../../resource.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../resource.h:  // Reference count used to manage resource lifetime. The vtable->destroy
../../resource.h:// Verifies that the vtable has the right resource sub-vtable.
../../resource.h:  iree_atomic_ref_count_init(&out_resource->ref_count);
../../resource.h:  out_resource->vtable = vtable;
../../resource.h:    iree_atomic_ref_count_inc(&resource->ref_count);
../../resource.h:// to use the type-specific release functions (such as iree_hal_buffer_release)
../../resource.h:// to allow for more optimizations and better compile-time type safety.
../../resource.h:      iree_atomic_ref_count_dec(&resource->ref_count) == 1) {
../../resource.h:    ((iree_hal_resource_vtable_t*)resource->vtable)->destroy(resource);
../../resource.h:  return resource ? ((const iree_hal_resource_t*)resource)->vtable == vtable
../../resource.h:// positives - do not rely on it for handling untrusted user input.
../../driver_registry.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../driver_registry.c://===----------------------------------------------------------------------===//
../../driver_registry.c://===----------------------------------------------------------------------===//
../../driver_registry.c:// An alternative would be to keep factories in an intrusive list - that way
../../driver_registry.c:// isolating/sandboxing/multi-versioning).
../../driver_registry.c:  registry->host_allocator = host_allocator;
../../driver_registry.c:  iree_slim_mutex_initialize(&registry->mutex);
../../driver_registry.c:  iree_allocator_t host_allocator = registry->host_allocator;
../../driver_registry.c:  iree_slim_mutex_deinitialize(&registry->mutex);
../../driver_registry.c:  iree_slim_mutex_lock(&registry->mutex);
../../driver_registry.c:  for (iree_host_size_t i = 0; i < registry->factory_count; ++i) {
../../driver_registry.c:    if (registry->factories[i] == factory) {
../../driver_registry.c:      registry->factory_count + 1 >= IREE_ARRAYSIZE(registry->factories)) {
../../driver_registry.c:        IREE_ARRAYSIZE(registry->factories));
../../driver_registry.c:    registry->factories[registry->factory_count++] = factory;
../../driver_registry.c:  iree_slim_mutex_unlock(&registry->mutex);
../../driver_registry.c:  iree_slim_mutex_lock(&registry->mutex);
../../driver_registry.c:  iree_host_size_t index = -1;
../../driver_registry.c:  for (iree_host_size_t i = 0; i < registry->factory_count; ++i) {
../../driver_registry.c:    if (registry->factories[i] != factory) continue;
../../driver_registry.c:  if (index == -1) {
../../driver_registry.c:    memmove((void*)&registry->factories[index], &registry->factories[index + 1],
../../driver_registry.c:            registry->factory_count - index - 1);
../../driver_registry.c:    registry->factories[--registry->factory_count] = NULL;
../../driver_registry.c:  iree_slim_mutex_unlock(&registry->mutex);
../../driver_registry.c:  storage_size += driver_info->driver_name.size;
../../driver_registry.c:  storage_size += driver_info->full_name.size;
../../driver_registry.c:      source_driver_info->driver_name, &target_driver_info->driver_name,
../../driver_registry.c:      source_driver_info->full_name, &target_driver_info->full_name,
../../driver_registry.c:  iree_slim_mutex_lock(&registry->mutex);
../../driver_registry.c:  for (iree_host_size_t i = 0; i < registry->factory_count; ++i) {
../../driver_registry.c:    const iree_hal_driver_factory_t* factory = registry->factories[i];
../../driver_registry.c:        factory->enumerate(factory->self, &driver_info_count, &driver_infos);
../../driver_registry.c:    for (iree_host_size_t i = 0; i < registry->factory_count; ++i) {
../../driver_registry.c:      const iree_hal_driver_factory_t* factory = registry->factories[i];
../../driver_registry.c:          factory->enumerate(factory->self, &driver_info_count, &driver_infos);
../../driver_registry.c:  iree_slim_mutex_unlock(&registry->mutex);
../../driver_registry.c:  iree_slim_mutex_lock(&registry->mutex);
../../driver_registry.c:  for (iree_host_size_t i = 0; i < registry->factory_count; ++i) {
../../driver_registry.c:        registry->factories[registry->factory_count - i - 1];
../../driver_registry.c:        factory->enumerate(factory->self, &driver_info_count, &driver_infos);
../../driver_registry.c:          &driver_infos[driver_info_count - j - 1];
../../driver_registry.c:      if (iree_string_view_equal(driver_name, driver_info->driver_name)) {
../../driver_registry.c:  // example a delay-loaded driver cannot be created even if it was enumerated.
../../driver_registry.c:    status = hit_factory->try_create(hit_factory->self, driver_name,
../../driver_registry.c:  iree_slim_mutex_unlock(&registry->mutex);
../../buffer_view_util.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../buffer_view_util.c://===----------------------------------------------------------------------===//
../../buffer_view_util.c://===----------------------------------------------------------------------===//
../../buffer_view_util.c:            "opaque and sub-byte aligned element types cannot be indexed");
../../buffer_view_util.c:        "opaque and sub-byte aligned element types cannot be indexed");
../../buffer_view_util.c:        "opaque and sub-byte aligned element types cannot be indexed");
../../buffer_view_util.c:    end_indices[i] = start_indices[i] + lengths[i] - 1;
../../buffer_view_util.c:  // Non-contiguous regions not yet implemented. Will be easier to detect when
../../buffer_view_util.c:      end_byte_offset - start_byte_offset + element_size;
../../buffer_view_util.c:        "non-contiguous range region computation not implemented");
../../buffer_view_util.c://===----------------------------------------------------------------------===//
../../buffer_view_util.c://===----------------------------------------------------------------------===//
../../buffer_view_util.c:  // Map the buffer into host-visible memory.
../../buffer_view_util.c:  // back to allocation -> generation -> copy.
../../buffer_view_util.c:    // Compatible with allocate -> map -> generate.
../../buffer_view_util.c:    // Allocate host-local memory first and generate into that.
../../buffer_view_util.c://===----------------------------------------------------------------------===//
../../buffer_view_util.c://===----------------------------------------------------------------------===//
../../buffer_view_util.c:  return iree_hal_parse_buffer_elements(params->data_str, params->element_type,
../../buffer_view_util.c:                                        mapping->contents);
../../buffer_view_util.c:      if (buffer_length < buffer_capacity - 1) { \
../../buffer_view_util.c:        buffer ? buffer_capacity - buffer_length : 0,
../../buffer_view_util.c:      buffer ? buffer_capacity - buffer_length : 0,
../../buffer_view_util.c:      buffer ? buffer_capacity - buffer_length : 0,
../../buffer_view_util.c:  // NOTE: we could see how many bytes are available in the builder (capacity -
../../buffer_view_util.c:  // size) and then pass those in to the initial format - if there's enough
../../string_util.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../string_util.h:// Parses a serialized element of |element_type| to its in-memory form.
../../buffer_transfer.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../buffer_transfer.c://===----------------------------------------------------------------------===//
../../buffer_transfer.c://===----------------------------------------------------------------------===//
../../buffer_transfer.c:// normal queue submission that allows for more fine-grained sequencing and
../../buffer_transfer.c:// in-flight operations concurrently using the buffer ranges.
../../buffer_transfer.c:  // Perform a full submit-and-wait. On devices with multiple queues this can
../../buffer_transfer.c:  // run out-of-order/overlapped with other work and return earlier than device
../../buffer_transfer.c://===----------------------------------------------------------------------===//
../../buffer_transfer.c://===----------------------------------------------------------------------===//
../../buffer_transfer.c:// cycles copying the memory (and possible PCIe round-trips) letting the device
../../buffer_transfer.c:      // Whole buffer copy requested - that could mean either, so take the min.
../../buffer_transfer.c:      // Specific length requested - validate that we have matching lengths.
../../buffer_transfer.c:  // memory) then we can use the fast zero-alloc path. This may actually be
../../buffer_transfer.c:  // device-local host-visible memory we'd be performing the transfer by pulling
../../buffer_transfer.c:  // TODO(benvanik): check for device-local -> device-local and avoid mapping.
../../buffer_transfer.c:    // TODO(benvanik): make this device-local + host-visible? can be better for
../../buffer_transfer.c://===----------------------------------------------------------------------===//
../../buffer_transfer.c:// Human-friendly/performance-hostile transfer APIs
../../buffer_transfer.c://===----------------------------------------------------------------------===//
../../buffer_transfer.c:    return iree_ok_status();  // No-op.
../../buffer_transfer.c:  // host->host is not allowed. We may want to support this one day to allow for
../../buffer_transfer.c:        "cannot perform host->host transfers via this API, use memcpy/memmove");
../../buffer_transfer.c:  // Check for overlap - like memcpy we require that the two ranges don't have
../../buffer_transfer.c:  // both device buffers - host and device should never alias: behavior is
../../buffer_transfer.c://===----------------------------------------------------------------------===//
../../buffer_transfer.c://===----------------------------------------------------------------------===//
../../buffer_transfer.c:  // We could pack this into the mapping but this composes better - it's small
../../buffer_transfer.c:  // All devices should be able to satisfy this host-local + mapping request.
../../buffer_transfer.c:      local_byte_length, &emulation_state->host_local_buffer);
../../buffer_transfer.c:    // Download (device->host) the data.
../../buffer_transfer.c:        device, iree_hal_make_device_transfer_buffer(mapping->buffer),
../../buffer_transfer.c:            emulation_state->host_local_buffer),
../../buffer_transfer.c:    // Map the scratch buffer: map-ception.
../../buffer_transfer.c:    // Code-wise it looks like this may loop back onto this emulated path
../../buffer_transfer.c:    // local IREE_HAL_BUFFER_USAGE_MAPPING memory - and we check that above.
../../buffer_transfer.c:    status = iree_hal_buffer_map_range(emulation_state->host_local_buffer,
../../buffer_transfer.c:                                       &emulation_state->host_local_mapping);
../../buffer_transfer.c:    // Note that we are giving back the host-local mapped contents to the user -
../../buffer_transfer.c:    mapping->contents = emulation_state->host_local_mapping.contents;
../../buffer_transfer.c:    mapping->impl.reserved[0] = (uint64_t)((uintptr_t)emulation_state);
../../buffer_transfer.c:        iree_hal_buffer_unmap_range(&emulation_state->host_local_mapping));
../../buffer_transfer.c:    iree_hal_buffer_release(emulation_state->host_local_buffer);
../../buffer_transfer.c:                                                mapping->impl.reserved[0]);
../../buffer_transfer.c:      iree_hal_buffer_unmap_range(&emulation_state->host_local_mapping);
../../buffer_transfer.c:      iree_all_bits_set(mapping->impl.allowed_access,
../../buffer_transfer.c:    // Upload (host->device) the data.
../../buffer_transfer.c:            emulation_state->host_local_buffer),
../../buffer_transfer.c:        0, iree_hal_make_device_transfer_buffer(mapping->buffer),
../../buffer_transfer.c:  iree_hal_buffer_release(emulation_state->host_local_buffer);
../../fence.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../fence.h://===----------------------------------------------------------------------===//
../../fence.h://===----------------------------------------------------------------------===//
../../fence.h:// is undefined if any queue operations using the fence are in-flight.
../../fence.h:// a no-op.
../../fence.h:// Creates a new fence joining all |fences| as a wait-all operation.
../../fence.h://===----------------------------------------------------------------------===//
../../fence.h://===----------------------------------------------------------------------===//
../../CMakeLists.txt:# CMake-only content.                                                          #
../../channel.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../channel.h://===----------------------------------------------------------------------===//
../../channel.h://===----------------------------------------------------------------------===//
../../channel.h:#define IREE_HAL_CHANNEL_RANK_DEFAULT ((int32_t) - 1)
../../channel.h:#define IREE_HAL_CHANNEL_COUNT_DEFAULT ((int32_t) - 1)
../../channel.h:#define IREE_HAL_CHANNEL_NO_COLOR ((int32_t) - 1)
../../channel.h:  // Implementation-defined identifier for the channel.
../../channel.h:  // User-defined group key for differentiating multiple channel groups.
../../channel.h://===----------------------------------------------------------------------===//
../../channel.h://===----------------------------------------------------------------------===//
../../semaphore.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../semaphore.h://===----------------------------------------------------------------------===//
../../semaphore.h://===----------------------------------------------------------------------===//
../../semaphore.h:// This originates from Vulkan having a lower-bound of INT_MAX for
../../semaphore.h:// that lower-bound. At ~100 signals per second it'll take 1.5+ years to
../../semaphore.h:// semaphores - so even if the process lives for years it's highly unlikely any
../../semaphore.h:#define IREE_HAL_SEMAPHORE_MAX_VALUE (2147483647ull - 1)
../../semaphore.h:// greater-than-or-equal-to (>=) this indicates the semaphore has failed.
../../semaphore.h:      // The top bits of a pointer are sign-extended from bit 47 so we can
../../semaphore.h:      // restore the top bit by left-shifting the upper bits and then
../../semaphore.h:      // right-shifting with sign extension. We only use a single bit today and
../../semaphore.h:      // clone is a no-op and the code will be returned without an allocation.
../../semaphore.h:      // https://en.wikipedia.org/wiki/X86-64#Canonical_form_addresses
../../semaphore.h:  // Indicates the HAL implementation can perform a host-side wait on the
../../semaphore.h:  // additional host-device synchronization.
../../semaphore.h:  // Indicates the HAL implementation can perform a device-side wait on the
../../semaphore.h:  // without host (or user-mode) involvement.
../../semaphore.h:  // Indicates the HAL implementation can perform a host-side signal of the
../../semaphore.h:  // additional host-device synchronization.
../../semaphore.h:  // Indicates the HAL implementation can perform a device-side signal of the
../../semaphore.h:  // without host (or user-mode) involvement.
../../semaphore.h:  // Semaphore is compatible with host-side emulation. Usage is allowed but will
../../semaphore.h:  // prevent the pipelining of submissions on the device-side.
../../semaphore.h:  // Semaphore is compatible with device-side usage. The host cannot observe or
../../semaphore.h://===----------------------------------------------------------------------===//
../../semaphore.h://===----------------------------------------------------------------------===//
../../semaphore.h:// release or a non-owning reference that remains live for as long as the HAL
../../semaphore.h://===----------------------------------------------------------------------===//
../../semaphore.h://===----------------------------------------------------------------------===//
../../semaphore.h:// Synchronization mechanism for host->device, device->host, host->host,
../../semaphore.h:// and device->device notification. Semaphores behave like Vulkan timeline
../../semaphore.h:// Another use of semaphores is device->device synchronization for setting up
../../semaphore.h:// perform non-trivial scheduling behavior without the need to wake the host.
../../semaphore.h:// timelines are generally used (specifically in the device->host case):
../../semaphore.h:// https://www.youtube.com/watch?v=SpE--Rf516Y
../../semaphore.h:// https://www.khronos.org/assets/uploads/developers/library/2018-xdc/Vulkan-Timeline-Semaphores-Part-1_Sep18.pdf
../../semaphore.h:// https://docs.microsoft.com/en-us/windows/win32/direct3d12/user-mode-heap-synchronization
../../semaphore.h:// supporting 64-bit payloads.
../../semaphore.h://===----------------------------------------------------------------------===//
../../semaphore.h://===----------------------------------------------------------------------===//
../../semaphore.h://===----------------------------------------------------------------------===//
../../semaphore.h://===----------------------------------------------------------------------===//
../../semaphore.h:// Erases the i-th semaphore from the list in-place with O(1).
../../allocator_heap.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../allocator_heap.c:                                 &allocator->resource);
../../allocator_heap.c:    allocator->host_allocator = host_allocator;
../../allocator_heap.c:    allocator->data_allocator = data_allocator;
../../allocator_heap.c:        identifier, &allocator->identifier,
../../allocator_heap.c:      iree_slim_mutex_initialize(&allocator->statistics.mutex);
../../allocator_heap.c:  iree_allocator_t host_allocator = allocator->host_allocator;
../../allocator_heap.c:  IREE_STATISTICS(iree_slim_mutex_deinitialize(&allocator->statistics.mutex));
../../allocator_heap.c:  return allocator->host_allocator;
../../allocator_heap.c:    iree_slim_mutex_lock(&allocator->statistics.mutex);
../../allocator_heap.c:    memcpy(out_statistics, &allocator->statistics.base,
../../allocator_heap.c:    iree_slim_mutex_unlock(&allocator->statistics.mutex);
../../allocator_heap.c:    // NOTE: lightweight as this is hit in normal pre-sizing usage.
../../allocator_heap.c:  // All buffers can be allocated on the heap and all heap-accessible buffers
../../allocator_heap.c:  if (iree_all_bits_set(params->type, IREE_HAL_MEMORY_TYPE_DEVICE_VISIBLE)) {
../../allocator_heap.c:    if (iree_any_bit_set(params->usage, IREE_HAL_BUFFER_USAGE_TRANSFER)) {
../../allocator_heap.c:    if (iree_any_bit_set(params->usage,
../../allocator_heap.c:  // Always ensure we are host-visible.
../../allocator_heap.c:  params->type |= IREE_HAL_MEMORY_TYPE_HOST_VISIBLE;
../../allocator_heap.c:  params->type &= ~IREE_HAL_MEMORY_TYPE_OPTIMAL;
../../allocator_heap.c:  params->usage |= IREE_HAL_BUFFER_USAGE_MAPPING_SCOPED |
../../allocator_heap.c:  // Coerce options into those required for use by heap-based devices.
../../allocator_heap.c:  IREE_STATISTICS(statistics = &allocator->statistics);
../../allocator_heap.c:      statistics, &compat_params, allocation_size, allocator->data_allocator,
../../allocator_heap.c:      allocator->host_allocator, &buffer));
../../allocator_heap.c:  // Coerce options into those required for use by heap-based devices.
../../allocator_heap.c:  iree_device_size_t allocation_size = external_buffer->size;
../../allocator_heap.c:  switch (external_buffer->type) {
../../allocator_heap.c:      ptr = external_buffer->handle.host_allocation.ptr;
../../allocator_heap.c:      ptr = (void*)((intptr_t)external_buffer->handle.device_allocation.ptr);
../../allocator_heap.c:      external_buffer->size, iree_make_byte_span(ptr, external_buffer->size),
../../allocator_heap.c:      release_callback, allocator->host_allocator, out_buffer);
../../allocator_heap.c:  out_external_buffer->type = requested_type;
../../allocator_heap.c:  out_external_buffer->flags = requested_flags;
../../allocator_heap.c:  out_external_buffer->size = mapping.contents.data_length;
../../allocator_heap.c:    out_external_buffer->handle.host_allocation.ptr = mapping.contents.data;
../../allocator_heap.c:    out_external_buffer->handle.device_allocation.ptr =
../../driver.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../driver.h://===----------------------------------------------------------------------===//
../../driver.h://===----------------------------------------------------------------------===//
../../driver.h:  // Full human-readable name of the driver for display.
../../driver.h://===----------------------------------------------------------------------===//
../../driver.h://===----------------------------------------------------------------------===//
../../driver.h:// Optionally takes a list of key-value parameters as defined by the device
../../driver.h:// Optionally takes a list of key-value parameters as defined by the device
../../driver.h:// The |device_path| is a driver-dependent string that identifies a particular
../../driver.h:// Optionally takes a list of key-value parameters as defined by the device
../../driver.h:// optional. The path is a driver-dependent string that identifies a particular
../../driver.h:// Creates the driver-defined "default" device.
../../driver.h://===----------------------------------------------------------------------===//
../../driver.h://===----------------------------------------------------------------------===//
../../buffer_view_util.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../buffer_view_util.h://===----------------------------------------------------------------------===//
../../buffer_view_util.h://===----------------------------------------------------------------------===//
../../buffer_view_util.h:// Only works with densely-packed representations.
../../buffer_view_util.h:// Only works with densely-packed representations.
../../buffer_view_util.h://===----------------------------------------------------------------------===//
../../buffer_view_util.h://===----------------------------------------------------------------------===//
../../buffer_view_util.h:// queue. Even better is to do all generation on-device via dispatches without
../../buffer_view_util.h:// where device-side generation isn't possible or memory consumption is not a
../../buffer_view_util.h://===----------------------------------------------------------------------===//
../../buffer_view_util.h://===----------------------------------------------------------------------===//
../../buffer_view_util.h:// will be allocated with |device_allocator| as a host-local/device-visible
../../buffer_view_util.h:// Converts buffer view elements into a fully-specified string-form format like
../../buffer_view_util.h:// Prints buffer view elements into a fully-specified string-form format like
../../event.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../event.h://===----------------------------------------------------------------------===//
../../event.h://===----------------------------------------------------------------------===//
../../event.h://===----------------------------------------------------------------------===//
../../event.h://===----------------------------------------------------------------------===//
../../event.h:// https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkEvent.html
../../event.h://===----------------------------------------------------------------------===//
../../event.h://===----------------------------------------------------------------------===//
../../queue.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../queue.h://===----------------------------------------------------------------------===//
../../queue.h://===----------------------------------------------------------------------===//
../../queue.h:// implementation-specific: a bit may represent a logical queue in an underlying
../../queue.h:// This enables just-in-time selection as a command buffer could be made
../../queue.h:#define IREE_HAL_QUEUE_AFFINITY_ANY ((iree_hal_queue_affinity_t)(-1))
../../detail.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../detail.h:// can rely on LTO to perform cross-compilation unit inlining/strip unused HAL
../../detail.h:       ->vtable)                                                           \
../../detail.h:      ->method_name
../../detail.h:          &((iree_hal_resource_t*)(type_name))->ref_count);              \
../../detail.h:            &((iree_hal_resource_t*)(type_name))->ref_count) == 1) {     \
../../executable.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../executable.h://===----------------------------------------------------------------------===//
../../executable.h://===----------------------------------------------------------------------===//
../../executable.h:// context-aware scoped caches. HAL implementations can use this to preserve
../../executable.h:// switch strategies and choose between them per-dispatch.
../../executable.h://===----------------------------------------------------------------------===//
../../executable.h://===----------------------------------------------------------------------===//
../../command_buffer.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../command_buffer.c:  if (((command_buffer)->mode & IREE_HAL_COMMAND_BUFFER_MODE_UNVALIDATED) == \
../../command_buffer.c:                                                     ->validation_state))
../../command_buffer.c://===----------------------------------------------------------------------===//
../../command_buffer.c://===----------------------------------------------------------------------===//
../../command_buffer.c:  IREE_ASSERT_LE((int)op->kind, IREE_HAL_COLLECTIVE_KIND_MAX_VALUE);
../../command_buffer.c:  IREE_ASSERT_LE((int)op->reduction, IREE_HAL_COLLECTIVE_REDUCTION_MAX_VALUE);
../../command_buffer.c:  IREE_ASSERT_LE((int)op->element_type,
../../command_buffer.c:  const iree_string_view_t kind_name = kind_names[(int)op->kind];
../../command_buffer.c:      element_type_names[(int)op->element_type];
../../command_buffer.c:  switch (op->kind) {
../../command_buffer.c:      length = snprintf(out_temp->buffer, sizeof(out_temp->buffer),
../../command_buffer.c:          reduction_names[(int)op->reduction];
../../command_buffer.c:      length = snprintf(out_temp->buffer, sizeof(out_temp->buffer),
../../command_buffer.c:  return length > 0 ? iree_make_string_view(out_temp->buffer, length)
../../command_buffer.c://===----------------------------------------------------------------------===//
../../command_buffer.c://===----------------------------------------------------------------------===//
../../command_buffer.c://===----------------------------------------------------------------------===//
../../command_buffer.c://===----------------------------------------------------------------------===//
../../command_buffer.c:  iree_hal_resource_initialize(vtable, &command_buffer->resource);
../../command_buffer.c:  command_buffer->mode = mode;
../../command_buffer.c:  command_buffer->allowed_categories = command_categories;
../../command_buffer.c:  command_buffer->queue_affinity = queue_affinity;
../../command_buffer.c:  command_buffer->binding_capacity = binding_capacity;
../../command_buffer.c:  command_buffer->binding_count = 0;
../../command_buffer.c:  command_buffer->validation_state = validation_state;
../../command_buffer.c:                              "inline command buffers must be one-shot");
../../command_buffer.c:  return command_buffer->mode;
../../command_buffer.c:  return command_buffer->allowed_categories;
../../command_buffer.c:    // No-op fill. All other validation is skipped.
../../command_buffer.c:    // No-op update. All other validation is skipped.
../../command_buffer.c:    // No-op copy. All other validation is skipped.
../../command_buffer.c:    // No-op dispatch. All implementations are expected to do this but we ensure
../../command_buffer.c:    // side-effects. Note that this does mean that validation is skipped and
../../command_buffer.c:  // take 4-5us which adds too much overhead when trying to get accurate timings
../../command_buffer.c:  // so that we could avoid the tracy_malloc overheads per-dispatch.
../../command_buffer.c://===----------------------------------------------------------------------===//
../../command_buffer.c://===----------------------------------------------------------------------===//
../../command_buffer.c:  if (command_buffer->binding_count == 0) {
../../command_buffer.c:                            command_buffer->binding_count);
../../command_buffer.c:  } else if (binding_table.count < command_buffer->binding_count) {
../../command_buffer.c:                            command_buffer->binding_count, binding_table.count);
../../command_buffer.c://===----------------------------------------------------------------------===//
../../command_buffer.c://===----------------------------------------------------------------------===//
../../command_buffer.c:      switch (transfer_command->type) {
../../command_buffer.c:              iree_hal_make_buffer_ref(transfer_command->fill.target_buffer,
../../command_buffer.c:                                       transfer_command->fill.target_offset,
../../command_buffer.c:                                       transfer_command->fill.length),
../../command_buffer.c:              transfer_command->fill.pattern,
../../command_buffer.c:              transfer_command->fill.pattern_length, IREE_HAL_FILL_FLAG_NONE);
../../command_buffer.c:              command_buffer, transfer_command->update.source_buffer,
../../command_buffer.c:              transfer_command->update.source_offset,
../../command_buffer.c:              iree_hal_make_buffer_ref(transfer_command->update.target_buffer,
../../command_buffer.c:                                       transfer_command->update.target_offset,
../../command_buffer.c:                                       transfer_command->update.length),
../../command_buffer.c:              iree_hal_make_buffer_ref(transfer_command->copy.source_buffer,
../../command_buffer.c:                                       transfer_command->copy.source_offset,
../../command_buffer.c:                                       transfer_command->copy.length),
../../command_buffer.c:              iree_hal_make_buffer_ref(transfer_command->copy.target_buffer,
../../command_buffer.c:                                       transfer_command->copy.target_offset,
../../command_buffer.c:                                       transfer_command->copy.length),
../../command_buffer.c:                               i, (int)transfer_command->type);
../../driver_registry.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../driver_registry.h://===----------------------------------------------------------------------===//
../../driver_registry.h://===----------------------------------------------------------------------===//
../../driver_registry.h:// Delay-loaded drivers that may require non-trivial setup time (such as those
../../driver_registry.h:  // User-defined pointer passed to all functions.
../../driver_registry.h:  // to change call-to-call. If a factory needs to mutate its set of enumerated
../../driver_registry.h:  // devices then it must do so by first unregistering itself and re-registering
../../driver_registry.h:  // Delay-loaded drivers may still fail here if - for example - required system
../../driver_registry.h://===----------------------------------------------------------------------===//
../../driver_registry.h://===----------------------------------------------------------------------===//
../../driver_registry.h:// Returns the default per-process driver registry.
../../driver_registry.h:// Thread-safe. The factory is not retained and must be kept alive by the caller
../../driver_registry.h:// Thread-safe. As the factory is not retained by the registry the caller must
../../driver_registry.h:// may be available for successful creation as it's possible that delay-loaded
../../driver_registry.h:// Thread-safe. Note that the factory may be unregistered between the query
../../driver_registry.h:// searched in most-recently-added order such that it's possible to override
../../driver_registry.h:// Thread-safe. May block the caller if the driver is delay-loaded and needs to
../../driver_registry.h:// Factories are searched in most-recently-added order such that it's possible
../../driver_registry.h:// optional. The path is a driver-dependent string that identifies a particular
../../driver_registry.h:// Thread-safe. May block the caller if the driver is delay-loaded and needs to
../../command_buffer.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../command_buffer.h://===----------------------------------------------------------------------===//
../../command_buffer.h://===----------------------------------------------------------------------===//
../../command_buffer.h:  // This may enable in-place patching of command buffers that reduce overhead
../../command_buffer.h:  // `IREE_HAL_COMMAND_BUFFER_VALIDATION_ENABLE=1` - if shimming command buffers
../../command_buffer.h:  // or performing replay this validation can be disabled per-command buffer.
../../command_buffer.h:  // Pseudo-stage for read/writes by the host. Not executed on device.
../../command_buffer.h:  // External/non-specific read.
../../command_buffer.h:  // External/non-specific write.
../../command_buffer.h:// These are cheaper to encode than buffer-specific barriers but may cause
../../command_buffer.h:// over equivalently large sets of buffer-specific barriers (such as when
../../command_buffer.h:  // All access scopes prior-to the barrier (inclusive).
../../command_buffer.h:// Use of these (vs. global memory barriers) provides fine-grained execution
../../command_buffer.h:  // All access scopes prior-to the barrier (inclusive).
../../command_buffer.h:  // In-place: |send_binding| == |recv_binding| + rank * |element_count|
../../command_buffer.h:  // In-place: |send_binding| == |recv_binding|
../../command_buffer.h:  // |recv_binding|: only used on non-source ranks
../../command_buffer.h:  // In-place: |send_binding| == |recv_binding|
../../command_buffer.h:  // In-place: |send_binding| == |recv_binding|
../../command_buffer.h:  // will contain the i-th block of the results.
../../command_buffer.h:  // In-place: |recv_binding| == |send_binding| + rank * |element_count|
../../command_buffer.h:  // type in |send_binding| the target rank, unless it is -1. Receives
../../command_buffer.h:  // source rank, unless it is -1, then the result will be all zeros.
../../command_buffer.h:// limited number of primitives as some may be backed by fixed-function
../../command_buffer.h:  // - IREE_HAL_DISPATCH_FLAG_DYNAMIC_INDIRECT_PARAMETERS:
../../command_buffer.h:  // - IREE_HAL_DISPATCH_FLAG_STATIC_INDIRECT_PARAMETERS:
../../command_buffer.h:  // Size, in bytes, of any dynamically-sized workgroup local memory required.
../../command_buffer.h:  // and have 4-byte alignment and represents a `uint32_t workgroup_count[3];`.
../../command_buffer.h://===----------------------------------------------------------------------===//
../../command_buffer.h://===----------------------------------------------------------------------===//
../../command_buffer.h:    // Indirect buffer reference - need to combine the final range based on
../../command_buffer.h:    out_resolved_ref->reserved = buffer_ref.reserved;
../../command_buffer.h:    out_resolved_ref->buffer_slot = 0;
../../command_buffer.h:    out_resolved_ref->buffer = binding->buffer;
../../command_buffer.h:        binding->length != IREE_HAL_WHOLE_BUFFER
../../command_buffer.h:            ? binding->length
../../command_buffer.h:            : iree_hal_buffer_byte_length(binding->buffer) - binding->offset;
../../command_buffer.h:        binding->offset, max_length, buffer_ref.offset, buffer_ref.length,
../../command_buffer.h:        &out_resolved_ref->offset, &out_resolved_ref->length);
../../command_buffer.h://===----------------------------------------------------------------------===//
../../command_buffer.h://===----------------------------------------------------------------------===//
../../command_buffer.h:// modified or read while there are commands in-flight. The usual flow is to
../../command_buffer.h:// be in-flight). In this case the user of the device queue should treat all
../../command_buffer.h:// in-flight operations as cancelled and fully reset themselves. Other device
../../command_buffer.h:// Command buffers are thread-compatible. Use multiple command buffers if trying
../../command_buffer.h:// referencing the binding table. Must only be non-zero for command buffer modes
../../command_buffer.h:// used on non-transfer queues.
../../command_buffer.h:// Resets an event to the non-signaled state.
../../command_buffer.h:// used on non-transfer queues.
../../command_buffer.h:// be used on non-transfer queues.
../../command_buffer.h:// the possibility of a zero-copy path.
../../command_buffer.h:// This can be used to perform device->host, host->device, and device->device
../../command_buffer.h:// dispatch made within the same barrier-defined sequence. The executable
../../command_buffer.h://===----------------------------------------------------------------------===//
../../command_buffer.h://===----------------------------------------------------------------------===//
../../command_buffer.h://===----------------------------------------------------------------------===//
../../command_buffer.h://===----------------------------------------------------------------------===//
../../command_buffer.h://===----------------------------------------------------------------------===//
../../command_buffer.h://===----------------------------------------------------------------------===//
../../drivers/init.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/init.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/init.h:// This only registers IREE core drivers (those under iree/hal/). User-provided
../../drivers/accel/accel_device.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/accel/accel_device.c:  // Shared semaphore state used to emulate OS-level primitives. This backend
../../drivers/accel/accel_device.c:  // is intended to run on bare-metal systems where we need to perform all
../../drivers/accel/accel_device.c:  out_params->arena_block_size = 32 * 1024;
../../drivers/accel/accel_device.c:  if (params->arena_block_size < 4096) {
../../drivers/accel/accel_device.c:      sizeof(*device) + loader_count * sizeof(*device->loaders);
../../drivers/accel/accel_device.c:                                 &device->resource);
../../drivers/accel/accel_device.c:    iree_string_view_append_to_buffer(identifier, &device->identifier,
../../drivers/accel/accel_device.c:    device->host_allocator = host_allocator;
../../drivers/accel/accel_device.c:    device->device_allocator = device_allocator;
../../drivers/accel/accel_device.c:    iree_arena_block_pool_initialize(params->arena_block_size, host_allocator,
../../drivers/accel/accel_device.c:                                     &device->large_block_pool);
../../drivers/accel/accel_device.c:    device->loader_count = loader_count;
../../drivers/accel/accel_device.c:    for (iree_host_size_t i = 0; i < device->loader_count; ++i) {
../../drivers/accel/accel_device.c:      device->loaders[i] = loaders[i];
../../drivers/accel/accel_device.c:      iree_hal_executable_loader_retain(device->loaders[i]);
../../drivers/accel/accel_device.c:    iree_hal_accel_semaphore_state_initialize(&device->semaphore_state);
../../drivers/accel/accel_device.c:    fprintf(stderr, "--- Custom accelerator initializing via libVtop.so ---\n");
../../drivers/accel/accel_device.c:  fprintf(stderr, "--- Custom accelerator deinitializing ---\n");
../../drivers/accel/accel_device.c:  // De-initialize the SA16 accelerator simulation.
../../drivers/accel/accel_device.c:  iree_hal_accel_semaphore_state_deinitialize(&device->semaphore_state);
../../drivers/accel/accel_device.c:  for (iree_host_size_t i = 0; i < device->loader_count; ++i) {
../../drivers/accel/accel_device.c:    iree_hal_executable_loader_release(device->loaders[i]);
../../drivers/accel/accel_device.c:  iree_hal_allocator_release(device->device_allocator);
../../drivers/accel/accel_device.c:  iree_hal_channel_provider_release(device->channel_provider);
../../drivers/accel/accel_device.c:  iree_arena_block_pool_deinitialize(&device->large_block_pool);
../../drivers/accel/accel_device.c:  return device->identifier;
../../drivers/accel/accel_device.c:  return device->host_allocator;
../../drivers/accel/accel_device.c:  return device->device_allocator;
../../drivers/accel/accel_device.c:  iree_hal_allocator_release(device->device_allocator);
../../drivers/accel/accel_device.c:  device->device_allocator = new_allocator;
../../drivers/accel/accel_device.c:  iree_hal_channel_provider_release(device->channel_provider);
../../drivers/accel/accel_device.c:  device->channel_provider = new_provider;
../../drivers/accel/accel_device.c:  return iree_hal_allocator_trim(device->device_allocator);
../../drivers/accel/accel_device.c:        iree_string_view_match_pattern(device->identifier, key) ? 1 : 0;
../../drivers/accel/accel_device.c:            device->loader_count, device->loaders, /*caching_mode=*/0, key)
../../drivers/accel/accel_device.c:        queue_affinity, binding_capacity, &device->large_block_pool,
../../drivers/accel/accel_device.c:        device->host_allocator, out_command_buffer);
../../drivers/accel/accel_device.c:      identifier, /*worker_capacity=*/1, device->loader_count, device->loaders,
../../drivers/accel/accel_device.c:  return iree_hal_accel_semaphore_create(&device->semaphore_state, initial_value,
../../drivers/accel/accel_device.c:                                        device->host_allocator, out_semaphore);
../../drivers/accel/accel_device.c:  // The synchronous submission queue handles all semaphores as if host-side.
../../drivers/accel/accel_device.c:  // TODO(benvanik): queue-ordered allocations.
../../drivers/accel/accel_device.c:  // TODO(benvanik): queue-ordered allocations.
../../drivers/accel/accel_device.c:  // If there were no deferred command buffers no-op this call - they've already
../../drivers/accel/accel_device.c:      device->device_allocator,
../../drivers/accel/accel_device.c:      /*binding_capacity=*/0, device->host_allocator, storage,
../../drivers/accel/accel_device.c:  // do - chances are we already executed everything inline!
../../drivers/accel/accel_device.c:      &device->semaphore_state, IREE_HAL_WAIT_MODE_ALL, wait_semaphore_list,
../../drivers/accel/accel_device.c:  // Run all deferred command buffers - any we could have run inline we already
../../drivers/accel/accel_device.c:      &device->semaphore_state, signal_semaphore_list));
../../drivers/accel/accel_device.c:  return iree_hal_accel_semaphore_multi_wait(&device->semaphore_state, wait_mode,
../../drivers/accel/accel_device.c:  // https://man7.org/linux/man-pages/man2/perf_event_open.2.html
../../drivers/hip/dispatch_thread.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/dispatch_thread.c:  iree_slim_mutex_lock(&thread->mutex);
../../drivers/hip/dispatch_thread.c:  bool has_request = !iree_hal_hip_dispatch_queue_empty(&thread->queue);
../../drivers/hip/dispatch_thread.c:  has_request |= thread->do_exit;
../../drivers/hip/dispatch_thread.c:  iree_slim_mutex_unlock(&thread->mutex);
../../drivers/hip/dispatch_thread.c:    iree_notification_await(&thread->notification,
../../drivers/hip/dispatch_thread.c:    iree_slim_mutex_lock(&thread->mutex);
../../drivers/hip/dispatch_thread.c:    exit |= thread->do_exit;
../../drivers/hip/dispatch_thread.c:    iree_status_t status = iree_status_clone(thread->failure_status);
../../drivers/hip/dispatch_thread.c:    while (!iree_hal_hip_dispatch_queue_empty(&thread->queue)) {
../../drivers/hip/dispatch_thread.c:          iree_hal_hip_dispatch_queue_at(&thread->queue, 0);
../../drivers/hip/dispatch_thread.c:      iree_hal_hip_dispatch_queue_pop_front(&thread->queue, 1);
../../drivers/hip/dispatch_thread.c:      iree_slim_mutex_unlock(&thread->mutex);
../../drivers/hip/dispatch_thread.c:      iree_slim_mutex_lock(&thread->mutex);
../../drivers/hip/dispatch_thread.c:        iree_status_ignore(thread->failure_status);
../../drivers/hip/dispatch_thread.c:        thread->failure_status = iree_status_clone(status);
../../drivers/hip/dispatch_thread.c:    iree_slim_mutex_unlock(&thread->mutex);
../../drivers/hip/dispatch_thread.c:      // Drop the status as it was cloned into thread->failure_status
../../drivers/hip/dispatch_thread.c:  thread->do_exit = false;
../../drivers/hip/dispatch_thread.c:  iree_slim_mutex_initialize(&thread->mutex);
../../drivers/hip/dispatch_thread.c:  iree_hal_hip_dispatch_queue_initialize(host_allocator, &thread->queue);
../../drivers/hip/dispatch_thread.c:  thread->failure_status = iree_ok_status();
../../drivers/hip/dispatch_thread.c:  thread->host_allocator = host_allocator;
../../drivers/hip/dispatch_thread.c:  iree_notification_initialize(&thread->notification);
../../drivers/hip/dispatch_thread.c:  params.name = iree_make_cstring_view("iree-hal-hip-dispatch");
../../drivers/hip/dispatch_thread.c:                         thread, params, host_allocator, &thread->thread);
../../drivers/hip/dispatch_thread.c:    iree_hal_hip_dispatch_queue_deinitialize(&thread->queue);
../../drivers/hip/dispatch_thread.c:    iree_slim_mutex_deinitialize(&thread->mutex);
../../drivers/hip/dispatch_thread.c:  iree_slim_mutex_lock(&thread->mutex);
../../drivers/hip/dispatch_thread.c:  thread->do_exit = true;
../../drivers/hip/dispatch_thread.c:  iree_slim_mutex_unlock(&thread->mutex);
../../drivers/hip/dispatch_thread.c:  iree_notification_post(&thread->notification, IREE_ALL_WAITERS);
../../drivers/hip/dispatch_thread.c:  iree_thread_release(thread->thread);
../../drivers/hip/dispatch_thread.c:  iree_status_ignore(thread->failure_status);
../../drivers/hip/dispatch_thread.c:  iree_hal_hip_dispatch_queue_deinitialize(&thread->queue);
../../drivers/hip/dispatch_thread.c:  iree_slim_mutex_deinitialize(&thread->mutex);
../../drivers/hip/dispatch_thread.c:  iree_allocator_free(thread->host_allocator, thread);
../../drivers/hip/dispatch_thread.c:  iree_slim_mutex_lock(&thread->mutex);
../../drivers/hip/dispatch_thread.c:  iree_status_t status = iree_status_clone(thread->failure_status);
../../drivers/hip/dispatch_thread.c:        iree_hal_hip_dispatch_queue_push_back(&thread->queue, dispatch_data);
../../drivers/hip/dispatch_thread.c:    iree_status_ignore(thread->failure_status);
../../drivers/hip/dispatch_thread.c:    thread->failure_status = iree_status_clone(status);
../../drivers/hip/dispatch_thread.c:  iree_slim_mutex_unlock(&thread->mutex);
../../drivers/hip/dispatch_thread.c:  iree_notification_post(&thread->notification, IREE_ALL_WAITERS);
../../drivers/hip/dispatch_thread.c:  // If this was a failure then it was put into thread->failure_status.
../../drivers/hip/dynamic_symbol_tables.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/dynamic_symbol_tables.h://===----------------------------------------------------------------------===//
../../drivers/hip/dynamic_symbol_tables.h://===----------------------------------------------------------------------===//
../../drivers/hip/stream_command_buffer.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/stream_command_buffer.c:  // Per-stream HIP tracing context.
../../drivers/hip/stream_command_buffer.c:  // Staging arena used for host->device transfers.
../../drivers/hip/stream_command_buffer.c:      &iree_hal_hip_stream_command_buffer_vtable, &command_buffer->base);
../../drivers/hip/stream_command_buffer.c:  command_buffer->host_allocator = host_allocator;
../../drivers/hip/stream_command_buffer.c:  command_buffer->hip_symbols = hip_symbols;
../../drivers/hip/stream_command_buffer.c:  command_buffer->nccl_symbols = nccl_symbols;
../../drivers/hip/stream_command_buffer.c:  command_buffer->tracing_context = tracing_context;
../../drivers/hip/stream_command_buffer.c:  command_buffer->tracing_event_list.head = NULL;
../../drivers/hip/stream_command_buffer.c:  command_buffer->tracing_event_list.tail = NULL;
../../drivers/hip/stream_command_buffer.c:  command_buffer->hip_stream = stream;
../../drivers/hip/stream_command_buffer.c:  iree_arena_initialize(block_pool, &command_buffer->arena);
../../drivers/hip/stream_command_buffer.c:      iree_hal_resource_set_allocate(block_pool, &command_buffer->resource_set);
../../drivers/hip/stream_command_buffer.c:    iree_hal_collective_batch_initialize(&command_buffer->arena,
../../drivers/hip/stream_command_buffer.c:                                         command_buffer->resource_set,
../../drivers/hip/stream_command_buffer.c:                                         &command_buffer->collective_batch);
../../drivers/hip/stream_command_buffer.c:  *out_command_buffer = &command_buffer->base;
../../drivers/hip/stream_command_buffer.c:  iree_allocator_t host_allocator = command_buffer->host_allocator;
../../drivers/hip/stream_command_buffer.c:  iree_hal_stream_tracing_free(command_buffer->tracing_context,
../../drivers/hip/stream_command_buffer.c:                               &command_buffer->tracing_event_list);
../../drivers/hip/stream_command_buffer.c:  iree_hal_collective_batch_deinitialize(&command_buffer->collective_batch);
../../drivers/hip/stream_command_buffer.c:  iree_hal_resource_set_free(command_buffer->resource_set);
../../drivers/hip/stream_command_buffer.c:  iree_arena_deinitialize(&command_buffer->arena);
../../drivers/hip/stream_command_buffer.c:  return iree_hal_resource_is(&command_buffer->resource,
../../drivers/hip/stream_command_buffer.c:  if (!command_buffer->tracing_context) {
../../drivers/hip/stream_command_buffer.c:  iree_hal_stream_tracing_notify_submitted(command_buffer->tracing_context,
../../drivers/hip/stream_command_buffer.c:                                           &command_buffer->tracing_event_list);
../../drivers/hip/stream_command_buffer.c:// Must be called before any other non-collective nodes are added to the graph
../../drivers/hip/stream_command_buffer.c:  // NOTE: we could move this out into callers by way of an always-inline shim -
../../drivers/hip/stream_command_buffer.c:          &command_buffer->collective_batch))) {
../../drivers/hip/stream_command_buffer.c:      command_buffer->nccl_symbols, command_buffer->tracing_context,
../../drivers/hip/stream_command_buffer.c:      &command_buffer->tracing_event_list, &command_buffer->collective_batch,
../../drivers/hip/stream_command_buffer.c:      command_buffer->hip_stream);
../../drivers/hip/stream_command_buffer.c:  iree_hal_collective_batch_clear(&command_buffer->collective_batch);
../../drivers/hip/stream_command_buffer.c:      command_buffer->tracing_context, &command_buffer->tracing_event_list,
../../drivers/hip/stream_command_buffer.c:  iree_arena_reset(&command_buffer->arena);
../../drivers/hip/stream_command_buffer.c:  iree_hal_resource_set_free(command_buffer->resource_set);
../../drivers/hip/stream_command_buffer.c:      z0, iree_hal_resource_set_allocate(command_buffer->arena.block_pool,
../../drivers/hip/stream_command_buffer.c:                                         &command_buffer->resource_set));
../../drivers/hip/stream_command_buffer.c:  IREE_HAL_STREAM_TRACE_ZONE_END(command_buffer->tracing_context,
../../drivers/hip/stream_command_buffer.c:                                 &command_buffer->tracing_event_list,
../../drivers/hip/stream_command_buffer.c:      command_buffer->tracing_context, &command_buffer->tracing_event_list,
../../drivers/hip/stream_command_buffer.c:      location ? location->file.data : NULL, location ? location->file.size : 0,
../../drivers/hip/stream_command_buffer.c:      location ? location->line : 0,
../../drivers/hip/stream_command_buffer.c:  IREE_HAL_STREAM_TRACE_ZONE_END(command_buffer->tracing_context,
../../drivers/hip/stream_command_buffer.c:                                 &command_buffer->tracing_event_list,
../../drivers/hip/stream_command_buffer.c:                            "non-zero barrier flag not yet supported");
../../drivers/hip/stream_command_buffer.c:  // Nothing to do for barriers between memory operations or dispatches--HIP
../../drivers/hip/stream_command_buffer.c:  IREE_HAL_STREAM_TRACE_ZONE_BEGIN(command_buffer->tracing_context,
../../drivers/hip/stream_command_buffer.c:                                   &command_buffer->tracing_event_list,
../../drivers/hip/stream_command_buffer.c:          z0, command_buffer->hip_symbols,
../../drivers/hip/stream_command_buffer.c:                            command_buffer->hip_stream),
../../drivers/hip/stream_command_buffer.c:          z0, command_buffer->hip_symbols,
../../drivers/hip/stream_command_buffer.c:                            command_buffer->hip_stream),
../../drivers/hip/stream_command_buffer.c:          z0, command_buffer->hip_symbols,
../../drivers/hip/stream_command_buffer.c:                           command_buffer->hip_stream),
../../drivers/hip/stream_command_buffer.c:  IREE_HAL_STREAM_TRACE_ZONE_END(command_buffer->tracing_context,
../../drivers/hip/stream_command_buffer.c:                                 &command_buffer->tracing_event_list,
../../drivers/hip/stream_command_buffer.c:  if (command_buffer->arena.block_pool) {
../../drivers/hip/stream_command_buffer.c:        z0, iree_arena_allocate(&command_buffer->arena, target_ref.length,
../../drivers/hip/stream_command_buffer.c:  IREE_HAL_STREAM_TRACE_ZONE_BEGIN(command_buffer->tracing_context,
../../drivers/hip/stream_command_buffer.c:                                   &command_buffer->tracing_event_list,
../../drivers/hip/stream_command_buffer.c:      z0, command_buffer->hip_symbols,
../../drivers/hip/stream_command_buffer.c:                         command_buffer->hip_stream),
../../drivers/hip/stream_command_buffer.c:  IREE_HAL_STREAM_TRACE_ZONE_END(command_buffer->tracing_context,
../../drivers/hip/stream_command_buffer.c:                                 &command_buffer->tracing_event_list,
../../drivers/hip/stream_command_buffer.c:  IREE_HAL_STREAM_TRACE_ZONE_BEGIN(command_buffer->tracing_context,
../../drivers/hip/stream_command_buffer.c:                                   &command_buffer->tracing_event_list,
../../drivers/hip/stream_command_buffer.c:      z0, command_buffer->hip_symbols,
../../drivers/hip/stream_command_buffer.c:                     command_buffer->hip_stream),
../../drivers/hip/stream_command_buffer.c:  IREE_HAL_STREAM_TRACE_ZONE_END(command_buffer->tracing_context,
../../drivers/hip/stream_command_buffer.c:                                 &command_buffer->tracing_event_list,
../../drivers/hip/stream_command_buffer.c:      &command_buffer->collective_batch, channel, op, param, send_binding,
../../drivers/hip/stream_command_buffer.c:  // Lookup kernel parameters used for side-channeling additional launch
../../drivers/hip/stream_command_buffer.c:              executable, entry_point, command_buffer->base.queue_affinity,
../../drivers/hip/stream_command_buffer.c:      command_buffer->tracing_context, &command_buffer->tracing_event_list,
../../drivers/hip/stream_command_buffer.c:      kernel_params->debug_info.source_filename.data,
../../drivers/hip/stream_command_buffer.c:      kernel_params->debug_info.source_filename.size,
../../drivers/hip/stream_command_buffer.c:      kernel_params->debug_info.source_line,
../../drivers/hip/stream_command_buffer.c:      kernel_params->debug_info.function_name.data,
../../drivers/hip/stream_command_buffer.c:      kernel_params->debug_info.function_name.size,
../../drivers/hip/stream_command_buffer.c:      z0, iree_hal_resource_set_insert(command_buffer->resource_set, 1,
../../drivers/hip/stream_command_buffer.c:      kernel_params->binding_count + kernel_params->constant_count;
../../drivers/hip/stream_command_buffer.c:  // TODO: use packed parameters instead of the indirection mechanism - this
../../drivers/hip/stream_command_buffer.c:      z0, iree_arena_allocate(&command_buffer->arena, total_size,
../../drivers/hip/stream_command_buffer.c:    if (binding->buffer) {
../../drivers/hip/stream_command_buffer.c:          z0, iree_hal_resource_set_insert(command_buffer->resource_set, 1,
../../drivers/hip/stream_command_buffer.c:                                           &binding->buffer));
../../drivers/hip/stream_command_buffer.c:          iree_hal_buffer_allocated_buffer(binding->buffer));
../../drivers/hip/stream_command_buffer.c:      iree_device_size_t offset = iree_hal_buffer_byte_offset(binding->buffer);
../../drivers/hip/stream_command_buffer.c:      device_ptr = (uint8_t*)device_buffer + offset + binding->offset;
../../drivers/hip/stream_command_buffer.c:  // are just storing a 32-bit value for the push constant here instead. So we
../../drivers/hip/stream_command_buffer.c:  // must process one element each type, for 64-bit machines.
../../drivers/hip/stream_command_buffer.c:  for (iree_host_size_t i = 0; i < kernel_params->constant_count; i++) {
../../drivers/hip/stream_command_buffer.c:    *((uint32_t*)params_ptr[kernel_params->binding_count + i]) =
../../drivers/hip/stream_command_buffer.c:      command_buffer->hip_symbols,
../../drivers/hip/stream_command_buffer.c:          kernel_params->function, config.workgroup_count[0],
../../drivers/hip/stream_command_buffer.c:                                   : kernel_params->block_dims[0],
../../drivers/hip/stream_command_buffer.c:                                   : kernel_params->block_dims[1],
../../drivers/hip/stream_command_buffer.c:                                   : kernel_params->block_dims[2],
../../drivers/hip/stream_command_buffer.c:          /*sharedMemBytes=*/0, command_buffer->hip_stream, params_ptr, NULL),
../../drivers/hip/stream_command_buffer.c:  IREE_HAL_STREAM_TRACE_ZONE_END(command_buffer->tracing_context,
../../drivers/hip/stream_command_buffer.c:                                 &command_buffer->tracing_event_list,
../../drivers/hip/stream_command_buffer.c:  return command_buffer->tracing_event_list;
../../drivers/hip/util/tree.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/util/tree.h://===----------------------------------------------------------------------===//
../../drivers/hip/util/tree.h://===----------------------------------------------------------------------===//
../../drivers/hip/util/tree.h://===----------------------------------------------------------------------===//
../../drivers/hip/util/tree.h://===----------------------------------------------------------------------===//
../../drivers/hip/memory_pools.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/memory_pools.c:// device-specific ones by malloc() and leaking (with LSAN note) unique string
../../drivers/hip/memory_pools.c:    "HIP pool: device-local reserved";
../../drivers/hip/memory_pools.c:  out_pools->parent_device = parent_device;
../../drivers/hip/memory_pools.c:  out_pools->hip_symbols = hip_symbols;
../../drivers/hip/memory_pools.c:  out_pools->host_allocator = host_allocator;
../../drivers/hip/memory_pools.c:                                             pooling_params->device_local,
../../drivers/hip/memory_pools.c:                                             &out_pools->device_local);
../../drivers/hip/memory_pools.c:        hip_symbols, hip_device, pooling_params->other, &out_pools->other);
../../drivers/hip/memory_pools.c:  if (pools->device_local) {
../../drivers/hip/memory_pools.c:    IREE_HIP_IGNORE_ERROR(pools->hip_symbols,
../../drivers/hip/memory_pools.c:                          hipMemPoolDestroy(pools->device_local));
../../drivers/hip/memory_pools.c:    pools->device_local = NULL;
../../drivers/hip/memory_pools.c:  if (pools->other) {
../../drivers/hip/memory_pools.c:    IREE_HIP_IGNORE_ERROR(pools->hip_symbols, hipMemPoolDestroy(pools->other));
../../drivers/hip/memory_pools.c:    pools->other = NULL;
../../drivers/hip/memory_pools.c:        is_device_local ? &pools->statistics.device_bytes_allocated
../../drivers/hip/memory_pools.c:                        : &pools->statistics.host_bytes_allocated;
../../drivers/hip/memory_pools.c:        is_device_local ? &pools->statistics.device_bytes_freed
../../drivers/hip/memory_pools.c:                        : &pools->statistics.host_bytes_freed;
../../drivers/hip/memory_pools.c:    statistics->device_bytes_allocated = iree_atomic_load(
../../drivers/hip/memory_pools.c:        &pools->statistics.device_bytes_allocated, iree_memory_order_relaxed);
../../drivers/hip/memory_pools.c:    statistics->host_bytes_allocated = iree_atomic_load(
../../drivers/hip/memory_pools.c:        &pools->statistics.host_bytes_allocated, iree_memory_order_relaxed);
../../drivers/hip/memory_pools.c:    statistics->device_bytes_freed = iree_atomic_load(
../../drivers/hip/memory_pools.c:        &pools->statistics.device_bytes_freed, iree_memory_order_relaxed);
../../drivers/hip/memory_pools.c:    statistics->host_bytes_freed = iree_atomic_load(
../../drivers/hip/memory_pools.c:        &pools->statistics.host_bytes_freed, iree_memory_order_relaxed);
../../drivers/hip/memory_pools.c:    if (pools->device_local) {
../../drivers/hip/memory_pools.c:          pools->hip_symbols,
../../drivers/hip/memory_pools.c:          hipMemPoolGetAttribute(pools->device_local, hipMemPoolAttrUsedMemHigh,
../../drivers/hip/memory_pools.c:      statistics->device_bytes_peak += (iree_device_size_t)pool_peak;
../../drivers/hip/memory_pools.c:    if (pools->other) {
../../drivers/hip/memory_pools.c:          pools->hip_symbols,
../../drivers/hip/memory_pools.c:          hipMemPoolGetAttribute(pools->other, hipMemPoolAttrUsedMemHigh,
../../drivers/hip/memory_pools.c:      statistics->host_bytes_peak += (iree_device_size_t)pool_peak;
../../drivers/hip/memory_pools.c:      pools->hip_symbols,
../../drivers/hip/memory_pools.c:      hipMemPoolTrimTo(pools->device_local,
../../drivers/hip/memory_pools.c:                       pooling_params->device_local.minimum_capacity),
../../drivers/hip/memory_pools.c:      pools->hip_symbols,
../../drivers/hip/memory_pools.c:      hipMemPoolTrimTo(pools->other, pooling_params->other.minimum_capacity),
../../drivers/hip/memory_pools.c:// the release callback so that this isn't called and we don't double-free.
../../drivers/hip/memory_pools.c:    IREE_HIP_IGNORE_ERROR(pools->hip_symbols, hipFree(device_ptr));
../../drivers/hip/memory_pools.c:          ? pools->device_local
../../drivers/hip/memory_pools.c:          : pools->other;
../../drivers/hip/memory_pools.c:      pools->hip_symbols,
../../drivers/hip/memory_pools.c:      .device = pools->parent_device,
../../drivers/hip/memory_pools.c:      release_callback, pools->host_allocator, &buffer);
../../drivers/hip/memory_pools.c:      status = IREE_HIP_CALL_TO_STATUS(pools->hip_symbols, hipFree(device_ptr),
../../drivers/hip/memory_pools.c:      // Drop the release callback so that we don't try to double-free the
../../drivers/hip/dynamic_symbols.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/dynamic_symbols.c://===----------------------------------------------------------------------===//
../../drivers/hip/dynamic_symbols.c://===----------------------------------------------------------------------===//
../../drivers/hip/dynamic_symbols.c:        syms->dylib, name, (void**)&syms->hip_symbol_name)); \
../../drivers/hip/dynamic_symbols.c:        syms->dylib, name, (void**)&syms->hip_symbol_name)); \
../../drivers/hip/dynamic_symbols.c:              host_allocator, &error_builder, &out_syms->dylib)) {
../../drivers/hip/dynamic_symbols.c:                host_allocator, &error_builder, &out_syms->dylib)) {
../../drivers/hip/dynamic_symbols.c:                  host_allocator, &error_builder, &out_syms->dylib)) {
../../drivers/hip/dynamic_symbols.c:  iree_dynamic_library_release(syms->dylib);
../../drivers/hip/dynamic_symbols.c:  if (!syms->dylib) {
../../drivers/hip/dynamic_symbols.c:  return iree_dynamic_library_append_symbol_path_to_builder(syms->hipDeviceGet,
../../drivers/hip/hip_allocator.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/per_device_information.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/util/CMakeLists.txt:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/rccl_status_util.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/rccl_status_util.h:  iree_hal_hip_nccl_result_to_status((syms), ((syms)->expr), __FILE__, __LINE__)
../../drivers/hip/rccl_status_util.h:                           (syms), ((syms)->expr), __FILE__, __LINE__), \
../../drivers/hip/rccl_status_util.h:      iree_hal_hip_nccl_result_to_status((syms), ((syms)->expr), __FILE__, \
../../drivers/hip/rccl_status_util.h:  IREE_IGNORE_ERROR(iree_hal_hip_nccl_result_to_status((syms), ((syms)->expr), \
../../drivers/hip/util/queue.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/util/queue.h:// re-allocation of data.
../../drivers/hip/util/queue.h:  bool name##_empty(name##_t* queue) { return queue->element_count == 0; }     \
../../drivers/hip/util/queue.h:    return queue->element_count;                                               \
../../drivers/hip/graph_command_buffer.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/graph_command_buffer.c:  // Per-stream HIP tracing context.
../../drivers/hip/graph_command_buffer.c:  // Staging arena used for host->device transfers.
../../drivers/hip/graph_command_buffer.c:  if (IREE_UNLIKELY(command_buffer->graph_node_count != 0)) {
../../drivers/hip/graph_command_buffer.c:      &command_buffer->hip_graph_nodes[command_buffer->graph_node_count++];
../../drivers/hip/graph_command_buffer.c:  size_t dependency_count = command_buffer->hip_barrier_node ? 1 : 0;
../../drivers/hip/graph_command_buffer.c:      command_buffer->tracing_context, &command_buffer->tracing_event_list,
../../drivers/hip/graph_command_buffer.c:      (iree_hal_stream_tracing_native_graph_t*)command_buffer->hip_graph,
../../drivers/hip/graph_command_buffer.c:          ->hip_barrier_node,
../../drivers/hip/graph_command_buffer.c:  command_buffer->hip_barrier_node = *tracing_event_node;
../../drivers/hip/graph_command_buffer.c:  if (IREE_UNLIKELY(command_buffer->graph_node_count != 0)) {
../../drivers/hip/graph_command_buffer.c:      &command_buffer->hip_graph_nodes[command_buffer->graph_node_count++];
../../drivers/hip/graph_command_buffer.c:  size_t dependency_count = command_buffer->hip_barrier_node ? 1 : 0;
../../drivers/hip/graph_command_buffer.c:      command_buffer->tracing_context, &command_buffer->tracing_event_list,
../../drivers/hip/graph_command_buffer.c:      (iree_hal_stream_tracing_native_graph_t*)command_buffer->hip_graph,
../../drivers/hip/graph_command_buffer.c:          ->hip_barrier_node,
../../drivers/hip/graph_command_buffer.c:  // GPU tracing zones are first-in, last-out.
../../drivers/hip/graph_command_buffer.c:  command_buffer->hip_barrier_node = *tracing_event_node;
../../drivers/hip/graph_command_buffer.c:      &iree_hal_hip_graph_command_buffer_vtable, &command_buffer->base);
../../drivers/hip/graph_command_buffer.c:  command_buffer->host_allocator = host_allocator;
../../drivers/hip/graph_command_buffer.c:  command_buffer->symbols = hip_symbols;
../../drivers/hip/graph_command_buffer.c:  command_buffer->tracing_context = tracing_context;
../../drivers/hip/graph_command_buffer.c:  command_buffer->tracing_event_list.head = NULL;
../../drivers/hip/graph_command_buffer.c:  command_buffer->tracing_event_list.tail = NULL;
../../drivers/hip/graph_command_buffer.c:  iree_arena_initialize(block_pool, &command_buffer->arena);
../../drivers/hip/graph_command_buffer.c:  command_buffer->hip_context = context;
../../drivers/hip/graph_command_buffer.c:  command_buffer->hip_graph = NULL;
../../drivers/hip/graph_command_buffer.c:  command_buffer->hip_exec = NULL;
../../drivers/hip/graph_command_buffer.c:  command_buffer->hip_barrier_node = NULL;
../../drivers/hip/graph_command_buffer.c:  command_buffer->graph_node_count = 0;
../../drivers/hip/graph_command_buffer.c:      iree_hal_resource_set_allocate(block_pool, &command_buffer->resource_set);
../../drivers/hip/graph_command_buffer.c:    iree_hal_collective_batch_initialize(&command_buffer->arena,
../../drivers/hip/graph_command_buffer.c:                                         command_buffer->resource_set,
../../drivers/hip/graph_command_buffer.c:                                         &command_buffer->collective_batch);
../../drivers/hip/graph_command_buffer.c:    *out_command_buffer = &command_buffer->base;
../../drivers/hip/graph_command_buffer.c:    iree_hal_command_buffer_release(&command_buffer->base);
../../drivers/hip/graph_command_buffer.c:  iree_allocator_t host_allocator = command_buffer->host_allocator;
../../drivers/hip/graph_command_buffer.c:  iree_hal_stream_tracing_free(command_buffer->tracing_context,
../../drivers/hip/graph_command_buffer.c:                               &command_buffer->tracing_event_list);
../../drivers/hip/graph_command_buffer.c:  iree_hal_collective_batch_clear(&command_buffer->collective_batch);
../../drivers/hip/graph_command_buffer.c:  if (command_buffer->hip_graph != NULL) {
../../drivers/hip/graph_command_buffer.c:    IREE_HIP_IGNORE_ERROR(command_buffer->symbols,
../../drivers/hip/graph_command_buffer.c:                          hipGraphDestroy(command_buffer->hip_graph));
../../drivers/hip/graph_command_buffer.c:    command_buffer->hip_graph = NULL;
../../drivers/hip/graph_command_buffer.c:  if (command_buffer->hip_exec != NULL) {
../../drivers/hip/graph_command_buffer.c:    IREE_HIP_IGNORE_ERROR(command_buffer->symbols,
../../drivers/hip/graph_command_buffer.c:                          hipGraphExecDestroy(command_buffer->hip_exec));
../../drivers/hip/graph_command_buffer.c:    command_buffer->hip_exec = NULL;
../../drivers/hip/graph_command_buffer.c:  command_buffer->hip_barrier_node = NULL;
../../drivers/hip/graph_command_buffer.c:  command_buffer->graph_node_count = 0;
../../drivers/hip/graph_command_buffer.c:  iree_hal_collective_batch_deinitialize(&command_buffer->collective_batch);
../../drivers/hip/graph_command_buffer.c:  iree_hal_resource_set_free(command_buffer->resource_set);
../../drivers/hip/graph_command_buffer.c:  iree_arena_deinitialize(&command_buffer->arena);
../../drivers/hip/graph_command_buffer.c:  return iree_hal_resource_is(&command_buffer->resource,
../../drivers/hip/graph_command_buffer.c:  return command_buffer->hip_exec;
../../drivers/hip/graph_command_buffer.c:  if (!command_buffer->tracing_context) {
../../drivers/hip/graph_command_buffer.c:  iree_hal_stream_tracing_notify_submitted(command_buffer->tracing_context,
../../drivers/hip/graph_command_buffer.c:                                           &command_buffer->tracing_event_list);
../../drivers/hip/graph_command_buffer.c:// Must be called before any other non-collective nodes are added to the graph
../../drivers/hip/graph_command_buffer.c:  // NOTE: we could move this out into callers by way of an always-inline shim -
../../drivers/hip/graph_command_buffer.c:          &command_buffer->collective_batch))) {
../../drivers/hip/graph_command_buffer.c:  // https://docs.nvidia.com/deeplearning/nccl/user-guide/docs/usage/hipgraph.html
../../drivers/hip/graph_command_buffer.c:  //  syms->cuStreamBeginCapture(nccl_stream);
../../drivers/hip/graph_command_buffer.c:  //  iree_hal_hip_nccl_submit_batch(command_buffer->context,
../../drivers/hip/graph_command_buffer.c:  //                                  &command_buffer->collective_batch,
../../drivers/hip/graph_command_buffer.c:  //  syms->cuStreamEndCapture(nccl_stream, &child_graph);
../../drivers/hip/graph_command_buffer.c:  //  syms->cuGraphAddChildGraphNode(..., child_graph);
../../drivers/hip/graph_command_buffer.c:  //  syms->cuGraphDestroy(child_graph);  // probably, I think it gets cloned
../../drivers/hip/graph_command_buffer.c:  // capture - we could memoize that on the command buffer or on the device
../../drivers/hip/graph_command_buffer.c:  // stream mode for these capture-only streams that is lighter weight than a
../../drivers/hip/graph_command_buffer.c:  iree_hal_collective_batch_clear(&command_buffer->collective_batch);
../../drivers/hip/graph_command_buffer.c:  if (command_buffer->hip_graph != NULL) {
../../drivers/hip/graph_command_buffer.c:                            "command buffer cannot be re-recorded");
../../drivers/hip/graph_command_buffer.c:      command_buffer->symbols,
../../drivers/hip/graph_command_buffer.c:      hipGraphCreate(&command_buffer->hip_graph, /*flags=*/0),
../../drivers/hip/graph_command_buffer.c:  command_buffer->hip_barrier_node = NULL;
../../drivers/hip/graph_command_buffer.c:  command_buffer->graph_node_count = 0;
../../drivers/hip/graph_command_buffer.c:      command_buffer->symbols,
../../drivers/hip/graph_command_buffer.c:      hipGraphInstantiate(&command_buffer->hip_exec, command_buffer->hip_graph,
../../drivers/hip/graph_command_buffer.c:    IREE_HIP_IGNORE_ERROR(command_buffer->symbols,
../../drivers/hip/graph_command_buffer.c:                          hipGraphDestroy(command_buffer->hip_graph));
../../drivers/hip/graph_command_buffer.c:    command_buffer->hip_graph = NULL;
../../drivers/hip/graph_command_buffer.c:  iree_hal_resource_set_freeze(command_buffer->resource_set);
../../drivers/hip/graph_command_buffer.c:      location ? location->file.data : NULL, location ? location->file.size : 0,
../../drivers/hip/graph_command_buffer.c:      location ? location->line : 0,
../../drivers/hip/graph_command_buffer.c:  IREE_ASSERT_GT(command_buffer->graph_node_count, 0,
../../drivers/hip/graph_command_buffer.c:  if (IREE_LIKELY(command_buffer->graph_node_count == 1)) {
../../drivers/hip/graph_command_buffer.c:    command_buffer->hip_barrier_node = command_buffer->hip_graph_nodes[0];
../../drivers/hip/graph_command_buffer.c:    command_buffer->graph_node_count = 0;
../../drivers/hip/graph_command_buffer.c:      command_buffer->symbols,
../../drivers/hip/graph_command_buffer.c:          &command_buffer->hip_barrier_node, command_buffer->hip_graph,
../../drivers/hip/graph_command_buffer.c:          command_buffer->hip_graph_nodes, command_buffer->graph_node_count),
../../drivers/hip/graph_command_buffer.c:  command_buffer->graph_node_count = 0;
../../drivers/hip/graph_command_buffer.c:      z0, iree_hal_resource_set_insert(command_buffer->resource_set, 1,
../../drivers/hip/graph_command_buffer.c:  if (command_buffer->graph_node_count >=
../../drivers/hip/graph_command_buffer.c:  size_t dependency_count = command_buffer->hip_barrier_node ? 1 : 0;
../../drivers/hip/graph_command_buffer.c:      z0, command_buffer->symbols,
../../drivers/hip/graph_command_buffer.c:          &command_buffer->hip_graph_nodes[command_buffer->graph_node_count++],
../../drivers/hip/graph_command_buffer.c:          command_buffer->hip_graph, &command_buffer->hip_barrier_node,
../../drivers/hip/graph_command_buffer.c:  if (command_buffer->symbols->hipDrvGraphAddMemcpyNode == NULL) {
../../drivers/hip/graph_command_buffer.c:                            "cannot use graph-based command buffer");
../../drivers/hip/graph_command_buffer.c:      z0, iree_arena_allocate(&command_buffer->arena, target_ref.length,
../../drivers/hip/graph_command_buffer.c:      z0, iree_hal_resource_set_insert(command_buffer->resource_set, 1,
../../drivers/hip/graph_command_buffer.c:  if (command_buffer->graph_node_count >=
../../drivers/hip/graph_command_buffer.c:  size_t dependency_count = command_buffer->hip_barrier_node ? 1 : 0;
../../drivers/hip/graph_command_buffer.c:      z0, command_buffer->symbols,
../../drivers/hip/graph_command_buffer.c:          &command_buffer->hip_graph_nodes[command_buffer->graph_node_count++],
../../drivers/hip/graph_command_buffer.c:          command_buffer->hip_graph, &command_buffer->hip_barrier_node,
../../drivers/hip/graph_command_buffer.c:          dependency_count, &params, command_buffer->hip_context),
../../drivers/hip/graph_command_buffer.c:  if (command_buffer->symbols->hipDrvGraphAddMemcpyNode == NULL) {
../../drivers/hip/graph_command_buffer.c:                            "cannot use graph-based command buffer");
../../drivers/hip/graph_command_buffer.c:      iree_hal_resource_set_insert(command_buffer->resource_set, 2, buffers));
../../drivers/hip/graph_command_buffer.c:  if (command_buffer->graph_node_count >=
../../drivers/hip/graph_command_buffer.c:  size_t dependency_count = command_buffer->hip_barrier_node ? 1 : 0;
../../drivers/hip/graph_command_buffer.c:      z0, command_buffer->symbols,
../../drivers/hip/graph_command_buffer.c:          &command_buffer->hip_graph_nodes[command_buffer->graph_node_count++],
../../drivers/hip/graph_command_buffer.c:          command_buffer->hip_graph, &command_buffer->hip_barrier_node,
../../drivers/hip/graph_command_buffer.c:          dependency_count, &params, command_buffer->hip_context),
../../drivers/hip/graph_command_buffer.c:  return iree_hal_collective_batch_append(&command_buffer->collective_batch,
../../drivers/hip/graph_command_buffer.c:  // Lookup kernel parameters used for side-channeling additional launch
../../drivers/hip/graph_command_buffer.c:              executable, entry_point, command_buffer->base.queue_affinity,
../../drivers/hip/graph_command_buffer.c:      kernel_params->debug_info.source_filename.data,
../../drivers/hip/graph_command_buffer.c:      kernel_params->debug_info.source_filename.size,
../../drivers/hip/graph_command_buffer.c:      kernel_params->debug_info.source_line,
../../drivers/hip/graph_command_buffer.c:      kernel_params->debug_info.function_name.data,
../../drivers/hip/graph_command_buffer.c:      kernel_params->debug_info.function_name.size, /*name=*/NULL, 0);
../../drivers/hip/graph_command_buffer.c:      z0, iree_hal_resource_set_insert(command_buffer->resource_set, 1,
../../drivers/hip/graph_command_buffer.c:      kernel_params->binding_count + kernel_params->constant_count;
../../drivers/hip/graph_command_buffer.c:  // TODO: use packed parameters instead of the indirection mechanism - this
../../drivers/hip/graph_command_buffer.c:      z0, iree_arena_allocate(&command_buffer->arena, total_size,
../../drivers/hip/graph_command_buffer.c:    if (binding->buffer) {
../../drivers/hip/graph_command_buffer.c:          z0, iree_hal_resource_set_insert(command_buffer->resource_set, 1,
../../drivers/hip/graph_command_buffer.c:                                           &binding->buffer));
../../drivers/hip/graph_command_buffer.c:          iree_hal_buffer_allocated_buffer(binding->buffer));
../../drivers/hip/graph_command_buffer.c:      iree_device_size_t offset = iree_hal_buffer_byte_offset(binding->buffer);
../../drivers/hip/graph_command_buffer.c:      device_ptr = (uint8_t*)device_buffer + offset + binding->offset;
../../drivers/hip/graph_command_buffer.c:  // pointer on the target machine. we are just storing a 32-bit value for the
../../drivers/hip/graph_command_buffer.c:  // 64-bit machines.
../../drivers/hip/graph_command_buffer.c:  for (iree_host_size_t i = 0; i < kernel_params->constant_count; i++) {
../../drivers/hip/graph_command_buffer.c:    *((uint32_t*)params_ptr[kernel_params->binding_count + i]) =
../../drivers/hip/graph_command_buffer.c:                                             : kernel_params->block_dims[0],
../../drivers/hip/graph_command_buffer.c:                                             : kernel_params->block_dims[1],
../../drivers/hip/graph_command_buffer.c:                                             : kernel_params->block_dims[2],
../../drivers/hip/graph_command_buffer.c:      .func = kernel_params->function,
../../drivers/hip/graph_command_buffer.c:  if (command_buffer->graph_node_count >=
../../drivers/hip/graph_command_buffer.c:  size_t dependency_count = command_buffer->hip_barrier_node ? 1 : 0;
../../drivers/hip/graph_command_buffer.c:      z0, command_buffer->symbols,
../../drivers/hip/graph_command_buffer.c:          &command_buffer->hip_graph_nodes[command_buffer->graph_node_count++],
../../drivers/hip/graph_command_buffer.c:          command_buffer->hip_graph, &command_buffer->hip_barrier_node,
../../drivers/hip/graph_command_buffer.c:  return command_buffer->tracing_event_list;
../../drivers/hip/cleanup_thread.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/util/queue_test.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/rccl_dynamic_symbols.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/rccl_dynamic_symbols.h:// Initializes |out_syms| in-place with dynamically loaded NCCL symbols.
../../drivers/hip/util/tree_test.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/util/tree_test.cc:                     void* user_data) -> bool {
../../drivers/hip/util/tree_test.cc:                     void* user_data) -> bool {
../../drivers/hip/util/tree_test.cc:    keys->push_back(iree_hal_hip_util_tree_node_get_key(node));
../../drivers/hip/graph_command_buffer.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/graph_command_buffer.h:// Returns true if |command_buffer| is a HIP graph-based command buffer.
../../drivers/hip/hip_buffer.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/hip_buffer.c:    iree_hal_buffer_initialize(placement, &buffer->base, allocation_size,
../../drivers/hip/hip_buffer.c:                               &iree_hal_hip_buffer_vtable, &buffer->base);
../../drivers/hip/hip_buffer.c:    buffer->host_allocator = host_allocator;
../../drivers/hip/hip_buffer.c:    buffer->type = buffer_type;
../../drivers/hip/hip_buffer.c:    buffer->host_ptr = host_ptr;
../../drivers/hip/hip_buffer.c:    buffer->device_ptr = device_ptr;
../../drivers/hip/hip_buffer.c:    buffer->release_callback = release_callback;
../../drivers/hip/hip_buffer.c:    buffer->empty = false;
../../drivers/hip/hip_buffer.c:    iree_slim_mutex_initialize(&buffer->device_ptr_lock);
../../drivers/hip/hip_buffer.c:    iree_notification_initialize(&buffer->device_ptr_notification);
../../drivers/hip/hip_buffer.c:    *out_buffer = &buffer->base;
../../drivers/hip/hip_buffer.c:  IREE_ASSERT(buffer->device_ptr == NULL,
../../drivers/hip/hip_buffer.c:  iree_slim_mutex_lock(&buffer->device_ptr_lock);
../../drivers/hip/hip_buffer.c:  buffer->device_ptr = pointer;
../../drivers/hip/hip_buffer.c:  iree_slim_mutex_unlock(&buffer->device_ptr_lock);
../../drivers/hip/hip_buffer.c:  iree_notification_post(&buffer->device_ptr_notification, IREE_ALL_WAITERS);
../../drivers/hip/hip_buffer.c:  iree_slim_mutex_lock(&buffer->device_ptr_lock);
../../drivers/hip/hip_buffer.c:  buffer->empty = true;
../../drivers/hip/hip_buffer.c:  buffer->device_ptr = NULL;
../../drivers/hip/hip_buffer.c:  iree_slim_mutex_unlock(&buffer->device_ptr_lock);
../../drivers/hip/hip_buffer.c:  iree_notification_post(&buffer->device_ptr_notification, IREE_ALL_WAITERS);
../../drivers/hip/hip_buffer.c:  iree_allocator_t host_allocator = buffer->host_allocator;
../../drivers/hip/hip_buffer.c:  if (buffer->release_callback.fn) {
../../drivers/hip/hip_buffer.c:    buffer->release_callback.fn(buffer->release_callback.user_data,
../../drivers/hip/hip_buffer.c:  iree_slim_mutex_deinitialize(&buffer->device_ptr_lock);
../../drivers/hip/hip_buffer.c:  iree_notification_deinitialize(&buffer->device_ptr_notification);
../../drivers/hip/hip_buffer.c:  uint8_t* data_ptr = (uint8_t*)(buffer->host_ptr) + local_byte_offset;
../../drivers/hip/hip_buffer.c:  mapping->contents = iree_make_byte_span(data_ptr, local_byte_length);
../../drivers/hip/hip_buffer.c:  return buffer->type;
../../drivers/hip/hip_buffer.c:  iree_slim_mutex_lock(&buffer->device_ptr_lock);
../../drivers/hip/hip_buffer.c:  bool has_ptr_or_error = buffer->device_ptr || buffer->empty;
../../drivers/hip/hip_buffer.c:  iree_slim_mutex_unlock(&buffer->device_ptr_lock);
../../drivers/hip/hip_buffer.c:  iree_notification_await(&buffer->device_ptr_notification,
../../drivers/hip/hip_buffer.c:  return buffer->device_ptr;
../../drivers/hip/hip_buffer.c:  return buffer->host_ptr;
../../drivers/hip/hip_buffer.c:  buffer->release_callback = iree_hal_buffer_release_callback_null();
../../drivers/hip/util/tree.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/util/tree.c:  if (tree->cache) {
../../drivers/hip/util/tree.c:    iree_hal_hip_util_tree_node_t* node = tree->cache;
../../drivers/hip/util/tree.c:    tree->cache = node->right;
../../drivers/hip/util/tree.c:  node->right = tree->cache;
../../drivers/hip/util/tree.c:  tree->cache = node;
../../drivers/hip/util/tree.c:  if (node != &tree->nil) {
../../drivers/hip/util/tree.c:    memset(node, 0, sizeof(*node) + tree->element_size);
../../drivers/hip/util/tree.c:        tree->allocator, sizeof(*node) + tree->element_size, (void**)&node));
../../drivers/hip/util/tree.c:  node->data = (uint8_t*)node + sizeof(*node);
../../drivers/hip/util/tree.c:  if ((uint8_t*)node >= tree->initial_node_cache &&
../../drivers/hip/util/tree.c:          tree->initial_node_cache + tree->initial_node_cache_size) {
../../drivers/hip/util/tree.c:  iree_allocator_free(tree->allocator, node);
../../drivers/hip/util/tree.c:  iree_hal_hip_util_tree_node_t* right_child = node->right;
../../drivers/hip/util/tree.c:  node->right = right_child->left;
../../drivers/hip/util/tree.c:  if (right_child->left != &tree->nil) {
../../drivers/hip/util/tree.c:    right_child->left->parent = node;
../../drivers/hip/util/tree.c:  right_child->parent = node->parent;
../../drivers/hip/util/tree.c:  if (node->parent == NULL) {
../../drivers/hip/util/tree.c:    tree->root = right_child;
../../drivers/hip/util/tree.c:  } else if (node == node->parent->left) {
../../drivers/hip/util/tree.c:    node->parent->left = right_child;
../../drivers/hip/util/tree.c:    node->parent->right = right_child;
../../drivers/hip/util/tree.c:  right_child->left = node;
../../drivers/hip/util/tree.c:  node->parent = right_child;
../../drivers/hip/util/tree.c:  iree_hal_hip_util_tree_node_t* left_child = node->left;
../../drivers/hip/util/tree.c:  node->left = left_child->right;
../../drivers/hip/util/tree.c:  if (left_child->right != &tree->nil) {
../../drivers/hip/util/tree.c:    left_child->right->parent = node;
../../drivers/hip/util/tree.c:  left_child->parent = node->parent;
../../drivers/hip/util/tree.c:  if (node->parent == NULL) {
../../drivers/hip/util/tree.c:    tree->root = left_child;
../../drivers/hip/util/tree.c:  } else if (node == node->parent->right) {
../../drivers/hip/util/tree.c:    node->parent->right = left_child;
../../drivers/hip/util/tree.c:    node->parent->left = left_child;
../../drivers/hip/util/tree.c:  left_child->right = node;
../../drivers/hip/util/tree.c:  node->parent = left_child;
../../drivers/hip/util/tree.c:  node->left = &tree->nil;
../../drivers/hip/util/tree.c:  node->right = &tree->nil;
../../drivers/hip/util/tree.c:  node->key = key;
../../drivers/hip/util/tree.c:  node->red = true;  // red
../../drivers/hip/util/tree.c:  node->parent = NULL;
../../drivers/hip/util/tree.c:  iree_hal_hip_util_tree_node_t* search_position = tree->root;
../../drivers/hip/util/tree.c:  while (search_position != &tree->nil) {
../../drivers/hip/util/tree.c:    if (node->key < search_position->key) {
../../drivers/hip/util/tree.c:      search_position = search_position->left;
../../drivers/hip/util/tree.c:    } else if (node->key > search_position->key) {
../../drivers/hip/util/tree.c:      search_position = search_position->right;
../../drivers/hip/util/tree.c:  node->parent = target_parent;
../../drivers/hip/util/tree.c:    tree->root = node;
../../drivers/hip/util/tree.c:  } else if (node->key < target_parent->key) {
../../drivers/hip/util/tree.c:    target_parent->left = node;
../../drivers/hip/util/tree.c:    target_parent->right = node;
../../drivers/hip/util/tree.c:  if (node->parent == NULL) {
../../drivers/hip/util/tree.c:    node->red = false;
../../drivers/hip/util/tree.c:  if (node->parent == tree->root) {
../../drivers/hip/util/tree.c:  while (node->parent->red) {
../../drivers/hip/util/tree.c:    if (node->parent == node->parent->parent->right) {
../../drivers/hip/util/tree.c:      iree_hal_hip_util_tree_node_t* uncle = node->parent->parent->left;
../../drivers/hip/util/tree.c:      if (uncle->red) {
../../drivers/hip/util/tree.c:        uncle->red = false;
../../drivers/hip/util/tree.c:        node->parent->red = false;
../../drivers/hip/util/tree.c:        node->parent->parent->red = true;
../../drivers/hip/util/tree.c:        node = node->parent->parent;
../../drivers/hip/util/tree.c:        if (node == node->parent->left) {
../../drivers/hip/util/tree.c:          node = node->parent;
../../drivers/hip/util/tree.c:        node->parent->red = false;
../../drivers/hip/util/tree.c:        node->parent->parent->red = true;
../../drivers/hip/util/tree.c:        iree_hal_hip_util_tree_rotate_left(tree, node->parent->parent);
../../drivers/hip/util/tree.c:      iree_hal_hip_util_tree_node_t* uncle = node->parent->parent->right;
../../drivers/hip/util/tree.c:      if (uncle && uncle->red) {
../../drivers/hip/util/tree.c:        uncle->red = false;
../../drivers/hip/util/tree.c:        node->parent->red = false;
../../drivers/hip/util/tree.c:        node->parent->parent->red = true;
../../drivers/hip/util/tree.c:        node = node->parent->parent;
../../drivers/hip/util/tree.c:        if (node == node->parent->right) {
../../drivers/hip/util/tree.c:          node = node->parent;
../../drivers/hip/util/tree.c:        node->parent->red = false;
../../drivers/hip/util/tree.c:        node->parent->parent->red = true;
../../drivers/hip/util/tree.c:        iree_hal_hip_util_tree_rotate_right(tree, node->parent->parent);
../../drivers/hip/util/tree.c:    if (node == tree->root) {
../../drivers/hip/util/tree.c:  tree->root->red = false;
../../drivers/hip/util/tree.c:  if (!node || node->is_sentinel) {
../../drivers/hip/util/tree.c:      if (!iree_hal_hip_util_tree_walk_helper(node->left, walk_type, callback,
../../drivers/hip/util/tree.c:      return iree_hal_hip_util_tree_walk_helper(node->right, walk_type,
../../drivers/hip/util/tree.c:      if (!iree_hal_hip_util_tree_walk_helper(node->left, walk_type, callback,
../../drivers/hip/util/tree.c:      return iree_hal_hip_util_tree_walk_helper(node->right, walk_type,
../../drivers/hip/util/tree.c:      if (!iree_hal_hip_util_tree_walk_helper(node->left, walk_type, callback,
../../drivers/hip/util/tree.c:      if (!iree_hal_hip_util_tree_walk_helper(node->right, walk_type, callback,
../../drivers/hip/util/tree.c:  if (!dst->parent) {
../../drivers/hip/util/tree.c:    tree->root = src;
../../drivers/hip/util/tree.c:  } else if (dst == dst->parent->left) {
../../drivers/hip/util/tree.c:    dst->parent->left = src;
../../drivers/hip/util/tree.c:    dst->parent->right = src;
../../drivers/hip/util/tree.c:  src->parent = dst->parent;
../../drivers/hip/util/tree.c:  bool initial_red = next->red;
../../drivers/hip/util/tree.c:  if (to_remove->left == &tree->nil) {
../../drivers/hip/util/tree.c:    replacement = to_remove->right;
../../drivers/hip/util/tree.c:    iree_hal_hip_util_tree_replace(tree, to_remove, to_remove->right);
../../drivers/hip/util/tree.c:  } else if (to_remove->right == &tree->nil) {
../../drivers/hip/util/tree.c:    replacement = to_remove->left;
../../drivers/hip/util/tree.c:    iree_hal_hip_util_tree_replace(tree, to_remove, to_remove->left);
../../drivers/hip/util/tree.c:    initial_red = next->red;
../../drivers/hip/util/tree.c:    replacement = next->right;
../../drivers/hip/util/tree.c:    if (next->parent == to_remove) {
../../drivers/hip/util/tree.c:      replacement->parent = next;
../../drivers/hip/util/tree.c:      iree_hal_hip_util_tree_replace(tree, next, next->right);
../../drivers/hip/util/tree.c:      next->right = to_remove->right;
../../drivers/hip/util/tree.c:      next->right->parent = next;
../../drivers/hip/util/tree.c:    next->left = to_remove->left;
../../drivers/hip/util/tree.c:    next->left->parent = next;
../../drivers/hip/util/tree.c:    next->red = to_remove->red;
../../drivers/hip/util/tree.c:  while (replacement != tree->root && !replacement->red) {
../../drivers/hip/util/tree.c:    if (replacement == replacement->parent->left) {
../../drivers/hip/util/tree.c:      iree_hal_hip_util_tree_node_t* sibling = replacement->parent->right;
../../drivers/hip/util/tree.c:      if (sibling->red) {
../../drivers/hip/util/tree.c:        sibling->red = false;
../../drivers/hip/util/tree.c:        replacement->parent->red = true;
../../drivers/hip/util/tree.c:        iree_hal_hip_util_tree_rotate_left(tree, replacement->parent);
../../drivers/hip/util/tree.c:        sibling = replacement->parent->right;
../../drivers/hip/util/tree.c:      if (!sibling->left->red && !sibling->right->red) {
../../drivers/hip/util/tree.c:        sibling->red = true;
../../drivers/hip/util/tree.c:        replacement = replacement->parent;
../../drivers/hip/util/tree.c:        if (!sibling->right->red) {
../../drivers/hip/util/tree.c:          sibling->left->red = false;
../../drivers/hip/util/tree.c:          sibling->red = true;
../../drivers/hip/util/tree.c:          sibling = replacement->parent->right;
../../drivers/hip/util/tree.c:        sibling->red = replacement->parent->red;
../../drivers/hip/util/tree.c:        replacement->parent->red = false;
../../drivers/hip/util/tree.c:        sibling->right->red = false;
../../drivers/hip/util/tree.c:        iree_hal_hip_util_tree_rotate_left(tree, replacement->parent);
../../drivers/hip/util/tree.c:        replacement = tree->root;
../../drivers/hip/util/tree.c:      iree_hal_hip_util_tree_node_t* sibling = replacement->parent->left;
../../drivers/hip/util/tree.c:      if (sibling->red) {
../../drivers/hip/util/tree.c:        sibling->red = false;
../../drivers/hip/util/tree.c:        replacement->parent->red = true;
../../drivers/hip/util/tree.c:        iree_hal_hip_util_tree_rotate_right(tree, replacement->parent);
../../drivers/hip/util/tree.c:        sibling = replacement->parent->left;
../../drivers/hip/util/tree.c:      if (!sibling->left->red && !sibling->right->red) {
../../drivers/hip/util/tree.c:        sibling->red = true;
../../drivers/hip/util/tree.c:        replacement = replacement->parent;
../../drivers/hip/util/tree.c:        if (!sibling->left->red) {
../../drivers/hip/util/tree.c:          sibling->right->red = false;
../../drivers/hip/util/tree.c:          sibling->red = true;
../../drivers/hip/util/tree.c:          sibling = replacement->parent->left;
../../drivers/hip/util/tree.c:        sibling->red = replacement->parent->red;
../../drivers/hip/util/tree.c:        replacement->parent->red = false;
../../drivers/hip/util/tree.c:        sibling->left->red = false;
../../drivers/hip/util/tree.c:        iree_hal_hip_util_tree_rotate_right(tree, replacement->parent);
../../drivers/hip/util/tree.c:        replacement = tree->root;
../../drivers/hip/util/tree.c:  replacement->red = false;
../../drivers/hip/util/tree.c://===----------------------------------------------------------------------===//
../../drivers/hip/util/tree.c://===----------------------------------------------------------------------===//
../../drivers/hip/util/tree.c:  return node->data;
../../drivers/hip/util/tree.c:  return node->key;
../../drivers/hip/util/tree.c:  if (!node->right->is_sentinel) {
../../drivers/hip/util/tree.c:    node = node->right;
../../drivers/hip/util/tree.c:    while (!node->left->is_sentinel) {
../../drivers/hip/util/tree.c:      node = node->left;
../../drivers/hip/util/tree.c:  iree_hal_hip_util_tree_node_t* parent = node->parent;
../../drivers/hip/util/tree.c:  while (parent && node == parent->right) {
../../drivers/hip/util/tree.c:    parent = node->parent;
../../drivers/hip/util/tree.c:  if (!node->left->is_sentinel) {
../../drivers/hip/util/tree.c:    node = node->left;
../../drivers/hip/util/tree.c:    while (!node->right->is_sentinel) {
../../drivers/hip/util/tree.c:      node = node->right;
../../drivers/hip/util/tree.c:  iree_hal_hip_util_tree_node_t* parent = node->parent;
../../drivers/hip/util/tree.c:  while (parent && node == parent->left) {
../../drivers/hip/util/tree.c:    parent = node->parent;
../../drivers/hip/util/tree.c://===----------------------------------------------------------------------===//
../../drivers/hip/util/tree.c://===----------------------------------------------------------------------===//
../../drivers/hip/util/tree.c:  out_tree->element_size = element_size;
../../drivers/hip/util/tree.c:  out_tree->allocator = allocator;
../../drivers/hip/util/tree.c:  out_tree->root = &out_tree->nil;
../../drivers/hip/util/tree.c:  out_tree->size = 0;
../../drivers/hip/util/tree.c:  out_tree->cache = NULL;  // Initialize cache
../../drivers/hip/util/tree.c:  memset(&out_tree->nil, 0x00, sizeof(out_tree->nil));
../../drivers/hip/util/tree.c:  out_tree->nil.is_sentinel = true;
../../drivers/hip/util/tree.c:  out_tree->initial_node_cache = initial_node_cache;
../../drivers/hip/util/tree.c:  out_tree->initial_node_cache_size = initial_node_cache_size;
../../drivers/hip/util/tree.c:        iree_host_align(sizeof(out_tree->nil) + element_size, 16);
../../drivers/hip/util/tree.c:      node->data = (uint8_t*)node + sizeof(*node);
../../drivers/hip/util/tree.c:  iree_hal_hip_util_tree_node_t* node = tree->cache;
../../drivers/hip/util/tree.c:    iree_hal_hip_util_tree_node_t* next = node->right;
../../drivers/hip/util/tree.c:    if ((uint8_t*)node < tree->initial_node_cache ||
../../drivers/hip/util/tree.c:            tree->initial_node_cache + tree->initial_node_cache_size) {
../../drivers/hip/util/tree.c:      iree_allocator_free(tree->allocator, node);
../../drivers/hip/util/tree.c:  tree->root = &tree->nil;
../../drivers/hip/util/tree.c:  memset(&tree->nil, 0, sizeof(tree->nil));
../../drivers/hip/util/tree.c:  tree->nil.is_sentinel = true;
../../drivers/hip/util/tree.c:  tree->size = 0;
../../drivers/hip/util/tree.c:  tree->cache = NULL;
../../drivers/hip/util/tree.c:  return tree->element_size;
../../drivers/hip/util/tree.c:  ++tree->size;
../../drivers/hip/util/tree.c:  return tree->size;
../../drivers/hip/util/tree.c:  if ((!next || next->key > new_key) && (!prev || prev->key < new_key)) {
../../drivers/hip/util/tree.c:    node->key = new_key;
../../drivers/hip/util/tree.c:  iree_hal_hip_util_tree_node_t* node = tree->root;
../../drivers/hip/util/tree.c:  while (node->is_sentinel == false) {
../../drivers/hip/util/tree.c:    if (key == node->key) {
../../drivers/hip/util/tree.c:    } else if (key < node->key) {
../../drivers/hip/util/tree.c:      node = node->left;
../../drivers/hip/util/tree.c:      node = node->right;
../../drivers/hip/util/tree.c:  iree_hal_hip_util_tree_node_t* node = tree->root;
../../drivers/hip/util/tree.c:  while (node->is_sentinel == false) {
../../drivers/hip/util/tree.c:    if (key == node->key) {
../../drivers/hip/util/tree.c:    } else if (key < node->key) {
../../drivers/hip/util/tree.c:      node = node->left;
../../drivers/hip/util/tree.c:      node = node->right;
../../drivers/hip/util/tree.c:  if (!last || last->key > key) {
../../drivers/hip/util/tree.c:  iree_hal_hip_util_tree_node_t* node = tree->root;
../../drivers/hip/util/tree.c:  while (node->is_sentinel == false) {
../../drivers/hip/util/tree.c:    if (key == node->key) {
../../drivers/hip/util/tree.c:    } else if (key < node->key) {
../../drivers/hip/util/tree.c:      node = node->left;
../../drivers/hip/util/tree.c:      node = node->right;
../../drivers/hip/util/tree.c:  if (!last || last->key > key) {
../../drivers/hip/util/tree.c:  while (last && last->key <= key) {
../../drivers/hip/util/tree.c:  if (!tree->root || tree->root->is_sentinel) {
../../drivers/hip/util/tree.c:  iree_hal_hip_util_tree_node_t* val = tree->root;
../../drivers/hip/util/tree.c:  while (!val->left->is_sentinel) {
../../drivers/hip/util/tree.c:    val = val->left;
../../drivers/hip/util/tree.c:  if (!tree->root || tree->root->is_sentinel) {
../../drivers/hip/util/tree.c:  iree_hal_hip_util_tree_node_t* val = tree->root;
../../drivers/hip/util/tree.c:  while (!val->right->is_sentinel) {
../../drivers/hip/util/tree.c:    val = val->right;
../../drivers/hip/util/tree.c:  --tree->size;
../../drivers/hip/util/tree.c:  iree_hal_hip_util_tree_walk_helper(tree->root, walk_type, callback,
../../drivers/hip/registration/CMakeLists.txt:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/hip_driver.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/hip_driver.c:#define IREE_DEVICE_ID_TO_HIPDEVICE(device_id) (hipDevice_t)((device_id) - 1)
../../drivers/hip/hip_driver.c:  // NCCL API dynamic symbols to use collectives (multi-gpu/multi-node).
../../drivers/hip/hip_driver.c:  out_options->default_device_index = 0;
../../drivers/hip/hip_driver.c:      IREE_HIP_CALL_TO_STATUS(&driver->hip_symbols, hipInit(0), "hipInit");
../../drivers/hip/hip_driver.c:  iree_hal_resource_initialize(&iree_hal_hip_driver_vtable, &driver->resource);
../../drivers/hip/hip_driver.c:  driver->host_allocator = host_allocator;
../../drivers/hip/hip_driver.c:      identifier, &driver->identifier,
../../drivers/hip/hip_driver.c:  driver->default_device_index = options->default_device_index;
../../drivers/hip/hip_driver.c:      host_allocator, options->hip_lib_search_path_count,
../../drivers/hip/hip_driver.c:      options->hip_lib_search_paths, &driver->hip_symbols);
../../drivers/hip/hip_driver.c:        host_allocator, &driver->hip_symbols, &driver->nccl_symbols);
../../drivers/hip/hip_driver.c:  memcpy(&driver->device_params, device_params, sizeof(driver->device_params));
../../drivers/hip/hip_driver.c:  iree_allocator_t host_allocator = driver->host_allocator;
../../drivers/hip/hip_driver.c:  iree_hal_hip_nccl_dynamic_symbols_deinitialize(&driver->nccl_symbols);
../../drivers/hip/hip_driver.c:  iree_hal_hip_dynamic_symbols_deinitialize(&driver->hip_symbols);
../../drivers/hip/hip_driver.c:  out_device_info->device_id = IREE_HIPDEVICE_TO_DEVICE_ID(device);
../../drivers/hip/hip_driver.c:           "GPU-"
../../drivers/hip/hip_driver.c:           "%02x%02x%02x%02x-"
../../drivers/hip/hip_driver.c:           "%02x%02x-"
../../drivers/hip/hip_driver.c:           "%02x%02x-"
../../drivers/hip/hip_driver.c:           "%02x%02x-"
../../drivers/hip/hip_driver.c:                            IREE_ARRAYSIZE(device_path_str) - 1),
../../drivers/hip/hip_driver.c:      &out_device_info->path, (char*)buffer_ptr);
../../drivers/hip/hip_driver.c:      device_name_str, &out_device_info->name, (char*)buffer_ptr);
../../drivers/hip/hip_driver.c:  IREE_HIP_RETURN_AND_END_ZONE_IF_ERROR(z0, &driver->hip_symbols,
../../drivers/hip/hip_driver.c:          &driver->hip_symbols, hipDeviceGet(&device, i), "hipDeviceGet");
../../drivers/hip/hip_driver.c:          device, &driver->hip_symbols, buffer_ptr, &buffer_ptr,
../../drivers/hip/hip_driver.c:  iree_string_builder_initialize(builder->allocator, &path_builder);
../../drivers/hip/hip_driver.c:      &driver->hip_symbols, &path_builder);
../../drivers/hip/hip_driver.c:        builder, "\n- amdhip64_dylib_path: %s", path_builder.buffer);
../../drivers/hip/hip_driver.c:  IREE_HIP_RETURN_IF_ERROR(&driver->hip_symbols,
../../drivers/hip/hip_driver.c:      builder, "\n- gpu-compute-capability: %d.%d", prop.major, prop.minor));
../../drivers/hip/hip_driver.c:      builder, "\n- gpu-arch-name: %s", prop.gcnArchName));
../../drivers/hip/hip_driver.c:      builder, "\n- launch-max-block-dims: (%d, %d, %d)", prop.maxThreadsDim[0],
../../drivers/hip/hip_driver.c:      builder, "\n- block-max-thread-count: %d", prop.maxThreadsPerBlock));
../../drivers/hip/hip_driver.c:      builder, "\n- block-max-32-bit-register-count: %d", prop.regsPerBlock));
../../drivers/hip/hip_driver.c:      builder, "\n- block-max-shared-memory: %d KB", shared_memory_kb));
../../drivers/hip/hip_driver.c:      builder, "\n- memory-is-integrated-memory: %d", prop.integrated));
../../drivers/hip/hip_driver.c:      builder, "\n- memory-supports-managed-memory: %d", prop.managedMemory));
../../drivers/hip/hip_driver.c:      builder, "\n- memory-total-const-memory-size: %d MB", const_memory_mb));
../../drivers/hip/hip_driver.c:      builder, "\n- memory-total-global-memory-size: %d MB", global_memory_mb));
../../drivers/hip/hip_driver.c:      builder, "\n- memory-l2-cache-size: %d bytes", prop.l2CacheSize));
../../drivers/hip/hip_driver.c:      builder, "\n- gpu-compute-unit-count: %d", prop.multiProcessorCount));
../../drivers/hip/hip_driver.c:      builder, "\n- gpu-compute-max-clock-rate: %d mHz", compute_clock_mhz));
../../drivers/hip/hip_driver.c:      builder, "\n- gpu-memory-max-clock-rate: %d mHz", memory_clock_mhz));
../../drivers/hip/hip_driver.c:      builder, "\n- gpu-warp-size: %d", prop.warpSize));
../../drivers/hip/hip_driver.c:                base_driver, &driver->hip_symbols, driver->default_device_index,
../../drivers/hip/hip_driver.c:  iree_hal_hip_device_params_t device_params = driver->device_params;
../../drivers/hip/hip_driver.c:      base_driver, device_name, &device_params, &driver->hip_symbols,
../../drivers/hip/hip_driver.c:      &driver->nccl_symbols, 1, &device, host_allocator, out_device);
../../drivers/hip/hip_driver.c:  if (!iree_string_view_consume_prefix(&device_path, IREE_SV("GPU-"))) {
../../drivers/hip/hip_driver.c:  IREE_HIP_RETURN_IF_ERROR(&driver->hip_symbols,
../../drivers/hip/hip_driver.c:    IREE_HIP_RETURN_IF_ERROR(&driver->hip_symbols, hipDeviceGet(&device, i),
../../drivers/hip/hip_driver.c:    IREE_HIP_RETURN_IF_ERROR(&driver->hip_symbols,
../../drivers/hip/hip_driver.c:        "HIP device with UUID GPU-"
../../drivers/hip/hip_driver.c:        "%02x%02x%02x%02x-"
../../drivers/hip/hip_driver.c:        "%02x%02x-"
../../drivers/hip/hip_driver.c:        "%02x%02x-"
../../drivers/hip/hip_driver.c:        "%02x%02x-"
../../drivers/hip/hip_driver.c:  IREE_HIP_RETURN_IF_ERROR(&driver->hip_symbols,
../../drivers/hip/hip_driver.c:  IREE_HIP_RETURN_IF_ERROR(&driver->hip_symbols,
../../drivers/hip/hip_driver.c:  return iree_string_view_starts_with(device_path, IREE_SV("GPU-"));
../../drivers/hip/hip_driver.c:      base_driver, device_name, &driver->device_params, &driver->hip_symbols,
../../drivers/hip/hip_driver.c:      &driver->nccl_symbols, device_count, devices, host_allocator, out_device);
../../drivers/hip/hip_driver.c:        iree_string_view_substr(device_path, offset, comma_pos - offset);
../../drivers/hip/registration/driver_module.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/registration/driver_module.c:    "Enables HIP asynchronous stream-ordered allocations when supported.");
../../drivers/hip/registration/driver_module.c:          "Enables caching for stream-ordered allocations")
../../drivers/hip/registration/driver_module.c:    "   2 : fine-grained kernel level tracing enabled.\n");
../../drivers/hip/registration/driver_module.c:  // TODO: make this a single key-value pair (semicolon separated).
../../drivers/hip/registration/driver_module.c:  // If there were no flag-based dylib paths, consult the environment
../../drivers/hip/registration/driver_module.c:  // TODO: make this a single key-value pair (semicolon separated).
../../drivers/hip/registration/driver_module.c:      } while (split_index != -1);
../../drivers/hip/registration/driver_module.c:      device_params->command_buffer_mode =
../../drivers/hip/registration/driver_module.c:          key, value, &device_params->allow_inline_execution));
../../drivers/hip/registration/driver_module.c:          key, value, &device_params->async_allocations));
../../drivers/hip/registration/driver_module.c:          key, value, &device_params->async_caching));
../../drivers/hip/registration/driver_module.c:          key, value, &device_params->stream_tracing));
../../drivers/hip/registration/driver_module.c:          key, value, &driver_options->default_device_index));
../../drivers/hip/registration/driver_module.c:  // TODO: make this a single key-value pair (semicolon separated).
../../drivers/hip/registration/driver_module.c:        dylib_path_count * sizeof(driver_options->hip_lib_search_paths[0]),
../../drivers/hip/registration/driver_module.c:        (void**)&driver_options->hip_lib_search_paths));
../../drivers/hip/registration/driver_module.c:        driver_options->hip_lib_search_paths
../../drivers/hip/registration/driver_module.c:            [driver_options->hip_lib_search_path_count++] = value;
../../drivers/hip/CMakeLists.txt:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/CMakeLists.txt:  set(HIP_API_HEADERS_ROOT "${IREE_SOURCE_DIR}/third_party/hip-build-deps/include")
../../drivers/hip/util/queue.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/util/queue.c:  out_queue->allocator = allocator;
../../drivers/hip/util/queue.c:  out_queue->elements = &out_queue->initial_allocation[0];
../../drivers/hip/util/queue.c:  out_queue->element_size = element_size;
../../drivers/hip/util/queue.c:  out_queue->element_count = 0;
../../drivers/hip/util/queue.c:  out_queue->capacity = inline_count;
../../drivers/hip/util/queue.c:  out_queue->head = 0;
../../drivers/hip/util/queue.c:  if (queue->elements != &queue->initial_allocation[0]) {
../../drivers/hip/util/queue.c:    iree_allocator_free(queue->allocator, queue->elements);
../../drivers/hip/util/queue.c:  if (queue->capacity == queue->element_count) {
../../drivers/hip/util/queue.c:    queue->capacity = iree_max(16, queue->capacity * 2);
../../drivers/hip/util/queue.c:    if (queue->elements == &queue->initial_allocation[0]) {
../../drivers/hip/util/queue.c:          queue->allocator, queue->element_size * queue->capacity,
../../drivers/hip/util/queue.c:      memcpy(new_mem, queue->elements + (queue->head * queue->element_size),
../../drivers/hip/util/queue.c:             (queue->element_count - queue->head) * queue->element_size);
../../drivers/hip/util/queue.c:                 ((queue->element_count - queue->head) * queue->element_size),
../../drivers/hip/util/queue.c:             queue->elements, queue->head * queue->element_size);
../../drivers/hip/util/queue.c:      queue->head = 0;
../../drivers/hip/util/queue.c:      new_mem = queue->elements;
../../drivers/hip/util/queue.c:          queue->allocator, queue->element_size * queue->capacity,
../../drivers/hip/util/queue.c:          queue->element_count - queue->head;
../../drivers/hip/util/queue.c:          queue->element_count - num_head_elements;
../../drivers/hip/util/queue.c:            new_mem + (queue->head + num_head_elements) * queue->element_size,
../../drivers/hip/util/queue.c:            new_mem, num_wrapped_elements * queue->element_size);
../../drivers/hip/util/queue.c:    queue->elements = new_mem;
../../drivers/hip/util/queue.c:  memcpy(queue->elements +
../../drivers/hip/util/queue.c:             (((queue->head + queue->element_count) % queue->capacity) *
../../drivers/hip/util/queue.c:              queue->element_size),
../../drivers/hip/util/queue.c:         element, queue->element_size);
../../drivers/hip/util/queue.c:  ++queue->element_count;
../../drivers/hip/util/queue.c:  IREE_ASSERT_LE(count, queue->element_count, "Popping too many elements");
../../drivers/hip/util/queue.c:  queue->head += count;
../../drivers/hip/util/queue.c:  queue->head = queue->head % queue->capacity;
../../drivers/hip/util/queue.c:  queue->element_count -= count;
../../drivers/hip/util/queue.c:  IREE_ASSERT_LT(i, queue->element_count, "Index out of range");
../../drivers/hip/util/queue.c:  return queue->elements +
../../drivers/hip/util/queue.c:         ((queue->head + i) % queue->capacity) * queue->element_size;
../../drivers/hip/registration/driver_module.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/memory_pools.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/memory_pools.h:  // Used for any host-visible/host-local memory types.
../../drivers/hip/memory_pools.h:// The deallocation will be stream-ordered on |stream|.
../../drivers/hip/nop_executable_cache.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/nop_executable_cache.h:// Creates a no-op executable cache that does not cache at all.
../../drivers/hip/rccl_channel.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/rccl_channel.h:  for (iree_host_size_t i = 0; i < IREE_ARRAYSIZE(id->data); ++i) {
../../drivers/hip/rccl_channel.h:    if (id->data[i] != 0) return false;
../../drivers/hip/rccl_channel.h:// Performs a non-blocking submission of |batch| to |stream|.
../../drivers/hip/dynamic_symbols.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/dynamic_symbols.h://===----------------------------------------------------------------------===//
../../drivers/hip/dynamic_symbols.h://===----------------------------------------------------------------------===//
../../drivers/hip/dynamic_symbols.h:// Initializes |out_syms| in-place with dynamically loaded HIP symbols.
../../drivers/hip/api.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/api.h://===----------------------------------------------------------------------===//
../../drivers/hip/api.h://===----------------------------------------------------------------------===//
../../drivers/hip/api.h:// Parameters for each hipMemPool_t used for queue-ordered allocations.
../../drivers/hip/api.h:  // Used for any host-visible/host-local memory types.
../../drivers/hip/api.h:  // hardware-specific performance counters.
../../drivers/hip/api.h:  // NOTE: tracing has a non-trivial overhead and will skew the timing of
../../drivers/hip/api.h:  // from there; be wary of whole-program tracing with this enabled.
../../drivers/hip/api.h:  // Parameters for each hipMemPool_t used for queue-ordered allocations.
../../drivers/hip/api.h://===----------------------------------------------------------------------===//
../../drivers/hip/api.h://===----------------------------------------------------------------------===//
../../drivers/hip/native_executable.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/native_executable.c:      hipDeviceGetAttribute(&out_limits->max_block_dims[0],
../../drivers/hip/native_executable.c:      hipDeviceGetAttribute(&out_limits->max_block_dims[1],
../../drivers/hip/native_executable.c:      hipDeviceGetAttribute(&out_limits->max_block_dims[2],
../../drivers/hip/native_executable.c:      hipDeviceGetAttribute(&out_limits->max_block_shared_memory_size,
../../drivers/hip/native_executable.c:  // Run flatcc generated verification. This ensures all pointers are in-bounds
../../drivers/hip/native_executable.c:      if (block_dims->x > limits->max_block_dims[0] ||
../../drivers/hip/native_executable.c:          block_dims->y > limits->max_block_dims[1] ||
../../drivers/hip/native_executable.c:          block_dims->z > limits->max_block_dims[2]) {
../../drivers/hip/native_executable.c:            i, block_dims->x, block_dims->y, block_dims->z,
../../drivers/hip/native_executable.c:            limits->max_block_dims[0], limits->max_block_dims[1],
../../drivers/hip/native_executable.c:            limits->max_block_dims[2]);
../../drivers/hip/native_executable.c:  if (block_shared_memory_size > limits->max_block_shared_memory_size) {
../../drivers/hip/native_executable.c:                            limits->max_block_shared_memory_size);
../../drivers/hip/native_executable.c:              executable_params->executable_data, &limits));
../../drivers/hip/native_executable.c:          executable_params->executable_data.data);
../../drivers/hip/native_executable.c:      sizeof(*executable->per_device_data[0]) +
../../drivers/hip/native_executable.c:      module_count * sizeof(executable->per_device_data[0]->modules[0]) +
../../drivers/hip/native_executable.c:      export_count * sizeof(executable->per_device_data[0]->exports[0]) +
../../drivers/hip/native_executable.c:      topology.count * sizeof(executable->per_device_data[0]) +
../../drivers/hip/native_executable.c:                               &executable->resource);
../../drivers/hip/native_executable.c:  executable->host_allocator = host_allocator;
../../drivers/hip/native_executable.c:  executable->symbols = symbols;
../../drivers/hip/native_executable.c:  executable->num_devices = topology.count;
../../drivers/hip/native_executable.c:      topology.count * sizeof(executable->per_device_data[0]);
../../drivers/hip/native_executable.c:    executable->per_device_data[i] =
../../drivers/hip/native_executable.c:        executable->per_device_data[j];
../../drivers/hip/native_executable.c:    per_device_data->module_count = module_count;
../../drivers/hip/native_executable.c:    per_device_data->modules =
../../drivers/hip/native_executable.c:                       (export_count * sizeof(per_device_data->exports[0])));
../../drivers/hip/native_executable.c:    per_device_data->export_count = export_count;
../../drivers/hip/native_executable.c:                   ((uint8_t*)per_device_data->modules +
../../drivers/hip/native_executable.c:                    module_count * sizeof(per_device_data->modules[0])));
../../drivers/hip/native_executable.c:      per_device_data->modules[i] = module;
../../drivers/hip/native_executable.c:        hipModule_t module = per_device_data->modules[module_ordinal];
../../drivers/hip/native_executable.c:            &per_device_data->exports[i];
../../drivers/hip/native_executable.c:        kernel_info->function = function;
../../drivers/hip/native_executable.c:        kernel_info->block_dims[0] = block_dims->x;
../../drivers/hip/native_executable.c:        kernel_info->block_dims[1] = block_dims->y;
../../drivers/hip/native_executable.c:        kernel_info->block_dims[2] = block_dims->z;
../../drivers/hip/native_executable.c:        kernel_info->constant_count =
../../drivers/hip/native_executable.c:        kernel_info->binding_count =
../../drivers/hip/native_executable.c:                                    "] for kernel `%s` specified non-zero "
../../drivers/hip/native_executable.c:          kernel_info->debug_info.function_name = export_info->function_name;
../../drivers/hip/native_executable.c:          kernel_info->debug_info.source_filename =
../../drivers/hip/native_executable.c:              export_info->source_filename;
../../drivers/hip/native_executable.c:          kernel_info->debug_info.source_line = export_info->source_line;
../../drivers/hip/native_executable.c:  iree_allocator_t host_allocator = executable->host_allocator;
../../drivers/hip/native_executable.c:  for (iree_host_size_t i = 0; i < executable->num_devices; ++i) {
../../drivers/hip/native_executable.c:        executable->per_device_data[i];
../../drivers/hip/native_executable.c:    for (iree_host_size_t j = 0; j < data->module_count; ++j) {
../../drivers/hip/native_executable.c:      if (data->modules[j]) {
../../drivers/hip/native_executable.c:        IREE_HIP_IGNORE_ERROR(executable->symbols,
../../drivers/hip/native_executable.c:                              hipModuleUnload(data->modules[j]));
../../drivers/hip/native_executable.c:  if (device_ordinal > executable->num_devices) {
../../drivers/hip/native_executable.c:                            "affinity for non-existent queue was provided.");
../../drivers/hip/native_executable.c:      executable->per_device_data[device_ordinal];
../../drivers/hip/native_executable.c:  if (ordinal >= data->export_count) {
../../drivers/hip/native_executable.c:        ordinal, data->export_count);
../../drivers/hip/native_executable.c:  *out_params = &data->exports[ordinal];
../../drivers/hip/dynamic_symbols_test.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/context_util.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/rccl_channel.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/rccl_channel.c:  // guaranteed to be unique - only use for informational purposes.
../../drivers/hip/rccl_channel.c:    hash += id->data[i];
../../drivers/hip/rccl_channel.c:                               &channel->resource);
../../drivers/hip/rccl_channel.c:  channel->hip_symbols = hip_symbols;
../../drivers/hip/rccl_channel.c:  channel->nccl_symbols = nccl_symbols;
../../drivers/hip/rccl_channel.c:  channel->host_allocator = host_allocator;
../../drivers/hip/rccl_channel.c:  channel->parent_channel = NULL;
../../drivers/hip/rccl_channel.c:  channel->rank = rank;
../../drivers/hip/rccl_channel.c:  channel->count = count;
../../drivers/hip/rccl_channel.c:  channel->comm = comm;
../../drivers/hip/rccl_channel.c:  IREE_TRACE(channel->id_hash = id_hash);
../../drivers/hip/rccl_channel.c:  IREE_TRACE_ZONE_APPEND_VALUE_I64(z0, channel->id_hash);
../../drivers/hip/rccl_channel.c:  IREE_TRACE_ZONE_APPEND_VALUE_I64(z0, channel->rank);
../../drivers/hip/rccl_channel.c:  IREE_TRACE_ZONE_APPEND_VALUE_I64(z0, channel->count);
../../drivers/hip/rccl_channel.c:  iree_allocator_t host_allocator = channel->host_allocator;
../../drivers/hip/rccl_channel.c:  //   ncclCommFinalize(channel->comm);  // non-blocking!
../../drivers/hip/rccl_channel.c:  //   ncclCommDestroy(channel->comm)
../../drivers/hip/rccl_channel.c:  //   ncclCommDestroy(channel->comm)
../../drivers/hip/rccl_channel.c:  IREE_NCCL_IGNORE_ERROR(channel->nccl_symbols,
../../drivers/hip/rccl_channel.c:                         ncclCommFinalize(channel->comm));
../../drivers/hip/rccl_channel.c:  IREE_NCCL_IGNORE_ERROR(channel->nccl_symbols, ncclCommDestroy(channel->comm));
../../drivers/hip/rccl_channel.c:  iree_hal_channel_release(channel->parent_channel);
../../drivers/hip/rccl_channel.c:  // TODO: see if we need to set the sharing config - we may always want to.
../../drivers/hip/rccl_channel.c:      channel->nccl_symbols,
../../drivers/hip/rccl_channel.c:      ncclCommSplit(channel->comm, color, key, &split_comm, &config),
../../drivers/hip/rccl_channel.c:      channel->nccl_symbols, ncclCommUserRank(split_comm, &split_rank),
../../drivers/hip/rccl_channel.c:    status = IREE_NCCL_RESULT_TO_STATUS(channel->nccl_symbols,
../../drivers/hip/rccl_channel.c:        iree_allocator_malloc(channel->host_allocator, sizeof(*split_channel),
../../drivers/hip/rccl_channel.c:                                 &split_channel->resource);
../../drivers/hip/rccl_channel.c:    split_channel->hip_symbols = channel->hip_symbols;
../../drivers/hip/rccl_channel.c:    split_channel->nccl_symbols = channel->nccl_symbols;
../../drivers/hip/rccl_channel.c:    split_channel->host_allocator = channel->host_allocator;
../../drivers/hip/rccl_channel.c:    split_channel->parent_channel = base_channel;
../../drivers/hip/rccl_channel.c:    split_channel->rank = split_rank;
../../drivers/hip/rccl_channel.c:    split_channel->count = split_count;
../../drivers/hip/rccl_channel.c:    split_channel->comm = split_comm;
../../drivers/hip/rccl_channel.c:    IREE_NCCL_IGNORE_ERROR(channel->nccl_symbols, ncclCommDestroy(split_comm));
../../drivers/hip/rccl_channel.c:  // NOTE: since it's cheap we keep rank/count local - this lets us trace them
../../drivers/hip/rccl_channel.c:  *out_rank = channel->rank;
../../drivers/hip/rccl_channel.c:  *out_count = channel->count;
../../drivers/hip/rccl_channel.c:  return channel->comm;
../../drivers/hip/rccl_channel.c:      iree_hal_hip_nccl_channel_cast(entry->channel);
../../drivers/hip/rccl_channel.c:  const iree_hal_hip_nccl_dynamic_symbols_t* symbols = channel->nccl_symbols;
../../drivers/hip/rccl_channel.c:  ncclComm_t comm = iree_hal_hip_nccl_channel_comm(entry->channel);
../../drivers/hip/rccl_channel.c:      iree_hal_hip_get_nccl_data_type(entry->op.element_type, &datatype));
../../drivers/hip/rccl_channel.c:  switch (entry->op.kind) {
../../drivers/hip/rccl_channel.c:              iree_hal_buffer_allocated_buffer(entry->send_binding.buffer)) +
../../drivers/hip/rccl_channel.c:          iree_hal_buffer_byte_offset(entry->send_binding.buffer) +
../../drivers/hip/rccl_channel.c:          entry->send_binding.offset;
../../drivers/hip/rccl_channel.c:                      entry->recv_binding.buffer))) +
../../drivers/hip/rccl_channel.c:          iree_hal_buffer_byte_offset(entry->recv_binding.buffer) +
../../drivers/hip/rccl_channel.c:          entry->recv_binding.offset;
../../drivers/hip/rccl_channel.c:                        entry->element_count, datatype, comm, stream),
../../drivers/hip/rccl_channel.c:                      entry->send_binding.buffer))) +
../../drivers/hip/rccl_channel.c:          iree_hal_buffer_byte_offset(entry->send_binding.buffer) +
../../drivers/hip/rccl_channel.c:          entry->send_binding.offset;
../../drivers/hip/rccl_channel.c:                      entry->recv_binding.buffer))) +
../../drivers/hip/rccl_channel.c:          iree_hal_buffer_byte_offset(entry->recv_binding.buffer) +
../../drivers/hip/rccl_channel.c:          entry->recv_binding.offset;
../../drivers/hip/rccl_channel.c:          iree_hal_hip_get_nccl_reduction_type(entry->op.reduction, &redop));
../../drivers/hip/rccl_channel.c:                        entry->element_count, datatype, redop, comm, stream),
../../drivers/hip/rccl_channel.c:                      entry->send_binding.buffer))) +
../../drivers/hip/rccl_channel.c:          iree_hal_buffer_byte_offset(entry->send_binding.buffer) +
../../drivers/hip/rccl_channel.c:          entry->send_binding.offset;
../../drivers/hip/rccl_channel.c:                      entry->recv_binding.buffer))) +
../../drivers/hip/rccl_channel.c:          iree_hal_buffer_byte_offset(entry->recv_binding.buffer) +
../../drivers/hip/rccl_channel.c:          entry->recv_binding.offset;
../../drivers/hip/rccl_channel.c:      iree_device_size_t send_count = entry->element_count / channel->count;
../../drivers/hip/rccl_channel.c:          iree_hal_collective_element_byte_count(entry->op.element_type);
../../drivers/hip/rccl_channel.c:      for (iree_host_size_t r = 0; r < channel->count; ++r) {
../../drivers/hip/rccl_channel.c:                      entry->send_binding.buffer))) +
../../drivers/hip/rccl_channel.c:          iree_hal_buffer_byte_offset(entry->send_binding.buffer) +
../../drivers/hip/rccl_channel.c:          entry->send_binding.offset;
../../drivers/hip/rccl_channel.c:                      entry->recv_binding.buffer))) +
../../drivers/hip/rccl_channel.c:          iree_hal_buffer_byte_offset(entry->recv_binding.buffer) +
../../drivers/hip/rccl_channel.c:          entry->recv_binding.offset;
../../drivers/hip/rccl_channel.c:                        entry->element_count, datatype, entry->param, comm,
../../drivers/hip/rccl_channel.c:                      entry->send_binding.buffer))) +
../../drivers/hip/rccl_channel.c:          iree_hal_buffer_byte_offset(entry->send_binding.buffer) +
../../drivers/hip/rccl_channel.c:          entry->send_binding.offset;
../../drivers/hip/rccl_channel.c:                      entry->recv_binding.buffer))) +
../../drivers/hip/rccl_channel.c:          iree_hal_buffer_byte_offset(entry->recv_binding.buffer) +
../../drivers/hip/rccl_channel.c:          entry->recv_binding.offset;
../../drivers/hip/rccl_channel.c:          iree_hal_hip_get_nccl_reduction_type(entry->op.reduction, &redop));
../../drivers/hip/rccl_channel.c:                     entry->element_count, datatype, redop, entry->param, comm,
../../drivers/hip/rccl_channel.c:                      entry->send_binding.buffer))) +
../../drivers/hip/rccl_channel.c:          iree_hal_buffer_byte_offset(entry->send_binding.buffer) +
../../drivers/hip/rccl_channel.c:          entry->send_binding.offset;
../../drivers/hip/rccl_channel.c:                      entry->recv_binding.buffer))) +
../../drivers/hip/rccl_channel.c:          iree_hal_buffer_byte_offset(entry->recv_binding.buffer) +
../../drivers/hip/rccl_channel.c:          entry->recv_binding.offset;
../../drivers/hip/rccl_channel.c:          iree_hal_hip_get_nccl_reduction_type(entry->op.reduction, &redop));
../../drivers/hip/rccl_channel.c:                            entry->element_count, datatype, redop, comm,
../../drivers/hip/rccl_channel.c:                      entry->send_binding.buffer))) +
../../drivers/hip/rccl_channel.c:          iree_hal_buffer_byte_offset(entry->send_binding.buffer) +
../../drivers/hip/rccl_channel.c:          entry->send_binding.offset;
../../drivers/hip/rccl_channel.c:          ncclSend((const void*)sendbuff, entry->element_count, datatype,
../../drivers/hip/rccl_channel.c:                   entry->param, comm, stream),
../../drivers/hip/rccl_channel.c:                      entry->recv_binding.buffer))) +
../../drivers/hip/rccl_channel.c:          iree_hal_buffer_byte_offset(entry->recv_binding.buffer) +
../../drivers/hip/rccl_channel.c:          entry->recv_binding.offset;
../../drivers/hip/rccl_channel.c:                                ncclRecv((void*)recvbuff, entry->element_count,
../../drivers/hip/rccl_channel.c:                                         datatype, entry->param, comm, stream),
../../drivers/hip/rccl_channel.c:                      entry->send_binding.buffer))) +
../../drivers/hip/rccl_channel.c:          iree_hal_buffer_byte_offset(entry->send_binding.buffer) +
../../drivers/hip/rccl_channel.c:          entry->send_binding.offset;
../../drivers/hip/rccl_channel.c:                      entry->recv_binding.buffer))) +
../../drivers/hip/rccl_channel.c:          iree_hal_buffer_byte_offset(entry->recv_binding.buffer) +
../../drivers/hip/rccl_channel.c:          entry->recv_binding.offset;
../../drivers/hip/rccl_channel.c:      memcpy(&sendid, &entry->param, 2);
../../drivers/hip/rccl_channel.c:      memcpy(&recvid, (char*)&entry->param + 2, 2);
../../drivers/hip/rccl_channel.c:      if (sendid != -1) {
../../drivers/hip/rccl_channel.c:            ncclSend((const void*)sendbuff, entry->element_count, datatype,
../../drivers/hip/rccl_channel.c:      if (recvid != -1) {
../../drivers/hip/rccl_channel.c:            ncclRecv((void*)recvbuff, entry->element_count, datatype, recvid,
../../drivers/hip/rccl_channel.c:            entry->element_count *
../../drivers/hip/rccl_channel.c:            iree_hal_collective_element_byte_count(entry->op.element_type);
../../drivers/hip/rccl_channel.c:            channel->hip_symbols,
../../drivers/hip/rccl_channel.c:  for (iree_host_size_t i = 0; i < batch->count; ++i) {
../../drivers/hip/rccl_channel.c:    iree_hal_collective_batch_entry_t* entry = &batch->entries[i];
../../drivers/hip/rccl_channel.c:        iree_hal_collective_op_format(&entry->op, &string_temp);
../../drivers/hip/rccl_channel.c:  for (iree_host_size_t i = 0; i < batch->count; ++i) {
../../drivers/hip/rccl_channel.c:        iree_hal_hip_nccl_submit_batch_entry(&batch->entries[i], stream));
../../drivers/hip/rccl_channel.c:  // End all zones we began above - note that these are just simply nested so
../../drivers/hip/rccl_channel.c:    for (iree_host_size_t i = 0; i < batch->count; ++i) {
../../drivers/hip/status_util.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/status_util.c:  const char* error_name = syms->hipGetErrorName(result);
../../drivers/hip/status_util.c:  const char* error_string = syms->hipGetErrorString(result);
../../drivers/hip/rccl_headers.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/hip_device.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/status_util.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/status_util.h:  iree_hal_hip_result_to_status((syms), ((syms)->expr), __FILE__, __LINE__)
../../drivers/hip/status_util.h:  IREE_RETURN_IF_ERROR(iree_hal_hip_result_to_status((syms), ((syms)->expr), \
../../drivers/hip/status_util.h:      iree_hal_hip_result_to_status((syms), ((syms)->expr), __FILE__,   \
../../drivers/hip/status_util.h:  IREE_IGNORE_ERROR(iree_hal_hip_result_to_status((syms), ((syms)->expr), \
../../drivers/hip/rccl_dynamic_symbol_table.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/hip_headers.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/hip_headers.h:#error "32-bit not supported on HIP backend"
../../drivers/hip/hip_headers.h:// Order matters here--hip_deprecated.h depends on hip_runtime_api.h. So turn
../../drivers/hip/hip_headers.h:// off clang-format.
../../drivers/hip/hip_headers.h:// clang-format off
../../drivers/hip/hip_headers.h:// clang-format on
../../drivers/hip/nop_executable_cache.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/nop_executable_cache.c:                               &executable_cache->resource);
../../drivers/hip/nop_executable_cache.c:  executable_cache->host_allocator = host_allocator;
../../drivers/hip/nop_executable_cache.c:  executable_cache->symbols = symbols;
../../drivers/hip/nop_executable_cache.c:  executable_cache->topology = topology;
../../drivers/hip/nop_executable_cache.c:  iree_allocator_t host_allocator = executable_cache->host_allocator;
../../drivers/hip/nop_executable_cache.c:      executable_cache->symbols, executable_cache->topology, executable_params,
../../drivers/hip/nop_executable_cache.c:      executable_cache->host_allocator, out_executable);
../../drivers/hip/rccl_status_util.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/rccl_status_util.c:                                        syms->ncclGetErrorString(result));
../../drivers/hip/hip_multi_queue_command_buffer.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/hip_multi_queue_command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/hip/hip_multi_queue_command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/hip/hip_multi_queue_command_buffer.c:      &iree_hal_hip_multi_queue_command_buffer_vtable, &command_buffer->base);
../../drivers/hip/hip_multi_queue_command_buffer.c:  command_buffer->host_allocator = host_allocator;
../../drivers/hip/hip_multi_queue_command_buffer.c:  command_buffer->command_buffer_count = command_buffer_count;
../../drivers/hip/hip_multi_queue_command_buffer.c:  command_buffer->topology = topology;
../../drivers/hip/hip_multi_queue_command_buffer.c:  command_buffer->hip_symbols = hip_symbols;
../../drivers/hip/hip_multi_queue_command_buffer.c:    command_buffer->child_buffers[i] = in_command_buffers[i];
../../drivers/hip/hip_multi_queue_command_buffer.c:    iree_hal_resource_retain(command_buffer->child_buffers[i]);
../../drivers/hip/hip_multi_queue_command_buffer.c:  for (iree_host_size_t i = 0; i < command_buffer->command_buffer_count; ++i) {
../../drivers/hip/hip_multi_queue_command_buffer.c:    iree_hal_resource_release(command_buffer->child_buffers[i]);
../../drivers/hip/hip_multi_queue_command_buffer.c:  iree_allocator_free(command_buffer->host_allocator, command_buffer);
../../drivers/hip/hip_multi_queue_command_buffer.c:  return iree_hal_resource_is(&command_buffer->resource,
../../drivers/hip/hip_multi_queue_command_buffer.c:  if (!(command_buffer->base.queue_affinity & queue_affinity)) {
../../drivers/hip/hip_multi_queue_command_buffer.c:  int index = iree_math_count_ones_u64(command_buffer->base.queue_affinity &
../../drivers/hip/hip_multi_queue_command_buffer.c:                                       (queue_affinity - 1));
../../drivers/hip/hip_multi_queue_command_buffer.c:  *out_command_buffer = command_buffer->child_buffers[index];
../../drivers/hip/hip_multi_queue_command_buffer.c:        command_buffer->base.queue_affinity;                             \
../../drivers/hip/hip_multi_queue_command_buffer.c:          command_buffer->hip_symbols,                                   \
../../drivers/hip/hip_multi_queue_command_buffer.c:          command_buffer->topology.devices[device_ordinal].hip_context); \
../../drivers/hip/hip_multi_queue_command_buffer.c:                   command_buffer->child_buffers[command_buffer_index]));
../../drivers/hip/hip_multi_queue_command_buffer.c:                   command_buffer->child_buffers[command_buffer_index]));
../../drivers/hip/hip_multi_queue_command_buffer.c:                           command_buffer->child_buffers[command_buffer_index],
../../drivers/hip/hip_multi_queue_command_buffer.c:                           command_buffer->child_buffers[command_buffer_index],
../../drivers/hip/hip_multi_queue_command_buffer.c:                           command_buffer->child_buffers[command_buffer_index],
../../drivers/hip/hip_multi_queue_command_buffer.c:          command_buffer->child_buffers[command_buffer_index], event_count,
../../drivers/hip/hip_multi_queue_command_buffer.c:                           command_buffer->child_buffers[command_buffer_index],
../../drivers/hip/hip_multi_queue_command_buffer.c:                           command_buffer->child_buffers[command_buffer_index],
../../drivers/hip/hip_multi_queue_command_buffer.c:                           command_buffer->child_buffers[command_buffer_index],
../../drivers/hip/hip_multi_queue_command_buffer.c:                           command_buffer->child_buffers[command_buffer_index],
../../drivers/hip/hip_multi_queue_command_buffer.c:                   command_buffer->child_buffers[command_buffer_index], channel,
../../drivers/hip/hip_multi_queue_command_buffer.c:                  command_buffer->child_buffers[command_buffer_index],
../../drivers/accel/cts/CMakeLists.txt:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/accel/cts/CMakeLists.txt:set(NATIVE_EXECUTABLE_FORMAT "\"${EXECUTABLE_FORMAT_PREFIX}-elf-\" IREE_ARCH")
../../drivers/accel/cts/CMakeLists.txt:  "--gtest_filter=-${FILTER_TESTS}"
../../drivers/accel/cts/CMakeLists.txt:      local-sync
../../drivers/accel/cts/CMakeLists.txt:      embedded-elf
../../drivers/accel/cts/CMakeLists.txt:      "llvm-cpu"
../../drivers/accel/cts/CMakeLists.txt:      driver=local-sync
../../drivers/accel/cts/CMakeLists.txt:      "--iree-llvmcpu-target-cpu=generic"
../../drivers/accel/cts/CMakeLists.txt:      local-sync
../../drivers/accel/cts/CMakeLists.txt:      "\"vmvx-bytecode-fb\""
../../drivers/accel/cts/CMakeLists.txt:      driver=local-sync
../../drivers/hip/event_pool.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/event_pool.c://===----------------------------------------------------------------------===//
../../drivers/hip/event_pool.c://===----------------------------------------------------------------------===//
../../drivers/hip/event_pool.c:  // * 1 - when inside the event pool and to be acquired;
../../drivers/hip/event_pool.c:  // * >= 1 - when acquired outside of the event pool;
../../drivers/hip/event_pool.c:  // * 0 - when before releasing back to the pool or destruction.
../../drivers/hip/event_pool.c:  // instead of re-adding it to the pool. We should not delete
../../drivers/hip/event_pool.c:  return event->hip_event;
../../drivers/hip/event_pool.c:  iree_allocator_t host_allocator = event->host_allocator;
../../drivers/hip/event_pool.c:  const iree_hal_hip_dynamic_symbols_t* symbols = event->symbols;
../../drivers/hip/event_pool.c:  IREE_ASSERT_REF_COUNT_ZERO(&event->ref_count);
../../drivers/hip/event_pool.c:  if (!event->exported) {
../../drivers/hip/event_pool.c:    IREE_HIP_IGNORE_ERROR(symbols, hipEventDestroy(event->hip_event));
../../drivers/hip/event_pool.c:  iree_atomic_ref_count_init(&event->ref_count);  // -> 1
../../drivers/hip/event_pool.c:  event->host_allocator = host_allocator;
../../drivers/hip/event_pool.c:  event->symbols = symbols;
../../drivers/hip/event_pool.c:  event->pool = pool;
../../drivers/hip/event_pool.c:  event->hip_event = imported_event;
../../drivers/hip/event_pool.c:  event->exported = false;
../../drivers/hip/event_pool.c:  if (event->hip_event) {
../../drivers/hip/event_pool.c:    event->imported = true;
../../drivers/hip/event_pool.c:        hipEventCreateWithFlags(&event->hip_event, hipEventDisableTiming),
../../drivers/hip/event_pool.c:    iree_atomic_ref_count_dec(&event->ref_count);  // -> 0
../../drivers/hip/event_pool.c:  iree_atomic_ref_count_inc(&event->ref_count);
../../drivers/hip/event_pool.c:  if (iree_atomic_ref_count_dec(&event->ref_count) == 1) {
../../drivers/hip/event_pool.c:    iree_hal_hip_event_pool_t* pool = event->pool;
../../drivers/hip/event_pool.c:    iree_hal_hip_event_pool_release(pool);  // -1
../../drivers/hip/event_pool.c:  if (event->imported) {
../../drivers/hip/event_pool.c:  event->exported = true;
../../drivers/hip/event_pool.c://===----------------------------------------------------------------------===//
../../drivers/hip/event_pool.c://===----------------------------------------------------------------------===//
../../drivers/hip/event_pool.c:      available_capacity * sizeof(*event_pool->available_list);
../../drivers/hip/event_pool.c:  iree_atomic_ref_count_init(&event_pool->ref_count);  // -> 1
../../drivers/hip/event_pool.c:  event_pool->host_allocator = host_allocator;
../../drivers/hip/event_pool.c:  event_pool->symbols = symbols;
../../drivers/hip/event_pool.c:  iree_slim_mutex_initialize(&event_pool->event_mutex);
../../drivers/hip/event_pool.c:  event_pool->available_capacity = available_capacity;
../../drivers/hip/event_pool.c:  event_pool->available_count = 0;
../../drivers/hip/event_pool.c:  event_pool->device_context = device_context;
../../drivers/hip/event_pool.c:          &event_pool->available_list[event_pool->available_count++]);
../../drivers/hip/event_pool.c:      iree_hal_hip_event_create(event_pool->symbols, event_pool,
../../drivers/hip/event_pool.c:                                event_pool->host_allocator, event, out_event);
../../drivers/hip/event_pool.c:  iree_allocator_t host_allocator = event_pool->host_allocator;
../../drivers/hip/event_pool.c:  for (iree_host_size_t i = 0; i < event_pool->available_count; ++i) {
../../drivers/hip/event_pool.c:    iree_hal_hip_event_t* event = event_pool->available_list[i];
../../drivers/hip/event_pool.c:    iree_atomic_ref_count_dec(&event->ref_count);  // -> 0
../../drivers/hip/event_pool.c:  IREE_ASSERT_REF_COUNT_ZERO(&event_pool->ref_count);
../../drivers/hip/event_pool.c:  iree_slim_mutex_deinitialize(&event_pool->event_mutex);
../../drivers/hip/event_pool.c:  iree_atomic_ref_count_inc(&event_pool->ref_count);
../../drivers/hip/event_pool.c:  if (iree_atomic_ref_count_dec(&event_pool->ref_count) == 1) {
../../drivers/hip/event_pool.c:  iree_slim_mutex_lock(&event_pool->event_mutex);
../../drivers/hip/event_pool.c:      iree_min(event_pool->available_count, event_count);
../../drivers/hip/event_pool.c:        event_pool->available_count - from_pool_count;
../../drivers/hip/event_pool.c:    memcpy(out_events, &event_pool->available_list[pool_base_index],
../../drivers/hip/event_pool.c:           from_pool_count * sizeof(*event_pool->available_list));
../../drivers/hip/event_pool.c:    event_pool->available_count -= from_pool_count;
../../drivers/hip/event_pool.c:    remaining_count -= from_pool_count;
../../drivers/hip/event_pool.c:  iree_slim_mutex_unlock(&event_pool->event_mutex);
../../drivers/hip/event_pool.c:        z0, iree_hal_hip_set_context(event_pool->symbols,
../../drivers/hip/event_pool.c:                                     event_pool->device_context));
../../drivers/hip/event_pool.c:          event_pool->symbols, event_pool, event_pool->host_allocator, NULL,
../../drivers/hip/event_pool.c:    iree_hal_hip_event_pool_retain(out_events[i]->pool);  // +1
../../drivers/hip/event_pool.c:  iree_slim_mutex_lock(&event_pool->event_mutex);
../../drivers/hip/event_pool.c:    if (!events[i]->imported && !events[i]->exported &&
../../drivers/hip/event_pool.c:        event_pool->available_capacity > event_pool->available_count) {
../../drivers/hip/event_pool.c:      event_pool->available_list[event_pool->available_count] = events[i];
../../drivers/hip/event_pool.c:      event_pool->available_count += 1;
../../drivers/hip/event_pool.c:  iree_slim_mutex_unlock(&event_pool->event_mutex);
../../drivers/hip/event_semaphore.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/event_semaphore.h:// Thread-safe; multiple threads may signal/wait values on the same semaphore.
../../drivers/hip/event_semaphore.h:// Performs a multi-wait on one or more semaphores. Returns
../../drivers/hip/hip_buffer.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/rccl_dynamic_symbols.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/rccl_dynamic_symbols.c:        syms->dylib, name, (void**)&syms->nccl_symbol_name)); \
../../drivers/hip/rccl_dynamic_symbols.c:        syms->dylib, name, (void**)&syms->nccl_symbol_name)); \
../../drivers/hip/rccl_dynamic_symbols.c:  if (!hip_library->dylib) {
../../drivers/hip/rccl_dynamic_symbols.c:      host_allocator, &out_syms->dylib);
../../drivers/hip/rccl_dynamic_symbols.c:    status = iree_hal_hip_nccl_check_version(out_syms->dylib);
../../drivers/hip/rccl_dynamic_symbols.c:    iree_dynamic_library_release(out_syms->dylib);
../../drivers/hip/rccl_dynamic_symbols.c:    out_syms->dylib = NULL;
../../drivers/hip/rccl_dynamic_symbols.c:  iree_dynamic_library_release(syms->dylib);
../../drivers/hip/hip_allocator.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/hip_allocator.c:  // To support device-local + host-visible memory we need concurrent managed
../../drivers/hip/hip_allocator.c:  // all device-local + host-visible memory into host-local + device-visible
../../drivers/hip/hip_allocator.c:  // page-locked memory. The compiler tries to avoid this for high-traffic
../../drivers/hip/hip_allocator.c:                "device-local + host-visible memory)");
../../drivers/hip/hip_allocator.c:                  topology.count * sizeof(*allocator->async_allocation_maps),
../../drivers/hip/hip_allocator.c:                               &allocator->resource);
../../drivers/hip/hip_allocator.c:  allocator->parent_device = parent_device;
../../drivers/hip/hip_allocator.c:  allocator->supports_memory_pools = supports_memory_pools;
../../drivers/hip/hip_allocator.c:  allocator->symbols = hip_symbols;
../../drivers/hip/hip_allocator.c:  allocator->host_allocator = host_allocator;
../../drivers/hip/hip_allocator.c:  allocator->supports_concurrent_managed_access =
../../drivers/hip/hip_allocator.c:  allocator->topology = topology;
../../drivers/hip/hip_allocator.c:  allocator->async_allocation_maps =
../../drivers/hip/hip_allocator.c:        allocator->async_allocation_maps[i].inline_storage,
../../drivers/hip/hip_allocator.c:        sizeof(allocator->async_allocation_maps[i].inline_storage),
../../drivers/hip/hip_allocator.c:        &allocator->async_allocation_maps[i].tree);
../../drivers/hip/hip_allocator.c:  iree_slim_mutex_initialize(&allocator->async_allocation_mutex);
../../drivers/hip/hip_allocator.c:  for (iree_host_size_t i = 0; i < allocator->topology.count; ++i) {
../../drivers/hip/hip_allocator.c:             &allocator->async_allocation_maps[i].tree);
../../drivers/hip/hip_allocator.c:      while (!iree_hal_hip_async_allocation_queue_empty(&queue_item->queue)) {
../../drivers/hip/hip_allocator.c:            iree_hal_hip_async_allocation_queue_at(&queue_item->queue, 0);
../../drivers/hip/hip_allocator.c:            allocator->symbols, hipFree(allocation.pointer), "hipFree"));
../../drivers/hip/hip_allocator.c:        iree_hal_hip_async_allocation_queue_pop_front(&queue_item->queue, 1);
../../drivers/hip/hip_allocator.c:      iree_hal_hip_async_allocation_queue_deinitialize(&queue_item->queue);
../../drivers/hip/hip_allocator.c:        &allocator->async_allocation_maps[i].tree);
../../drivers/hip/hip_allocator.c:  iree_slim_mutex_deinitialize(&allocator->async_allocation_mutex);
../../drivers/hip/hip_allocator.c:  iree_allocator_free(allocator->host_allocator, allocator);
../../drivers/hip/hip_allocator.c:  return allocator->host_allocator;
../../drivers/hip/hip_allocator.c:  iree_slim_mutex_lock(&allocator->async_allocation_mutex);
../../drivers/hip/hip_allocator.c:  for (iree_host_size_t i = 0; i < allocator->topology.count; ++i) {
../../drivers/hip/hip_allocator.c:        allocator->symbols,
../../drivers/hip/hip_allocator.c:            allocator->topology.devices[i].hip_dispatch_stream),
../../drivers/hip/hip_allocator.c:             &allocator->async_allocation_maps[i].tree);
../../drivers/hip/hip_allocator.c:      while (!iree_hal_hip_async_allocation_queue_empty(&queue_item->queue)) {
../../drivers/hip/hip_allocator.c:            iree_hal_hip_async_allocation_queue_at(&queue_item->queue, 0);
../../drivers/hip/hip_allocator.c:            allocator->symbols, hipFree(allocation.pointer), "hipFree");
../../drivers/hip/hip_allocator.c:        iree_hal_hip_async_allocation_queue_pop_front(&queue_item->queue, 1);
../../drivers/hip/hip_allocator.c:  iree_slim_mutex_unlock(&allocator->async_allocation_mutex);
../../drivers/hip/hip_allocator.c:    memcpy(out_statistics, &allocator->statistics, sizeof(*out_statistics));
../../drivers/hip/hip_allocator.c:    if (allocator->supports_memory_pools) {
../../drivers/hip/hip_allocator.c:      for (iree_host_size_t i = 0; i < allocator->topology.count; ++i) {
../../drivers/hip/hip_allocator.c:            &allocator->topology.devices[i].memory_pools, out_statistics);
../../drivers/hip/hip_allocator.c:  if (allocator->supports_concurrent_managed_access) {
../../drivers/hip/hip_allocator.c:    ++count;  // device-local | host-visible
../../drivers/hip/hip_allocator.c:    // NOTE: lightweight as this is hit in normal pre-sizing usage.
../../drivers/hip/hip_allocator.c:  // page-locked memory and it'd be good to enforce that.
../../drivers/hip/hip_allocator.c:  // Device-local memory (dispatch resources):
../../drivers/hip/hip_allocator.c:  if (allocator->supports_concurrent_managed_access) {
../../drivers/hip/hip_allocator.c:    // Device-local managed memory with host mapping support:
../../drivers/hip/hip_allocator.c:  // Write-combined page-locked host-local memory (upload):
../../drivers/hip/hip_allocator.c:  // Cached page-locked host-local memory (download):
../../drivers/hip/hip_allocator.c:  // self-consistent and just look at whether we can get a device pointer.
../../drivers/hip/hip_allocator.c:  if (iree_all_bits_set(params->type, IREE_HAL_MEMORY_TYPE_DEVICE_VISIBLE)) {
../../drivers/hip/hip_allocator.c:  if (iree_all_bits_set(params->type, IREE_HAL_MEMORY_TYPE_DEVICE_VISIBLE)) {
../../drivers/hip/hip_allocator.c:    if (iree_any_bit_set(params->usage, IREE_HAL_BUFFER_USAGE_TRANSFER)) {
../../drivers/hip/hip_allocator.c:    if (iree_any_bit_set(params->usage,
../../drivers/hip/hip_allocator.c:  if (iree_all_bits_set(params->type, IREE_HAL_MEMORY_TYPE_DEVICE_LOCAL |
../../drivers/hip/hip_allocator.c:    // If concurrent managed access is not supported then make device-local +
../../drivers/hip/hip_allocator.c:    // host-visible allocations fall back to host-local + device-visible
../../drivers/hip/hip_allocator.c:    // page-locked memory. This will be significantly slower for the device to
../../drivers/hip/hip_allocator.c:    if (!allocator->supports_concurrent_managed_access) {
../../drivers/hip/hip_allocator.c:      params->type &= ~(IREE_HAL_MEMORY_TYPE_DEVICE_LOCAL |
../../drivers/hip/hip_allocator.c:      params->type |=
../../drivers/hip/hip_allocator.c:  params->type &= ~IREE_HAL_MEMORY_TYPE_OPTIMAL;
../../drivers/hip/hip_allocator.c:  // application is unlikely to do anything when requesting a 0-byte buffer; but
../../drivers/hip/hip_allocator.c:        iree_hal_memory_type_format(params->type, &temp0);
../../drivers/hip/hip_allocator.c:        iree_hal_buffer_usage_format(params->usage, &temp1);
../../drivers/hip/hip_allocator.c:  if (params->queue_affinity) {
../../drivers/hip/hip_allocator.c:    device_ordinal = iree_math_count_trailing_zeros_u64(params->queue_affinity);
../../drivers/hip/hip_allocator.c:              allocator->symbols,
../../drivers/hip/hip_allocator.c:                  allocator->topology.devices[device_ordinal].hip_context)));
../../drivers/hip/hip_allocator.c:          allocator->symbols,
../../drivers/hip/hip_allocator.c:          allocator->supports_concurrent_managed_access) {
../../drivers/hip/hip_allocator.c:            allocator->symbols,
../../drivers/hip/hip_allocator.c:                allocator->topology.devices[device_ordinal].hip_device,
../../drivers/hip/hip_allocator.c:                allocator->topology.devices[device_ordinal]
../../drivers/hip/hip_allocator.c:      status = IREE_HIP_CALL_TO_STATUS(allocator->symbols,
../../drivers/hip/hip_allocator.c:        allocator->symbols, hipHostMalloc(&host_ptr, allocation_size, flags));
../../drivers/hip/hip_allocator.c:          allocator->symbols,
../../drivers/hip/hip_allocator.c:        .device = allocator->parent_device,
../../drivers/hip/hip_allocator.c:        .queue_affinity = params->queue_affinity ? params->queue_affinity
../../drivers/hip/hip_allocator.c:        &allocator->statistics, compat_params.type, allocation_size));
../../drivers/hip/hip_allocator.c:      iree_hal_hip_buffer_free(allocator->symbols, buffer_type, device_ptr,
../../drivers/hip/hip_allocator.c:      IREE_HIP_CALL_TO_STATUS(allocator->symbols, hipCtxPopCurrent(NULL)));
../../drivers/hip/hip_allocator.c:  iree_hal_hip_buffer_free(async_data->allocator->symbols,
../../drivers/hip/hip_allocator.c:                           async_data->buffer_type, async_data->device_pointer,
../../drivers/hip/hip_allocator.c:                           async_data->host_pointer);
../../drivers/hip/hip_allocator.c:  switch (async_data->buffer_type) {
../../drivers/hip/hip_allocator.c:                            (void*)async_data->device_pointer);
../../drivers/hip/hip_allocator.c:          &async_data->allocator->statistics, async_data->memory_type,
../../drivers/hip/hip_allocator.c:          async_data->allocation_size));
../../drivers/hip/hip_allocator.c:  iree_allocator_free(async_data->allocator->host_allocator, async_data);
../../drivers/hip/hip_allocator.c:  iree_status_t status = iree_allocator_malloc(allocator->host_allocator,
../../drivers/hip/hip_allocator.c:    release_async_data->allocator = allocator;
../../drivers/hip/hip_allocator.c:    release_async_data->device_pointer =
../../drivers/hip/hip_allocator.c:    release_async_data->host_pointer = iree_hal_hip_buffer_host_pointer(buffer);
../../drivers/hip/hip_allocator.c:    release_async_data->buffer_type = iree_hal_hip_buffer_type(buffer);
../../drivers/hip/hip_allocator.c:      release_async_data->memory_type = iree_hal_buffer_memory_type(buffer);
../../drivers/hip/hip_allocator.c:      release_async_data->allocation_size =
../../drivers/hip/hip_allocator.c:        allocator->parent_device, &iree_hal_hip_buffer_release_callback_async,
../../drivers/hip/hip_allocator.c:  iree_device_size_t allocation_size = external_buffer->size;
../../drivers/hip/hip_allocator.c:        iree_hal_memory_type_format(params->type, &temp0);
../../drivers/hip/hip_allocator.c:        iree_hal_buffer_usage_format(params->usage, &temp1);
../../drivers/hip/hip_allocator.c:  if (params->queue_affinity) {
../../drivers/hip/hip_allocator.c:    device_ordinal = iree_math_count_trailing_zeros_u64(params->queue_affinity);
../../drivers/hip/hip_allocator.c:      allocator->symbols,
../../drivers/hip/hip_allocator.c:          allocator->topology.devices[device_ordinal].hip_context)));
../../drivers/hip/hip_allocator.c:  switch (external_buffer->type) {
../../drivers/hip/hip_allocator.c:            "unable to register host allocations as device-local memory");
../../drivers/hip/hip_allocator.c:      host_ptr = external_buffer->handle.host_allocation.ptr;
../../drivers/hip/hip_allocator.c:          allocator->symbols,
../../drivers/hip/hip_allocator.c:          hipHostRegister(host_ptr, external_buffer->size, register_flags),
../../drivers/hip/hip_allocator.c:            allocator->symbols,
../../drivers/hip/hip_allocator.c:          (hipDeviceptr_t)external_buffer->handle.device_allocation.ptr;
../../drivers/hip/hip_allocator.c:                              "handle-based imports not yet implemented");
../../drivers/hip/hip_allocator.c:        .device = allocator->parent_device,
../../drivers/hip/hip_allocator.c:        .queue_affinity = params->queue_affinity ? params->queue_affinity
../../drivers/hip/hip_allocator.c:        compat_params.usage, external_buffer->size,
../../drivers/hip/hip_allocator.c:        /*byte_length=*/external_buffer->size, buffer_type, device_ptr,
../../drivers/hip/hip_allocator.c:      iree_hal_hip_buffer_free(allocator->symbols, buffer_type, device_ptr,
../../drivers/hip/hip_allocator.c:      IREE_HIP_CALL_TO_STATUS(allocator->symbols, hipCtxPopCurrent(NULL)));
../../drivers/hip/hip_allocator.c:          out_external_buffer->flags = requested_flags;
../../drivers/hip/hip_allocator.c:          out_external_buffer->type = requested_type;
../../drivers/hip/hip_allocator.c:          out_external_buffer->handle.device_allocation.ptr =
../../drivers/hip/hip_allocator.c:          out_external_buffer->size = iree_hal_buffer_allocation_size(buffer);
../../drivers/hip/hip_allocator.c:      iree_math_count_trailing_zeros_u64(buffer->placement.queue_affinity);
../../drivers/hip/hip_allocator.c:  iree_slim_mutex_lock(&allocator->async_allocation_mutex);
../../drivers/hip/hip_allocator.c:          &allocator->async_allocation_maps[device_ordinal].tree,
../../drivers/hip/hip_allocator.c:      if (iree_hal_hip_async_allocation_queue_count(&queue_item->queue) != 0) {
../../drivers/hip/hip_allocator.c:            iree_hal_hip_async_allocation_queue_at(&queue_item->queue, 0);
../../drivers/hip/hip_allocator.c:        iree_hal_hip_async_allocation_queue_pop_front(&queue_item->queue, 1);
../../drivers/hip/hip_allocator.c:        if (iree_hal_hip_async_allocation_queue_empty(&queue_item->queue)) {
../../drivers/hip/hip_allocator.c:          iree_hal_hip_async_allocation_queue_deinitialize(&queue_item->queue);
../../drivers/hip/hip_allocator.c:              &allocator->async_allocation_maps[device_ordinal].tree,
../../drivers/hip/hip_allocator.c:  iree_slim_mutex_unlock(&allocator->async_allocation_mutex);
../../drivers/hip/hip_allocator.c:        allocator->symbols,
../../drivers/hip/hip_allocator.c:            allocator->topology.devices[device_ordinal].hip_context));
../../drivers/hip/hip_allocator.c:          allocator->symbols,
../../drivers/hip/hip_allocator.c:          IREE_HIP_CALL_TO_STATUS(allocator->symbols, hipCtxPopCurrent(NULL),
../../drivers/hip/hip_allocator.c:        &allocator->statistics, iree_hal_buffer_memory_type(buffer),
../../drivers/hip/hip_allocator.c:      &allocator->statistics, iree_hal_buffer_memory_type(buffer),
../../drivers/hip/hip_allocator.c:      iree_math_count_trailing_zeros_u64(buffer->placement.queue_affinity);
../../drivers/hip/hip_allocator.c:  iree_slim_mutex_lock(&allocator->async_allocation_mutex);
../../drivers/hip/hip_allocator.c:      &allocator->async_allocation_maps[device_ordinal].tree,
../../drivers/hip/hip_allocator.c:        &allocator->async_allocation_maps[device_ordinal].tree,
../../drivers/hip/hip_allocator.c:    iree_hal_hip_async_allocation_queue_initialize(allocator->host_allocator,
../../drivers/hip/hip_allocator.c:                                                   &queue_item->queue);
../../drivers/hip/hip_allocator.c:             ->queue,
../../drivers/hip/hip_allocator.c:  iree_slim_mutex_unlock(&allocator->async_allocation_mutex);
../../drivers/hip/hip_allocator.c:      &allocator->statistics, iree_hal_buffer_memory_type(buffer),
../../drivers/hip/hip_allocator.c:      allocator->symbols, hipFree(device_ptr), "hipFree");
../../drivers/hip/hip_multi_queue_command_buffer.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/hip_multi_queue_command_buffer.h://===----------------------------------------------------------------------===//
../../drivers/hip/hip_multi_queue_command_buffer.h://===----------------------------------------------------------------------===//
../../drivers/hip/cts/multi_queue_device_creation.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/cts/multi_queue_device_creation.h:    iree_host_size_t device_count = grouped_devices.count(it->first);
../../drivers/hip/cts/multi_queue_device_creation.h:      path += std::to_string(it->second);
../../drivers/accel/CMakeLists.txt:# CMake-only content.                                                          #
../../drivers/hip/stream_command_buffer.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/stream_command_buffer.h:// If |block_pool| is non-NULL then the stream command buffer will retain copies
../../drivers/hip/stream_command_buffer.h:// Returns true if |command_buffer| is a HIP stream-based command buffer.
../../drivers/accel/accel_semaphore.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/accel/accel_semaphore.h://===----------------------------------------------------------------------===//
../../drivers/accel/accel_semaphore.h://===----------------------------------------------------------------------===//
../../drivers/accel/accel_semaphore.h:  // In-process notification signaled when any semaphore value changes.
../../drivers/accel/accel_semaphore.h://===----------------------------------------------------------------------===//
../../drivers/accel/accel_semaphore.h://===----------------------------------------------------------------------===//
../../drivers/accel/accel_semaphore.h:// synchronous backend is intended for - if you want something efficient in the
../../drivers/accel/accel_semaphore.h:// Performs a multi-wait on one or more semaphores.
../../drivers/hip/cts/CMakeLists.txt:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/cts/CMakeLists.txt:  "--iree-hip-target=${IREE_HIP_TEST_TARGET_CHIP}"
../../drivers/hip/cts/CMakeLists.txt:    "--hip_use_streams=true"
../../drivers/hip/cts/CMakeLists.txt:    #     cannot use graph-based command buffer
../../drivers/hip/cts/CMakeLists.txt:    requires-gpu-amd
../../drivers/hip/cts/CMakeLists.txt:    "--hip_use_streams=false"
../../drivers/hip/cts/CMakeLists.txt:    #     cannot use graph-based command buffer
../../drivers/hip/cts/CMakeLists.txt:    "--hip_use_streams=true"
../../drivers/hip/cts/CMakeLists.txt:    #     cannot use graph-based command buffer
../../drivers/hip/cts/CMakeLists.txt:    requires-gpu-amd
../../drivers/hip/cts/CMakeLists.txt:    "--hip_use_streams=false"
../../drivers/hip/cts/CMakeLists.txt:    #     cannot use graph-based command buffer
../../drivers/hip/cts/CMakeLists.txt:    "--hip_use_streams=true"
../../drivers/hip/cts/CMakeLists.txt:    #     cannot use graph-based command buffer
../../drivers/hip/cts/CMakeLists.txt:    requires-gpu-amd
../../drivers/hip/cts/CMakeLists.txt:    "--hip_use_streams=false"
../../drivers/hip/cts/CMakeLists.txt:    #     cannot use graph-based command buffer
../../drivers/accel/accel_driver.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/accel/accel_driver.c:  iree_hal_accel_device_params_initialize(&out_options->default_device_options);
../../drivers/accel/accel_driver.c:      sizeof(*driver) + loader_count * sizeof(*driver->loaders) + identifier.size;
../../drivers/accel/accel_driver.c:                                 &driver->resource);
../../drivers/accel/accel_driver.c:    driver->host_allocator = host_allocator;
../../drivers/accel/accel_driver.c:    driver->device_allocator = device_allocator;
../../drivers/accel/accel_driver.c:        identifier, &driver->identifier,
../../drivers/accel/accel_driver.c:        (char*)driver + total_size - identifier.size);
../../drivers/accel/accel_driver.c:    memcpy(&driver->options, options, sizeof(driver->options));
../../drivers/accel/accel_driver.c:    driver->loader_count = loader_count;
../../drivers/accel/accel_driver.c:    for (iree_host_size_t i = 0; i < driver->loader_count; ++i) {
../../drivers/accel/accel_driver.c:      driver->loaders[i] = loaders[i];
../../drivers/accel/accel_driver.c:      iree_hal_executable_loader_retain(driver->loaders[i]);
../../drivers/accel/accel_driver.c:  iree_allocator_t host_allocator = driver->host_allocator;
../../drivers/accel/accel_driver.c:  iree_hal_allocator_release(driver->device_allocator);
../../drivers/accel/accel_driver.c:  for (iree_host_size_t i = 0; i < driver->loader_count; ++i) {
../../drivers/accel/accel_driver.c:    iree_hal_executable_loader_release(driver->loaders[i]);
../../drivers/accel/accel_driver.c:      driver->identifier, &driver->options.default_device_options,
../../drivers/accel/accel_driver.c:      driver->loader_count, driver->loaders, driver->device_allocator,
../../drivers/accel/accel_driver.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/event_pool.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/event_pool.h://===----------------------------------------------------------------------===//
../../drivers/hip/event_pool.h://===----------------------------------------------------------------------===//
../../drivers/hip/event_pool.h:// Thread-safe; multiple threads may retain and release the same event.
../../drivers/hip/event_pool.h://===----------------------------------------------------------------------===//
../../drivers/hip/event_pool.h://===----------------------------------------------------------------------===//
../../drivers/hip/event_pool.h:// Thread-safe; multiple threads may acquire and release events from the pool.
../../drivers/hip/cleanup_thread.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/cleanup_thread.c:  iree_slim_mutex_lock(&thread->mutex);
../../drivers/hip/cleanup_thread.c:  bool has_request = !iree_hal_hip_callback_queue_empty(&thread->queue);
../../drivers/hip/cleanup_thread.c:  has_request |= thread->do_exit;
../../drivers/hip/cleanup_thread.c:  iree_slim_mutex_unlock(&thread->mutex);
../../drivers/hip/cleanup_thread.c:    iree_notification_await(&thread->notification,
../../drivers/hip/cleanup_thread.c:    iree_slim_mutex_lock(&thread->mutex);
../../drivers/hip/cleanup_thread.c:    exit |= thread->do_exit;
../../drivers/hip/cleanup_thread.c:    iree_status_t status = thread->failure_status;
../../drivers/hip/cleanup_thread.c:    while (!iree_hal_hip_callback_queue_empty(&thread->queue)) {
../../drivers/hip/cleanup_thread.c:          iree_hal_hip_callback_queue_at(&thread->queue, 0);
../../drivers/hip/cleanup_thread.c:      iree_hal_hip_callback_queue_pop_front(&thread->queue, 1);
../../drivers/hip/cleanup_thread.c:      iree_slim_mutex_unlock(&thread->mutex);
../../drivers/hip/cleanup_thread.c:            thread->symbols,
../../drivers/hip/cleanup_thread.c:      iree_slim_mutex_lock(&thread->mutex);
../../drivers/hip/cleanup_thread.c:        thread->failure_status = status;
../../drivers/hip/cleanup_thread.c:      if (!iree_status_is_ok(thread->failure_status)) {
../../drivers/hip/cleanup_thread.c:        status = iree_status_clone(thread->failure_status);
../../drivers/hip/cleanup_thread.c:    iree_slim_mutex_unlock(&thread->mutex);
../../drivers/hip/cleanup_thread.c:  thread->symbols = symbols;
../../drivers/hip/cleanup_thread.c:  thread->do_exit = false;
../../drivers/hip/cleanup_thread.c:  iree_slim_mutex_initialize(&thread->mutex);
../../drivers/hip/cleanup_thread.c:  iree_hal_hip_callback_queue_initialize(host_allocator, &thread->queue);
../../drivers/hip/cleanup_thread.c:  thread->failure_status = iree_ok_status();
../../drivers/hip/cleanup_thread.c:  thread->host_allocator = host_allocator;
../../drivers/hip/cleanup_thread.c:  iree_notification_initialize(&thread->notification);
../../drivers/hip/cleanup_thread.c:  params.name = iree_make_cstring_view("iree-hal-hip-cleanup");
../../drivers/hip/cleanup_thread.c:                         thread, params, host_allocator, &thread->thread);
../../drivers/hip/cleanup_thread.c:    iree_hal_hip_callback_queue_deinitialize(&thread->queue);
../../drivers/hip/cleanup_thread.c:    iree_slim_mutex_deinitialize(&thread->mutex);
../../drivers/hip/cleanup_thread.c:  iree_slim_mutex_lock(&thread->mutex);
../../drivers/hip/cleanup_thread.c:  thread->do_exit = true;
../../drivers/hip/cleanup_thread.c:  iree_slim_mutex_unlock(&thread->mutex);
../../drivers/hip/cleanup_thread.c:  iree_notification_post(&thread->notification, IREE_ALL_WAITERS);
../../drivers/hip/cleanup_thread.c:  iree_thread_release(thread->thread);
../../drivers/hip/cleanup_thread.c:  iree_hal_hip_callback_queue_deinitialize(&thread->queue);
../../drivers/hip/cleanup_thread.c:  iree_slim_mutex_deinitialize(&thread->mutex);
../../drivers/hip/cleanup_thread.c:  iree_allocator_free(thread->host_allocator, thread);
../../drivers/hip/cleanup_thread.c:  iree_slim_mutex_lock(&thread->mutex);
../../drivers/hip/cleanup_thread.c:  if (!iree_status_is_ok(thread->failure_status)) {
../../drivers/hip/cleanup_thread.c:    iree_slim_mutex_unlock(&thread->mutex);
../../drivers/hip/cleanup_thread.c:    return thread->failure_status;
../../drivers/hip/cleanup_thread.c:  iree_hal_hip_callback_queue_push_back(&thread->queue, callback_data);
../../drivers/hip/cleanup_thread.c:  iree_slim_mutex_unlock(&thread->mutex);
../../drivers/hip/cleanup_thread.c:  iree_notification_post(&thread->notification, IREE_ALL_WAITERS);
../../drivers/hip/dispatch_thread.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/dispatch_thread.h:// command buffer that we use in hip. One is a pre-recorded command buffer
../../drivers/hip/dispatch_thread.h:// to that thread as well, as they need to remain in-order.
../../drivers/accel/accel_command_buffer.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/accel/accel_event.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/native_executable.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/native_executable.h:// The max number of per-dispatch bindings allowed in the HIP HAL
../../drivers/hip/native_executable.h:// The max number of per-dispatch constants supported by the HIP HAL
../../drivers/accel/accel_event.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/accel/accel_event.c:    iree_hal_resource_initialize(&iree_hal_accel_event_vtable, &event->resource);
../../drivers/accel/accel_event.c:    event->host_allocator = host_allocator;
../../drivers/accel/accel_event.c:  iree_allocator_t host_allocator = event->host_allocator;
../../drivers/accel/BUILD.bazel:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/event_semaphore.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/event_semaphore.c:  iree_event_deinitialize(&event->event);
../../drivers/hip/event_semaphore.c:  iree_allocator_free(event->host_allocator, event);
../../drivers/hip/event_semaphore.c:// wait or a non-infinite timeout.
../../drivers/hip/event_semaphore.c:  semaphore->host_allocator = host_allocator;
../../drivers/hip/event_semaphore.c:  semaphore->symbols = symbols;
../../drivers/hip/event_semaphore.c:  semaphore->devices = topology;
../../drivers/hip/event_semaphore.c:      semaphore->event_queue.inline_storage,
../../drivers/hip/event_semaphore.c:      sizeof(semaphore->event_queue.inline_storage),
../../drivers/hip/event_semaphore.c:      &semaphore->event_queue.tree);
../../drivers/hip/event_semaphore.c:  iree_notification_initialize(&semaphore->state_notification);
../../drivers/hip/event_semaphore.c:  iree_notification_initialize(&semaphore->external_event_notification);
../../drivers/hip/event_semaphore.c:  iree_slim_mutex_initialize(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:  semaphore->current_visible_value = initial_value;
../../drivers/hip/event_semaphore.c:  semaphore->max_value_to_be_signaled = initial_value;
../../drivers/hip/event_semaphore.c:  semaphore->failure_status = iree_ok_status();
../../drivers/hip/event_semaphore.c:  iree_allocator_t host_allocator = semaphore->host_allocator;
../../drivers/hip/event_semaphore.c:  iree_status_ignore(semaphore->failure_status);
../../drivers/hip/event_semaphore.c:  iree_slim_mutex_deinitialize(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:  iree_notification_deinitialize(&semaphore->external_event_notification);
../../drivers/hip/event_semaphore.c:  iree_notification_deinitialize(&semaphore->state_notification);
../../drivers/hip/event_semaphore.c:           iree_hal_hip_util_tree_first(&semaphore->event_queue.tree);
../../drivers/hip/event_semaphore.c:    iree_hal_hip_event_release(queue_item->event);
../../drivers/hip/event_semaphore.c:    iree_hal_hip_event_release(queue_item->secondary_event);
../../drivers/hip/event_semaphore.c:    iree_hal_resource_release(queue_item->cpu_event);
../../drivers/hip/event_semaphore.c:    iree_hal_hip_semaphore_work_item_t* work_item = queue_item->work_item;
../../drivers/hip/event_semaphore.c:      work_item->scheduled_callback(
../../drivers/hip/event_semaphore.c:          work_item->user_data, base_semaphore,
../../drivers/hip/event_semaphore.c:      iree_hal_hip_semaphore_work_item_t* next = work_item->next;
../../drivers/hip/event_semaphore.c:  iree_hal_hip_util_tree_deinitialize(&semaphore->event_queue.tree);
../../drivers/hip/event_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:  if (value <= semaphore->current_visible_value) {
../../drivers/hip/event_semaphore.c:    iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:      iree_hal_hip_util_tree_get(&semaphore->event_queue.tree, value);
../../drivers/hip/event_semaphore.c:    status = iree_hal_hip_util_tree_insert(&semaphore->event_queue.tree, value,
../../drivers/hip/event_semaphore.c:    if (!item->cpu_event) {
../../drivers/hip/event_semaphore.c:      status = iree_allocator_malloc(semaphore->host_allocator,
../../drivers/hip/event_semaphore.c:                                     sizeof(*item->cpu_event),
../../drivers/hip/event_semaphore.c:                                     (void**)&item->cpu_event);
../../drivers/hip/event_semaphore.c:                                     (iree_hal_resource_t*)item->cpu_event);
../../drivers/hip/event_semaphore.c:        item->cpu_event->host_allocator = semaphore->host_allocator;
../../drivers/hip/event_semaphore.c:        status = iree_event_initialize(false, &item->cpu_event->event);
../../drivers/hip/event_semaphore.c:          iree_allocator_free(semaphore->host_allocator, item->cpu_event);
../../drivers/hip/event_semaphore.c:          item->cpu_event = NULL;
../../drivers/hip/event_semaphore.c:      iree_hal_resource_retain(&item->cpu_event->resource);
../../drivers/hip/event_semaphore.c:      *out_event = item->cpu_event;
../../drivers/hip/event_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:    if (item && item->cpu_event) {
../../drivers/hip/event_semaphore.c:      iree_event_deinitialize(&item->cpu_event->event);
../../drivers/hip/event_semaphore.c:      iree_allocator_free(semaphore->host_allocator, item->cpu_event);
../../drivers/hip/event_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:      semaphore->current_visible_value >= IREE_HAL_SEMAPHORE_FAILURE_VALUE;
../../drivers/hip/event_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:  // fast-path this to just a normal wait.
../../drivers/hip/event_semaphore.c:    // Fast-path if we don't have to wait on only a subset of the semaphores.
../../drivers/hip/event_semaphore.c:      status = iree_wait_set_insert(wait_set, cpu_events[i]->event);
../../drivers/hip/event_semaphore.c:    iree_hal_resource_release(&cpu_events[i]->resource);
../../drivers/hip/event_semaphore.c:    iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:        iree_hal_hip_util_tree_first(&semaphore->event_queue.tree);
../../drivers/hip/event_semaphore.c:      iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:        semaphore->current_visible_value) {
../../drivers/hip/event_semaphore.c:      iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:    iree_hal_hip_util_tree_erase(&semaphore->event_queue.tree, node);
../../drivers/hip/event_semaphore.c:    iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:      iree_event_set(&copy.cpu_event->event);
../../drivers/hip/event_semaphore.c:      iree_hal_resource_release(&copy.cpu_event->resource);
../../drivers/hip/event_semaphore.c:      if (last_work_item && !last_work_item->next) {
../../drivers/hip/event_semaphore.c:        last_work_item->next = next_work_item;
../../drivers/hip/event_semaphore.c:      next_work_item = next_work_item->next;
../../drivers/hip/event_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:  if (semaphore->max_value_to_be_signaled < semaphore->current_visible_value) {
../../drivers/hip/event_semaphore.c:    semaphore->max_value_to_be_signaled = iree_max(
../../drivers/hip/event_semaphore.c:        semaphore->max_value_to_be_signaled, semaphore->current_visible_value);
../../drivers/hip/event_semaphore.c:    iree_notification_post(&semaphore->external_event_notification,
../../drivers/hip/event_semaphore.c:  iree_status_t status = iree_status_clone(semaphore->failure_status);
../../drivers/hip/event_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:    iree_hal_hip_semaphore_work_item_t* next_work_item = work_item->next;
../../drivers/hip/event_semaphore.c:    iree_status_ignore(work_item->scheduled_callback(
../../drivers/hip/event_semaphore.c:        work_item->user_data, base_semaphore, iree_status_clone(status)));
../../drivers/hip/event_semaphore.c:    iree_allocator_free(semaphore->host_allocator, work_item);
../../drivers/hip/event_semaphore.c:  iree_notification_post(&semaphore->state_notification, IREE_ALL_WAITERS);
../../drivers/hip/event_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:  iree_status_t status = iree_status_clone(semaphore->failure_status);
../../drivers/hip/event_semaphore.c:      value > semaphore->max_value_to_be_signaled) {
../../drivers/hip/event_semaphore.c:        iree_hal_hip_util_tree_get(&semaphore->event_queue.tree, value);
../../drivers/hip/event_semaphore.c:      status = iree_hal_hip_util_tree_insert(&semaphore->event_queue.tree,
../../drivers/hip/event_semaphore.c:        item->type = IREE_HAL_HIP_SEMAPHORE_QUEUE_ITEM_INTERNAL;
../../drivers/hip/event_semaphore.c:        item->event = NULL;
../../drivers/hip/event_semaphore.c:        item->cpu_event = NULL;
../../drivers/hip/event_semaphore.c:        item->work_item = NULL;
../../drivers/hip/event_semaphore.c:        item->created_device = NULL;
../../drivers/hip/event_semaphore.c:      status = iree_allocator_malloc(semaphore->host_allocator,
../../drivers/hip/event_semaphore.c:        work_item->scheduled_callback = callback;
../../drivers/hip/event_semaphore.c:        work_item->user_data = user_data;
../../drivers/hip/event_semaphore.c:        work_item->next = item->work_item;
../../drivers/hip/event_semaphore.c:        item->work_item = work_item;
../../drivers/hip/event_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:  iree_status_t status = iree_status_clone(semaphore->failure_status);
../../drivers/hip/event_semaphore.c:    iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:      &semaphore->event_queue.tree, semaphore->max_value_to_be_signaled);
../../drivers/hip/event_semaphore.c:        queue_item->type != IREE_HAL_HIP_SEMAPHORE_QUEUE_ITEM_IMPORTED) {
../../drivers/hip/event_semaphore.c:        iree_max(value, iree_max(semaphore->max_value_to_be_signaled,
../../drivers/hip/event_semaphore.c:    iree_hal_hip_semaphore_work_item_t* next_work_item = queue_item->work_item;
../../drivers/hip/event_semaphore.c:      if (last_work_item && !last_work_item->next) {
../../drivers/hip/event_semaphore.c:        last_work_item->next = next_work_item;
../../drivers/hip/event_semaphore.c:      next_work_item = next_work_item->next;
../../drivers/hip/event_semaphore.c:    queue_item->work_item = NULL;
../../drivers/hip/event_semaphore.c:    if (!queue_item->event) {
../../drivers/hip/event_semaphore.c:      iree_hal_hip_util_tree_erase(&semaphore->event_queue.tree, last_node);
../../drivers/hip/event_semaphore.c:  if (value > semaphore->max_value_to_be_signaled) {
../../drivers/hip/event_semaphore.c:    semaphore->max_value_to_be_signaled =
../../drivers/hip/event_semaphore.c:        iree_max(semaphore->max_value_to_be_signaled, value);
../../drivers/hip/event_semaphore.c:    iree_notification_post(&semaphore->external_event_notification,
../../drivers/hip/event_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:    iree_hal_hip_semaphore_work_item_t* next_work_item = work_item->next;
../../drivers/hip/event_semaphore.c:    work_item->scheduled_callback(work_item->user_data, base_semaphore, status);
../../drivers/hip/event_semaphore.c:    iree_allocator_free(semaphore->host_allocator, work_item);
../../drivers/hip/event_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:  if (value <= semaphore->current_visible_value) {
../../drivers/hip/event_semaphore.c:    iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:  iree_status_t status = iree_status_clone(semaphore->failure_status);
../../drivers/hip/event_semaphore.c:        iree_hal_hip_util_tree_get(&semaphore->event_queue.tree, value);
../../drivers/hip/event_semaphore.c:      status = iree_hal_hip_util_tree_insert(&semaphore->event_queue.tree,
../../drivers/hip/event_semaphore.c:        item->cpu_event = NULL;
../../drivers/hip/event_semaphore.c:        item->work_item = NULL;
../../drivers/hip/event_semaphore.c:        item->type = IREE_HAL_HIP_SEMAPHORE_QUEUE_ITEM_INTERNAL;
../../drivers/hip/event_semaphore.c:        item->event = NULL;
../../drivers/hip/event_semaphore.c:        item->created_device = NULL;
../../drivers/hip/event_semaphore.c:        if (item->has_been_waited_on) {
../../drivers/hip/event_semaphore.c:        if (item->event) {
../../drivers/hip/event_semaphore.c:              semaphore->symbols,
../../drivers/hip/event_semaphore.c:              hipStreamWaitEvent(stream, iree_hal_hip_event_handle(item->event),
../../drivers/hip/event_semaphore.c:        item->has_been_waited_on = true;
../../drivers/hip/event_semaphore.c:              ->event;
../../drivers/hip/event_semaphore.c:                      ->event;
../../drivers/hip/event_semaphore.c:          semaphore->symbols,
../../drivers/hip/event_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:  if (value <= semaphore->current_visible_value) {
../../drivers/hip/event_semaphore.c:    iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:  iree_status_t status = iree_status_clone(semaphore->failure_status);
../../drivers/hip/event_semaphore.c:        iree_hal_hip_util_tree_get(&semaphore->event_queue.tree, value);
../../drivers/hip/event_semaphore.c:      status = iree_hal_hip_util_tree_insert(&semaphore->event_queue.tree,
../../drivers/hip/event_semaphore.c:        item->cpu_event = NULL;
../../drivers/hip/event_semaphore.c:        item->work_item = NULL;
../../drivers/hip/event_semaphore.c:        item->event = NULL;
../../drivers/hip/event_semaphore.c:        item->has_been_waited_on = false;
../../drivers/hip/event_semaphore.c:        item->type = IREE_HAL_HIP_SEMAPHORE_QUEUE_ITEM_INTERNAL;
../../drivers/hip/event_semaphore.c:      if (!value->event) {
../../drivers/hip/event_semaphore.c:        status = iree_hal_hip_event_pool_acquire(event_pool, 1, &value->event);
../../drivers/hip/event_semaphore.c:        value->created_device = device;
../../drivers/hip/event_semaphore.c:      if (iree_status_is_ok(status) && !value->has_been_signaled) {
../../drivers/hip/event_semaphore.c:        if (device != value->created_device) {
../../drivers/hip/event_semaphore.c:                                                   &value->secondary_event);
../../drivers/hip/event_semaphore.c:                semaphore->symbols, hipEventRecord(iree_hal_hip_event_handle(
../../drivers/hip/event_semaphore.c:                                                       value->secondary_event),
../../drivers/hip/event_semaphore.c:                semaphore->symbols,
../../drivers/hip/event_semaphore.c:                    value->created_device->hip_async_memory_stream,
../../drivers/hip/event_semaphore.c:                    iree_hal_hip_event_handle(value->secondary_event), 0));
../../drivers/hip/event_semaphore.c:                semaphore->symbols,
../../drivers/hip/event_semaphore.c:                hipEventRecord(iree_hal_hip_event_handle(value->event),
../../drivers/hip/event_semaphore.c:                               value->created_device->hip_async_memory_stream));
../../drivers/hip/event_semaphore.c:              semaphore->symbols,
../../drivers/hip/event_semaphore.c:              hipEventRecord(iree_hal_hip_event_handle(value->event),
../../drivers/hip/event_semaphore.c:        value->has_been_signaled = true;
../../drivers/hip/event_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:  *out_value = semaphore->current_visible_value;
../../drivers/hip/event_semaphore.c:      iree_hal_hip_util_tree_first(&semaphore->event_queue.tree);
../../drivers/hip/event_semaphore.c:             ->event) {
../../drivers/hip/event_semaphore.c:             ->has_been_signaled) {
../../drivers/hip/event_semaphore.c:        semaphore->symbols->hipEventQuery(iree_hal_hip_event_handle(
../../drivers/hip/event_semaphore.c:                ->event));
../../drivers/hip/event_semaphore.c:      status = IREE_HIP_RESULT_TO_STATUS(semaphore->symbols, err);
../../drivers/hip/event_semaphore.c:    if (semaphore->current_visible_value < *out_value) {
../../drivers/hip/event_semaphore.c:      semaphore->current_visible_value = *out_value;
../../drivers/hip/event_semaphore.c:      iree_notification_post(&semaphore->state_notification, IREE_ALL_WAITERS);
../../drivers/hip/event_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:  *out_value = semaphore->current_visible_value;
../../drivers/hip/event_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:      iree_hal_hip_util_tree_first(&semaphore->event_queue.tree);
../../drivers/hip/event_semaphore.c:             ->event) {
../../drivers/hip/event_semaphore.c:             ->has_been_signaled) {
../../drivers/hip/event_semaphore.c:        semaphore->symbols->hipEventQuery(iree_hal_hip_event_handle(
../../drivers/hip/event_semaphore.c:                ->event));
../../drivers/hip/event_semaphore.c:      status = IREE_HIP_RESULT_TO_STATUS(semaphore->symbols, err);
../../drivers/hip/event_semaphore.c:    if (semaphore->current_visible_value < highest_value) {
../../drivers/hip/event_semaphore.c:      semaphore->current_visible_value = highest_value;
../../drivers/hip/event_semaphore.c:      iree_notification_post(&semaphore->state_notification, IREE_ALL_WAITERS);
../../drivers/hip/event_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:  if (new_value <= semaphore->current_visible_value) {
../../drivers/hip/event_semaphore.c:        semaphore->current_visible_value;
../../drivers/hip/event_semaphore.c:    iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:    semaphore->current_visible_value = new_value;
../../drivers/hip/event_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:  // Try to set our local status - we only preserve the first failure so only
../../drivers/hip/event_semaphore.c:  if (!iree_status_is_ok(semaphore->failure_status)) {
../../drivers/hip/event_semaphore.c:    // Previous sta-tus was not OK; drop our new status.
../../drivers/hip/event_semaphore.c:    iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:  semaphore->current_visible_value = IREE_HAL_SEMAPHORE_FAILURE_VALUE;
../../drivers/hip/event_semaphore.c:  semaphore->failure_status = status;
../../drivers/hip/event_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:    while (semaphore->max_value_to_be_signaled < value) {
../../drivers/hip/event_semaphore.c:          iree_notification_prepare_wait(&semaphore->state_notification);
../../drivers/hip/event_semaphore.c:      iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:          iree_notification_commit_wait(&semaphore->state_notification, wait,
../../drivers/hip/event_semaphore.c:      iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:    if (semaphore->current_visible_value >= value) {
../../drivers/hip/event_semaphore.c:      iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:      iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:      // This is the fast-path. Since we have an infinite timeout, we can
../../drivers/hip/event_semaphore.c:          &semaphore->event_queue.tree, value);
../../drivers/hip/event_semaphore.c:      iree_hal_hip_event_t* event = item->event;
../../drivers/hip/event_semaphore.c:      iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:          semaphore->symbols,
../../drivers/hip/event_semaphore.c:      iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:      // If we have a non-infinite timeout, this is the slow-path.
../../drivers/hip/event_semaphore.c:      iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:          status = iree_wait_one(&cpu_event->event, deadline_ns);
../../drivers/hip/event_semaphore.c:          iree_hal_resource_release(&cpu_event->resource);
../../drivers/hip/event_semaphore.c:      iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:    if (semaphore->current_visible_value >= IREE_HAL_SEMAPHORE_FAILURE_VALUE) {
../../drivers/hip/event_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:      iree_hal_hip_util_tree_insert(&semaphore->event_queue.tree, value, &node);
../../drivers/hip/event_semaphore.c:    item->cpu_event = NULL;
../../drivers/hip/event_semaphore.c:    item->work_item = NULL;
../../drivers/hip/event_semaphore.c:    item->type = IREE_HAL_HIP_SEMAPHORE_QUEUE_ITEM_IMPORTED;
../../drivers/hip/event_semaphore.c:    item->created_device = &semaphore->devices.devices[device_ordinal];
../../drivers/hip/event_semaphore.c:        semaphore->devices.devices[device_ordinal].device_event_pool,
../../drivers/hip/event_semaphore.c:        external_timepoint.handle.hip_event, &item->event);
../../drivers/hip/event_semaphore.c:  uint64_t current_value = semaphore->max_value_to_be_signaled;
../../drivers/hip/event_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:      iree_hal_hip_util_tree_insert(&semaphore->event_queue.tree, value, &node);
../../drivers/hip/event_semaphore.c:    item->cpu_event = NULL;
../../drivers/hip/event_semaphore.c:    item->work_item = NULL;
../../drivers/hip/event_semaphore.c:    item->type = IREE_HAL_HIP_SEMAPHORE_QUEUE_ITEM_EXPORTED;
../../drivers/hip/event_semaphore.c:    item->created_device = &semaphore->devices.devices[device_ordinal];
../../drivers/hip/event_semaphore.c:    item->is_external = true;
../../drivers/hip/event_semaphore.c:        semaphore->devices.devices[device_ordinal].device_event_pool, 1,
../../drivers/hip/event_semaphore.c:        &item->event);
../../drivers/hip/event_semaphore.c:      status = iree_hal_hip_event_export(item->event);
../../drivers/hip/event_semaphore.c:      out_external_timepoint->compatibility =
../../drivers/hip/event_semaphore.c:      out_external_timepoint->flags = requested_flags;
../../drivers/hip/event_semaphore.c:      out_external_timepoint->handle.hip_event =
../../drivers/hip/event_semaphore.c:          iree_hal_hip_event_handle(item->event);
../../drivers/hip/event_semaphore.c:      out_external_timepoint->type = IREE_HAL_EXTERNAL_TIMEPOINT_TYPE_HIP_EVENT;
../../drivers/hip/event_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:  iree_slim_mutex_lock(&data->semaphore->mutex);
../../drivers/hip/event_semaphore.c:  bool ret = data->semaphore->max_value_to_be_signaled >= data->value;
../../drivers/hip/event_semaphore.c:  iree_slim_mutex_unlock(&data->semaphore->mutex);
../../drivers/hip/event_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:           iree_hal_hip_util_tree_first(&semaphore->event_queue.tree);
../../drivers/hip/event_semaphore.c:    if (!item->is_external) {
../../drivers/hip/event_semaphore.c:  bool do_wait = value_to_wait_for > semaphore->max_value_to_be_signaled;
../../drivers/hip/event_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/hip/event_semaphore.c:        &semaphore->external_event_notification,
../../drivers/accel/accel_semaphore.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/accel/accel_semaphore.c://===----------------------------------------------------------------------===//
../../drivers/accel/accel_semaphore.c://===----------------------------------------------------------------------===//
../../drivers/accel/accel_semaphore.c:  iree_notification_initialize(&out_shared_state->notification);
../../drivers/accel/accel_semaphore.c:  iree_notification_deinitialize(&shared_state->notification);
../../drivers/accel/accel_semaphore.c://===----------------------------------------------------------------------===//
../../drivers/accel/accel_semaphore.c://===----------------------------------------------------------------------===//
../../drivers/accel/accel_semaphore.c:  // than trying to make the entire structure lock-free.
../../drivers/accel/accel_semaphore.c:                                  &semaphore->base);
../../drivers/accel/accel_semaphore.c:    semaphore->host_allocator = host_allocator;
../../drivers/accel/accel_semaphore.c:    semaphore->shared_state = shared_state;
../../drivers/accel/accel_semaphore.c:    iree_slim_mutex_initialize(&semaphore->mutex);
../../drivers/accel/accel_semaphore.c:    semaphore->current_value = initial_value;
../../drivers/accel/accel_semaphore.c:    semaphore->failure_status = iree_ok_status();
../../drivers/accel/accel_semaphore.c:    *out_semaphore = &semaphore->base;
../../drivers/accel/accel_semaphore.c:  iree_allocator_t host_allocator = semaphore->host_allocator;
../../drivers/accel/accel_semaphore.c:  iree_slim_mutex_deinitialize(&semaphore->mutex);
../../drivers/accel/accel_semaphore.c:  iree_status_ignore(semaphore->failure_status);
../../drivers/accel/accel_semaphore.c:  iree_hal_semaphore_deinitialize(&semaphore->base);
../../drivers/accel/accel_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/accel/accel_semaphore.c:  *out_value = semaphore->current_value;
../../drivers/accel/accel_semaphore.c:    status = iree_status_clone(semaphore->failure_status);
../../drivers/accel/accel_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/accel/accel_semaphore.c:  if (new_value <= semaphore->current_value) {
../../drivers/accel/accel_semaphore.c:    uint64_t current_value IREE_ATTRIBUTE_UNUSED = semaphore->current_value;
../../drivers/accel/accel_semaphore.c:  semaphore->current_value = new_value;
../../drivers/accel/accel_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/accel/accel_semaphore.c:    iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/accel/accel_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/accel/accel_semaphore.c:  iree_hal_semaphore_notify(&semaphore->base, new_value, IREE_STATUS_OK);
../../drivers/accel/accel_semaphore.c:  // TODO(#4680): make notifications per-semaphore; would make multi-wait
../../drivers/accel/accel_semaphore.c:  iree_notification_post(&semaphore->shared_state->notification,
../../drivers/accel/accel_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/accel/accel_semaphore.c:  // Try to set our local status - we only preserve the first failure so only
../../drivers/accel/accel_semaphore.c:  if (!iree_status_is_ok(semaphore->failure_status)) {
../../drivers/accel/accel_semaphore.c:    iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/accel/accel_semaphore.c:  semaphore->current_value = IREE_HAL_SEMAPHORE_FAILURE_VALUE;
../../drivers/accel/accel_semaphore.c:  semaphore->failure_status = status;
../../drivers/accel/accel_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/accel/accel_semaphore.c:  iree_hal_semaphore_notify(&semaphore->base, IREE_HAL_SEMAPHORE_FAILURE_VALUE,
../../drivers/accel/accel_semaphore.c:  iree_notification_post(&semaphore->shared_state->notification,
../../drivers/accel/accel_semaphore.c:    // Fast-path for a single semaphore.
../../drivers/accel/accel_semaphore.c:    iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/accel/accel_semaphore.c:      iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/accel/accel_semaphore.c:    iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/accel/accel_semaphore.c:  iree_notification_post(&shared_state->notification, IREE_ALL_WAITERS);
../../drivers/accel/accel_semaphore.c:  iree_hal_accel_semaphore_t* semaphore = state->semaphore;
../../drivers/accel/accel_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/accel/accel_semaphore.c:  bool is_signaled = semaphore->current_value >= state->value ||
../../drivers/accel/accel_semaphore.c:                     !iree_status_is_ok(semaphore->failure_status);
../../drivers/accel/accel_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/accel/accel_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/accel/accel_semaphore.c:  if (!iree_status_is_ok(semaphore->failure_status)) {
../../drivers/accel/accel_semaphore.c:    iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/accel/accel_semaphore.c:  } else if (semaphore->current_value >= value) {
../../drivers/accel/accel_semaphore.c:    iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/accel/accel_semaphore.c:    iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/accel/accel_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/accel/accel_semaphore.c:  iree_hal_accel_semaphore_state_t* shared_state = semaphore->shared_state;
../../drivers/accel/accel_semaphore.c:      &shared_state->notification,
../../drivers/accel/accel_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/accel/accel_semaphore.c:  if (!iree_status_is_ok(semaphore->failure_status)) {
../../drivers/accel/accel_semaphore.c:  } else if (semaphore->current_value < value) {
../../drivers/accel/accel_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/accel/accel_semaphore.c:  for (iree_host_size_t i = 0; i < semaphore_list->count; ++i) {
../../drivers/accel/accel_semaphore.c:        iree_hal_accel_semaphore_cast(semaphore_list->semaphores[i]);
../../drivers/accel/accel_semaphore.c:    iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/accel/accel_semaphore.c:        semaphore->current_value >= semaphore_list->payload_values[i] ||
../../drivers/accel/accel_semaphore.c:        !iree_status_is_ok(semaphore->failure_status);
../../drivers/accel/accel_semaphore.c:    iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/accel/accel_semaphore.c:  for (iree_host_size_t i = 0; i < semaphore_list->count; ++i) {
../../drivers/accel/accel_semaphore.c:        iree_hal_accel_semaphore_cast(semaphore_list->semaphores[i]);
../../drivers/accel/accel_semaphore.c:    iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/accel/accel_semaphore.c:        semaphore->current_value >= semaphore_list->payload_values[i] ||
../../drivers/accel/accel_semaphore.c:        !iree_status_is_ok(semaphore->failure_status);
../../drivers/accel/accel_semaphore.c:    iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/accel/accel_semaphore.c:// - IREE_STATUS_OK: any or all semaphores signaled (based on |wait_mode|).
../../drivers/accel/accel_semaphore.c:// - IREE_STATUS_ABORTED: one or more semaphores failed.
../../drivers/accel/accel_semaphore.c:// - IREE_STATUS_DEADLINE_EXCEEDED: any or all semaphores unsignaled.
../../drivers/accel/accel_semaphore.c:    iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/accel/accel_semaphore.c:    const uint64_t current_value = semaphore->current_value;
../../drivers/accel/accel_semaphore.c:        iree_status_code(semaphore->failure_status);
../../drivers/accel/accel_semaphore.c:    iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/accel/accel_semaphore.c:    // Fast-path for a single semaphore.
../../drivers/accel/accel_semaphore.c:  // Fast-path for polling; we'll never wait and can just do a quick query.
../../drivers/accel/accel_semaphore.c:      &shared_state->notification,
../../drivers/accel/accel_semaphore.c:  // We may have been successful - or may have a partial failure.
../../drivers/hip/hip_device.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/hip/hip_device.c://===----------------------------------------------------------------------===//
../../drivers/hip/hip_device.c://===----------------------------------------------------------------------===//
../../drivers/hip/hip_device.c:  // self-managed stream.
../../drivers/hip/hip_device.c:  iree_allocator_free(device_interface->host_allocator, device_interface);
../../drivers/hip/hip_device.c:  return IREE_HIP_CALL_TO_STATUS(device_interface->hip_symbols,
../../drivers/hip/hip_device.c:      device_interface->hip_symbols,
../../drivers/hip/hip_device.c:  return IREE_HIP_CALL_TO_STATUS(device_interface->hip_symbols,
../../drivers/hip/hip_device.c:      device_interface->hip_symbols,
../../drivers/hip/hip_device.c:  IREE_HIP_IGNORE_ERROR(device_interface->hip_symbols,
../../drivers/hip/hip_device.c:      device_interface->hip_symbols,
../../drivers/hip/hip_device.c:          (hipStream_t)device_interface->device_context->hip_dispatch_stream));
../../drivers/hip/hip_device.c:      device_interface->hip_symbols,
../../drivers/hip/hip_device.c:  out_params->arena_block_size = 32 * 1024;
../../drivers/hip/hip_device.c:  out_params->event_pool_capacity = 32;
../../drivers/hip/hip_device.c:  out_params->queue_count = 1;
../../drivers/hip/hip_device.c:  out_params->command_buffer_mode = IREE_HAL_HIP_COMMAND_BUFFER_MODE_STREAM;
../../drivers/hip/hip_device.c:  out_params->stream_tracing = 0;
../../drivers/hip/hip_device.c:  out_params->async_allocations = true;
../../drivers/hip/hip_device.c:  out_params->file_transfer_buffer_size =
../../drivers/hip/hip_device.c:  out_params->file_transfer_chunk_size =
../../drivers/hip/hip_device.c:  out_params->allow_inline_execution = false;
../../drivers/hip/hip_device.c:  out_params->async_caching = true;
../../drivers/hip/hip_device.c:  out_params->external_stream = IREE_HAL_DEVICE_INVALID_EXTERNAL_STREAM;
../../drivers/hip/hip_device.c:  if (params->arena_block_size < 4096) {
../../drivers/hip/hip_device.c:  if (params->queue_count == 0) {
../../drivers/hip/hip_device.c:  if (params->external_stream != IREE_HAL_DEVICE_INVALID_EXTERNAL_STREAM) {
../../drivers/hip/hip_device.c:  iree_hal_hip_device_topology_t topology = {.count = device->device_count,
../../drivers/hip/hip_device.c:                                             .devices = device->devices};
../../drivers/hip/hip_device.c:  if (device->params.stream_tracing) {
../../drivers/hip/hip_device.c:    if (device->params.stream_tracing >=
../../drivers/hip/hip_device.c:        device->params.stream_tracing < IREE_HAL_STREAM_TRACING_VERBOSITY_OFF) {
../../drivers/hip/hip_device.c:      sizeof(iree_hal_hip_per_device_info_t) * device->device_count;
../../drivers/hip/hip_device.c:  iree_hal_resource_initialize(&iree_hal_hip_device_vtable, &device->resource);
../../drivers/hip/hip_device.c:  iree_string_view_append_to_buffer(identifier, &device->identifier,
../../drivers/hip/hip_device.c:  iree_arena_block_pool_initialize(params->arena_block_size, host_allocator,
../../drivers/hip/hip_device.c:                                   &device->block_pool);
../../drivers/hip/hip_device.c:  device->driver = driver;
../../drivers/hip/hip_device.c:  iree_hal_driver_retain(device->driver);
../../drivers/hip/hip_device.c:  device->hip_symbols = symbols;
../../drivers/hip/hip_device.c:  device->nccl_symbols = nccl_symbols;
../../drivers/hip/hip_device.c:  device->params = *params;
../../drivers/hip/hip_device.c:  device->host_allocator = host_allocator;
../../drivers/hip/hip_device.c:  // Enable tracing for each of the streams - no-op if disabled.
../../drivers/hip/hip_device.c:  if (device->params.stream_tracing) {
../../drivers/hip/hip_device.c:    for (iree_host_size_t i = 0; i < device->device_count; ++i) {
../../drivers/hip/hip_device.c:      tracing_device_interface->base.vtable =
../../drivers/hip/hip_device.c:      tracing_device_interface->device_context = &device->devices[i];
../../drivers/hip/hip_device.c:      tracing_device_interface->host_allocator = host_allocator;
../../drivers/hip/hip_device.c:      tracing_device_interface->hip_symbols = symbols;
../../drivers/hip/hip_device.c:          symbols, hipCtxPushCurrent(device->devices[i].hip_context));
../../drivers/hip/hip_device.c:          device->identifier, device->params.stream_tracing,
../../drivers/hip/hip_device.c:          &device->block_pool, host_allocator,
../../drivers/hip/hip_device.c:          &device->devices[i].tracing_context);
../../drivers/hip/hip_device.c:  if (iree_status_is_ok(status) && params->async_allocations) {
../../drivers/hip/hip_device.c:    device->supports_memory_pools = true;
../../drivers/hip/hip_device.c:    for (iree_host_size_t i = 0; i < device->device_count; ++i) {
../../drivers/hip/hip_device.c:                                device->devices[i].hip_device),
../../drivers/hip/hip_device.c:      device->supports_memory_pools &= (supports_memory_pools != 0);
../../drivers/hip/hip_device.c:  if (iree_status_is_ok(status) && device->supports_memory_pools) {
../../drivers/hip/hip_device.c:    for (iree_host_size_t i = 0; i < device->device_count; ++i) {
../../drivers/hip/hip_device.c:      device->supports_memory_pools = false;
../../drivers/hip/hip_device.c:          (iree_hal_device_t*)device, symbols, device->devices[i].hip_device,
../../drivers/hip/hip_device.c:          &params->memory_pools, host_allocator,
../../drivers/hip/hip_device.c:          &device->devices[i].memory_pools);
../../drivers/hip/hip_device.c:      iree_hal_hip_device_make_topology(device), device->supports_memory_pools,
../../drivers/hip/hip_device.c:      host_allocator, &device->device_allocator);
../../drivers/hip/hip_device.c:                                                    &device->cleanup_thread);
../../drivers/hip/hip_device.c:        symbols, host_allocator, &device->buffer_free_thread);
../../drivers/hip/hip_device.c:    for (iree_host_size_t i = 0; i < device->device_count; ++i) {
../../drivers/hip/hip_device.c:          host_allocator, &device->devices[i].dispatch_thread);
../../drivers/hip/hip_device.c:    for (iree_host_size_t i = 0; i < device->device_count; ++i) {
../../drivers/hip/hip_device.c:          device->device_allocator, buffer_params,
../../drivers/hip/hip_device.c:          params->file_transfer_buffer_size,
../../drivers/hip/hip_device.c:          &device->devices[i].file_transfer_staging_buffer.buffer);
../../drivers/hip/hip_device.c:      device->devices[i].file_transfer_staging_buffer.head = 0;
../../drivers/hip/hip_device.c:      device->devices[i].file_transfer_staging_buffer.tail = 0;
../../drivers/hip/hip_device.c:          &device->devices[i].file_transfer_staging_buffer.mutex);
../../drivers/hip/hip_device.c:          &device->devices[i].file_transfer_staging_buffer.notify);
../../drivers/hip/hip_device.c:        symbols->hipDeviceCanAccessPeer(&canAccessPeer, device_id, j);
../../drivers/hip/hip_device.c:    hip_error = symbols->hipDeviceEnablePeerAccess(j, 0);
../../drivers/hip/hip_device.c:      sizeof(*device) + sizeof(device->devices[0]) * device_count +
../../drivers/hip/hip_device.c:  device->device_count = device_count;
../../drivers/hip/hip_device.c:  device->uses_external_stream =
../../drivers/hip/hip_device.c:      params->external_stream != IREE_HAL_DEVICE_INVALID_EXTERNAL_STREAM;
../../drivers/hip/hip_device.c:    device->devices[i].hip_device = device_id;
../../drivers/hip/hip_device.c:        hipDevicePrimaryCtxRetain(&device->devices[i].hip_context, devices[i]));
../../drivers/hip/hip_device.c:          symbols, hipCtxSetCurrent(device->devices[i].hip_context));
../../drivers/hip/hip_device.c:      if (device->uses_external_stream) {
../../drivers/hip/hip_device.c:        device->devices[i].hip_dispatch_stream =
../../drivers/hip/hip_device.c:            (hipStream_t)(params->external_stream);
../../drivers/hip/hip_device.c:            hipStreamCreateWithFlags(&device->devices[i].hip_dispatch_stream,
../../drivers/hip/hip_device.c:          hipStreamCreateWithFlags(&device->devices[i].hip_async_memory_stream,
../../drivers/hip/hip_device.c:    status = iree_event_pool_allocate(params->event_pool_capacity,
../../drivers/hip/hip_device.c:        symbols, params->event_pool_capacity, host_allocator,
../../drivers/hip/hip_device.c:        device->devices[i].hip_context, &device->devices[i].device_event_pool);
../../drivers/hip/hip_device.c:    device->host_event_pool = host_event_pool;
../../drivers/hip/hip_device.c:  return device->hip_symbols;
../../drivers/hip/hip_device.c:  const iree_hal_hip_dynamic_symbols_t* symbols = device->hip_symbols;
../../drivers/hip/hip_device.c:  for (iree_host_size_t i = 0; i < device->device_count; ++i) {
../../drivers/hip/hip_device.c:        device->devices[i].dispatch_thread);
../../drivers/hip/hip_device.c:  iree_hal_hip_cleanup_thread_deinitialize(device->cleanup_thread);
../../drivers/hip/hip_device.c:  iree_hal_hip_cleanup_thread_deinitialize(device->buffer_free_thread);
../../drivers/hip/hip_device.c:  device->cleanup_thread = NULL;
../../drivers/hip/hip_device.c:  device->buffer_free_thread = NULL;
../../drivers/hip/hip_device.c:  for (iree_host_size_t i = 0; i < device->device_count; ++i) {
../../drivers/hip/hip_device.c:        device->devices[i].file_transfer_staging_buffer.buffer);
../../drivers/hip/hip_device.c:        &device->devices[i].file_transfer_staging_buffer.mutex);
../../drivers/hip/hip_device.c:        &device->devices[i].file_transfer_staging_buffer.notify);
../../drivers/hip/hip_device.c:  iree_hal_allocator_release(device->device_allocator);
../../drivers/hip/hip_device.c:  iree_hal_channel_provider_release(device->channel_provider);
../../drivers/hip/hip_device.c:  for (iree_host_size_t i = 0; i < device->device_count; ++i) {
../../drivers/hip/hip_device.c:    iree_hal_hip_memory_pools_deinitialize(&device->devices[i].memory_pools);
../../drivers/hip/hip_device.c:    iree_hal_stream_tracing_context_free(device->devices[i].tracing_context);
../../drivers/hip/hip_device.c:  for (iree_host_size_t i = 0; i < device->device_count; ++i) {
../../drivers/hip/hip_device.c:    iree_hal_hip_event_pool_release(device->devices[i].device_event_pool);
../../drivers/hip/hip_device.c:  if (device->host_event_pool) iree_event_pool_free(device->host_event_pool);
../../drivers/hip/hip_device.c:  for (iree_host_size_t i = 0; i < device->device_count; ++i) {
../../drivers/hip/hip_device.c:    if (!device->uses_external_stream) {
../../drivers/hip/hip_device.c:          symbols, hipStreamDestroy(device->devices[i].hip_dispatch_stream));
../../drivers/hip/hip_device.c:        symbols, hipStreamDestroy(device->devices[i].hip_async_memory_stream));
../../drivers/hip/hip_device.c:        symbols, hipDevicePrimaryCtxRelease(device->devices[i].hip_device));
../../drivers/hip/hip_device.c:  iree_arena_block_pool_deinitialize(&device->block_pool);
../../drivers/hip/hip_device.c:  iree_hal_driver_release(device->driver);
../../drivers/hip/hip_device.c:  return device->identifier;
../../drivers/hip/hip_device.c:  return device->host_allocator;
../../drivers/hip/hip_device.c:  return device->device_allocator;
../../drivers/hip/hip_device.c:  iree_hal_allocator_release(device->device_allocator);
../../drivers/hip/hip_device.c:  device->device_allocator = new_allocator;
../../drivers/hip/hip_device.c:  iree_hal_channel_provider_release(device->channel_provider);
../../drivers/hip/hip_device.c:  device->channel_provider = new_provider;
../../drivers/hip/hip_device.c:  iree_arena_block_pool_trim(&device->block_pool);
../../drivers/hip/hip_device.c:  IREE_RETURN_IF_ERROR(iree_hal_allocator_trim(device->device_allocator));
../../drivers/hip/hip_device.c:  if (device->supports_memory_pools) {
../../drivers/hip/hip_device.c:    for (iree_host_size_t i = 0; i < device->device_count; ++i) {
../../drivers/hip/hip_device.c:          &device->devices[i].memory_pools, &device->params.memory_pools));
../../drivers/hip/hip_device.c:      device->hip_symbols,
../../drivers/hip/hip_device.c:      hipDeviceGetAttribute(&value, attribute, device->devices[0].hip_device),
../../drivers/hip/hip_device.c:        iree_string_view_match_pattern(device->identifier, key) ? 1 : 0;
../../drivers/hip/hip_device.c:    *out_value = iree_string_view_equal(key, IREE_SV("rocm-hsaco-fb")) ? 1 : 0;
../../drivers/hip/hip_device.c:      *out_value = device->device_count;
../../drivers/hip/hip_device.c:  if (!device->nccl_symbols || !device->nccl_symbols->dylib) {
../../drivers/hip/hip_device.c:  if (device->channel_provider &&
../../drivers/hip/hip_device.c:            device->channel_provider, &params.rank, &params.count),
../../drivers/hip/hip_device.c:    if (!device->channel_provider) {
../../drivers/hip/hip_device.c:          iree_hal_hip_nccl_get_unique_id(device->nccl_symbols, &id),
../../drivers/hip/hip_device.c:                             device->channel_provider,
../../drivers/hip/hip_device.c:    // User provided the ID - we treat it as opaque here and let NCCL validate.
../../drivers/hip/hip_device.c:      device->hip_symbols, device->nccl_symbols, &id, params.rank, params.count,
../../drivers/hip/hip_device.c:      device->host_allocator, out_channel);
../../drivers/hip/hip_device.c:      queue_affinity & ~(IREE_HAL_QUEUE_AFFINITY_ANY << device->device_count);
../../drivers/hip/hip_device.c:        device->hip_symbols,
../../drivers/hip/hip_device.c:        hipCtxPushCurrent(device->devices[device_ordinal].hip_context));
../../drivers/hip/hip_device.c:            iree_hal_device_allocator(base_device), device->hip_symbols,
../../drivers/hip/hip_device.c:            device->nccl_symbols,
../../drivers/hip/hip_device.c:            device->devices[device_ordinal].tracing_context, mode,
../../drivers/hip/hip_device.c:            device->devices[device_ordinal].hip_dispatch_stream,
../../drivers/hip/hip_device.c:            &device->block_pool, device->host_allocator,
../../drivers/hip/hip_device.c:            iree_hal_device_allocator(base_device), device->hip_symbols,
../../drivers/hip/hip_device.c:            device->devices[device_ordinal].tracing_context,
../../drivers/hip/hip_device.c:            device->devices[device_ordinal].hip_context, mode,
../../drivers/hip/hip_device.c:            binding_capacity, &device->block_pool, device->host_allocator,
../../drivers/hip/hip_device.c:        IREE_HIP_CALL_TO_STATUS(device->hip_symbols, hipCtxPopCurrent(NULL)));
../../drivers/hip/hip_device.c:        command_buffer_ordinal, &buffers[0], device->device_allocator, mode,
../../drivers/hip/hip_device.c:        command_categories, queue_affinity, device->hip_symbols,
../../drivers/hip/hip_device.c:        device->host_allocator, out_command_buffer);
../../drivers/hip/hip_device.c:  if (device->params.allow_inline_execution &&
../../drivers/hip/hip_device.c:  switch (device->params.command_buffer_mode) {
../../drivers/hip/hip_device.c:      // TODO(indirect-cmd): when we can record indirect graphs we won't need
../../drivers/hip/hip_device.c:      // to use deferred command buffers - this is here to emulate indirect
../../drivers/hip/hip_device.c:            queue_affinity, binding_capacity, &device->block_pool,
../../drivers/hip/hip_device.c:          queue_affinity, binding_capacity, &device->block_pool,
../../drivers/hip/hip_device.c:  for (iree_host_size_t i = 0; i < device->device_count; ++i) {
../../drivers/hip/hip_device.c:    devices[i] = device->devices[i].hip_device;
../../drivers/hip/hip_device.c:    contexts[i] = device->devices[i].hip_context;
../../drivers/hip/hip_device.c:      identifier, device->hip_symbols,
../../drivers/hip/hip_device.c:      iree_hal_hip_device_make_topology(device), device->host_allocator,
../../drivers/hip/hip_device.c:      initial_value, device->hip_symbols, device->host_allocator,
../../drivers/hip/hip_device.c:    if (device->params.async_caching) {
../../drivers/hip/hip_device.c:      iree_hal_hip_allocator_free_async(device->device_allocator, buffer);
../../drivers/hip/hip_device.c:      iree_hal_hip_allocator_free_sync(device->device_allocator, buffer);
../../drivers/hip/hip_device.c:      /*device_ptr=*/NULL, /*host_ptr=*/NULL, callback, device->host_allocator,
../../drivers/hip/hip_device.c:  iree_slim_mutex_deinitialize(&data->completed_mutex);
../../drivers/hip/hip_device.c:  iree_notification_deinitialize(&data->notification);
../../drivers/hip/hip_device.c:  iree_slim_mutex_initialize(&(*out)->completed_mutex);
../../drivers/hip/hip_device.c:  iree_notification_initialize(&(*out)->notification);
../../drivers/hip/hip_device.c:                               &(*out)->resource);
../../drivers/hip/hip_device.c:  iree_slim_mutex_lock(&data->completed_mutex);
../../drivers/hip/hip_device.c:  bool ret = data->completed;
../../drivers/hip/hip_device.c:  iree_slim_mutex_unlock(&data->completed_mutex);
../../drivers/hip/hip_device.c:  iree_slim_mutex_lock(&data->completed_mutex);
../../drivers/hip/hip_device.c:  data->completed = true;
../../drivers/hip/hip_device.c:  iree_slim_mutex_unlock(&data->completed_mutex);
../../drivers/hip/hip_device.c:  iree_notification_post(&data->notification, IREE_ALL_WAITERS);
../../drivers/hip/hip_device.c:      &data->notification,
../../drivers/hip/hip_device.c:  if (device->uses_external_stream) {
../../drivers/hip/hip_device.c:        host_allocator, &data->external_stream_dispatch_data));
../../drivers/hip/hip_device.c:  data->host_allocator = host_allocator;
../../drivers/hip/hip_device.c:  iree_atomic_store(&data->wait_semaphore_count, wait_semaphore_list.count,
../../drivers/hip/hip_device.c:  data->device = device;
../../drivers/hip/hip_device.c:  data->queue_affinity = queue_affinity;
../../drivers/hip/hip_device.c:  data->dispatch_fn = dispatch_fn;
../../drivers/hip/hip_device.c:  data->wait_semaphore_list.count = wait_semaphore_list.count;
../../drivers/hip/hip_device.c:  data->wait_semaphore_list.semaphores = (iree_hal_semaphore_t**)callback_ptr;
../../drivers/hip/hip_device.c:  memcpy(data->wait_semaphore_list.semaphores, wait_semaphore_list.semaphores,
../../drivers/hip/hip_device.c:  data->wait_semaphore_list.payload_values =
../../drivers/hip/hip_device.c:      data->wait_semaphore_list.payload_values,
../../drivers/hip/hip_device.c:  data->signal_semaphore_list.count = signal_semaphore_list.count;
../../drivers/hip/hip_device.c:  data->signal_semaphore_list.semaphores = (iree_hal_semaphore_t**)callback_ptr;
../../drivers/hip/hip_device.c:      data->signal_semaphore_list.semaphores, signal_semaphore_list.semaphores,
../../drivers/hip/hip_device.c:  data->signal_semaphore_list.payload_values =
../../drivers/hip/hip_device.c:  memcpy(data->signal_semaphore_list.payload_values,
../../drivers/hip/hip_device.c:  iree_slim_mutex_initialize(&data->status_mutex);
../../drivers/hip/hip_device.c:  data->status = iree_ok_status();
../../drivers/hip/hip_device.c:  iree_slim_mutex_deinitialize(&data->status_mutex);
../../drivers/hip/hip_device.c:  if (data->device->uses_external_stream) {
../../drivers/hip/hip_device.c:    iree_hal_resource_release(data->external_stream_dispatch_data);
../../drivers/hip/hip_device.c:  for (iree_host_size_t i = 0; i < data->wait_semaphore_list.count; ++i) {
../../drivers/hip/hip_device.c:    iree_hal_resource_release(data->wait_semaphore_list.semaphores[i]);
../../drivers/hip/hip_device.c:  for (iree_host_size_t i = 0; i < data->signal_semaphore_list.count; ++i) {
../../drivers/hip/hip_device.c:    iree_hal_resource_release(data->signal_semaphore_list.semaphores[i]);
../../drivers/hip/hip_device.c:      device->devices[device_ordinal].device_event_pool, 1, &event);
../../drivers/hip/hip_device.c:        device->hip_symbols,
../../drivers/hip/hip_device.c:                       device->devices[device_ordinal].hip_dispatch_stream));
../../drivers/hip/hip_device.c:  if (device->cleanup_thread) {
../../drivers/hip/hip_device.c:    return iree_hal_hip_cleanup_thread_add_cleanup(device->cleanup_thread, NULL,
../../drivers/hip/hip_device.c:        &device->devices[device_ordinal], stream,
../../drivers/hip/hip_device.c:        device->devices[device_ordinal].device_event_pool);
../../drivers/hip/hip_device.c:  callback_data->buffer = buffer;
../../drivers/hip/hip_device.c:  callback_data->device = device;
../../drivers/hip/hip_device.c:  callback_data->queue_affinity = queue_affinity;
../../drivers/hip/hip_device.c:  callback_data->host_allocator = host_allocator;
../../drivers/hip/hip_device.c:        device->hip_symbols,
../../drivers/hip/hip_device.c:    iree_slim_mutex_lock(&data->status_mutex);
../../drivers/hip/hip_device.c:    data->status = iree_status_join(data->status, status);
../../drivers/hip/hip_device.c:    iree_slim_mutex_unlock(&data->status_mutex);
../../drivers/hip/hip_device.c:  if (iree_atomic_fetch_sub(&data->wait_semaphore_count, 1,
../../drivers/hip/hip_device.c:  int device_ordinal = iree_math_count_trailing_zeros_u64(data->queue_affinity);
../../drivers/hip/hip_device.c:      data->device->devices[device_ordinal].dispatch_thread, data->dispatch_fn,
../../drivers/hip/hip_device.c:  iree_hal_buffer_release(data->buffer);
../../drivers/hip/hip_device.c:  iree_hal_hip_semaphore_callback_data_deinitialize(&data->base);
../../drivers/hip/hip_device.c:  iree_allocator_free(data->base.host_allocator, data);
../../drivers/hip/hip_device.c:  for (iree_host_size_t i = 0; i < data->base.signal_semaphore_list.count;
../../drivers/hip/hip_device.c:        data->base.signal_semaphore_list.semaphores[i]));
../../drivers/hip/hip_device.c:  if (data->buffer &&
../../drivers/hip/hip_device.c:      data->type == IREE_HAL_HIP_DEVICE_SEMAPHORE_OPERATION_ASYNC_DEALLOC) {
../../drivers/hip/hip_device.c:        iree_math_count_trailing_zeros_u64(data->base.queue_affinity);
../../drivers/hip/hip_device.c:    if (data->base.device->supports_memory_pools) {
../../drivers/hip/hip_device.c:              &data->base.device->devices[device_ordinal].memory_pools,
../../drivers/hip/hip_device.c:              data->base.device->devices[device_ordinal].hip_dispatch_stream,
../../drivers/hip/hip_device.c:              data->buffer));
../../drivers/hip/hip_device.c:    } else if (!data->base.device->params.async_caching) {
../../drivers/hip/hip_device.c:              iree_hal_device_allocator((iree_hal_device_t*)data->base.device),
../../drivers/hip/hip_device.c:              data->buffer));
../../drivers/hip/hip_device.c:  IREE_ASSERT_LE(data->type, IREE_HAL_HIP_DEVICE_SEMAPHORE_OPERATION_MAX);
../../drivers/hip/hip_device.c:  iree_hal_hip_device_t* device = data->base.device;
../../drivers/hip/hip_device.c:  if (!iree_status_is_ok(data->base.status)) {
../../drivers/hip/hip_device.c:    status = iree_status_join(data->base.status, status);
../../drivers/hip/hip_device.c:      iree_math_count_trailing_zeros_u64(data->base.queue_affinity);
../../drivers/hip/hip_device.c:        device->hip_symbols,
../../drivers/hip/hip_device.c:        hipCtxPushCurrent(device->devices[device_ordinal].hip_context));
../../drivers/hip/hip_device.c:      data->type == IREE_HAL_HIP_DEVICE_SEMAPHORE_OPERATION_ASYNC_ALLOC
../../drivers/hip/hip_device.c:          ? device->devices[device_ordinal].hip_async_memory_stream
../../drivers/hip/hip_device.c:          : device->devices[device_ordinal].hip_dispatch_stream;
../../drivers/hip/hip_device.c:        device, stream, data->base.wait_semaphore_list, device_ordinal);
../../drivers/hip/hip_device.c:    switch (data->type) {
../../drivers/hip/hip_device.c:        if (device->supports_memory_pools) {
../../drivers/hip/hip_device.c:              &device->devices[device_ordinal].memory_pools, data->buffer,
../../drivers/hip/hip_device.c:              stream, iree_hal_buffer_allocation_size(data->buffer));
../../drivers/hip/hip_device.c:            data->buffer);
../../drivers/hip/hip_device.c:        if (!data->base.device->supports_memory_pools && data->buffer &&
../../drivers/hip/hip_device.c:            data->base.device->params.async_caching) {
../../drivers/hip/hip_device.c:                              (iree_hal_device_t*)data->base.device),
../../drivers/hip/hip_device.c:                          data->buffer));
../../drivers/hip/hip_device.c:  if (device->uses_external_stream) {
../../drivers/hip/hip_device.c:        data->base.external_stream_dispatch_data);
../../drivers/hip/hip_device.c:  const iree_hal_hip_dynamic_symbols_t* symbols = device->hip_symbols;
../../drivers/hip/hip_device.c:        device, stream, device->cleanup_thread,
../../drivers/hip/hip_device.c:        data->base.signal_semaphore_list, device_ordinal,
../../drivers/hip/hip_device.c:    for (iree_host_size_t i = 0; i < data->base.signal_semaphore_list.count;
../../drivers/hip/hip_device.c:      iree_hal_semaphore_fail(data->base.signal_semaphore_list.semaphores[i],
../../drivers/hip/hip_device.c:      &callback_data->base);
../../drivers/hip/hip_device.c:    callback_data->buffer = buffer;
../../drivers/hip/hip_device.c:    callback_data->type = type;
../../drivers/hip/hip_device.c:      ((iree_hal_queue_affinity_t)1 << device->device_count);
../../drivers/hip/hip_device.c:  queue_affinity_mask = queue_affinity_mask | (queue_affinity_mask - 1);
../../drivers/hip/hip_device.c:      (device->supports_memory_pools ||
../../drivers/hip/hip_device.c:          device, device->host_allocator, queue_affinity, wait_semaphore_list,
../../drivers/hip/hip_device.c:      if (device->uses_external_stream) {
../../drivers/hip/hip_device.c:            callback_data->base.external_stream_dispatch_data;
../../drivers/hip/hip_device.c:          device->devices[device_ordinal].dispatch_thread,
../../drivers/hip/hip_device.c:                device->devices[device_ordinal].device_event_pool,
../../drivers/hip/hip_device.c:        iree_hal_resource_release(&buffer->resource);
../../drivers/hip/hip_device.c:    if (device->uses_external_stream) {
../../drivers/hip/hip_device.c:  // Only signal if not returning a synchronous error - synchronous failure
../../drivers/hip/hip_device.c:      ((iree_hal_queue_affinity_t)1 << device->device_count);
../../drivers/hip/hip_device.c:  queue_affinity_mask = queue_affinity_mask | (queue_affinity_mask - 1);
../../drivers/hip/hip_device.c:  if (device_ordinal > device->device_count) {
../../drivers/hip/hip_device.c:        device->device_count);
../../drivers/hip/hip_device.c:        device, device->host_allocator, queue_affinity, wait_semaphore_list,
../../drivers/hip/hip_device.c:    if (device->uses_external_stream) {
../../drivers/hip/hip_device.c:      external_stream_data = callback_data->base.external_stream_dispatch_data;
../../drivers/hip/hip_device.c:          device->devices[device_ordinal].dispatch_thread,
../../drivers/hip/hip_device.c:                device->devices[device_ordinal].device_event_pool,
../../drivers/hip/hip_device.c:    if (device->uses_external_stream) {
../../drivers/hip/hip_device.c:  if (device->supports_memory_pools) {
../../drivers/hip/hip_device.c:        &device->devices[device_ordinal].memory_pools,
../../drivers/hip/hip_device.c:        device->devices[device_ordinal].hip_dispatch_stream, buffer);
../../drivers/hip/hip_device.c:  // Only signal if not returning a synchronous error - synchronous failure
../../drivers/hip/hip_device.c:  iree_hal_file_release(data->source_file);
../../drivers/hip/hip_device.c:  iree_hal_resource_release(data->target_buffer);
../../drivers/hip/hip_device.c:  iree_hal_hip_semaphore_callback_data_deinitialize(&data->base);
../../drivers/hip/hip_device.c:  iree_allocator_free(data->base.host_allocator, data);
../../drivers/hip/hip_device.c:      iree_math_count_trailing_zeros_u64(data->base.queue_affinity);
../../drivers/hip/hip_device.c:  iree_slim_mutex_lock(&data->base.device->devices[device_ordinal]
../../drivers/hip/hip_device.c:  data->base.device->devices[device_ordinal]
../../drivers/hip/hip_device.c:      data->read_chunk_sizes[data->read_chunks_completed];
../../drivers/hip/hip_device.c:  data->base.device->devices[device_ordinal]
../../drivers/hip/hip_device.c:      data->base.device->params.file_transfer_buffer_size;
../../drivers/hip/hip_device.c:  if (data->base.device->devices[device_ordinal]
../../drivers/hip/hip_device.c:      data->base.device->devices[device_ordinal]
../../drivers/hip/hip_device.c:    data->base.device->devices[device_ordinal]
../../drivers/hip/hip_device.c:    data->base.device->devices[device_ordinal]
../../drivers/hip/hip_device.c:  iree_slim_mutex_unlock(&data->base.device->devices[device_ordinal]
../../drivers/hip/hip_device.c:  iree_notification_post(&data->base.device->devices[device_ordinal]
../../drivers/hip/hip_device.c:      data->command_buffers[data->read_chunks_completed];
../../drivers/hip/hip_device.c:        command_buffer, data->base.queue_affinity, &command_buffer);
../../drivers/hip/hip_device.c:          data->base.device->devices[device_ordinal].tracing_context,
../../drivers/hip/hip_device.c:  iree_hal_resource_release(data->command_buffers[data->read_chunks_completed]);
../../drivers/hip/hip_device.c:  if (++data->read_chunks_completed != data->num_read_chunks) {
../../drivers/hip/hip_device.c:  for (iree_host_size_t i = 0; i < data->base.signal_semaphore_list.count;
../../drivers/hip/hip_device.c:        data->base.signal_semaphore_list.semaphores[i]));
../../drivers/hip/hip_device.c:  iree_slim_mutex_lock(&info->file_transfer_staging_buffer.mutex);
../../drivers/hip/hip_device.c:      info->file_transfer_staging_buffer.head >=
../../drivers/hip/hip_device.c:              info->file_transfer_staging_buffer.tail
../../drivers/hip/hip_device.c:          ? device->params.file_transfer_buffer_size -
../../drivers/hip/hip_device.c:                (info->file_transfer_staging_buffer.head -
../../drivers/hip/hip_device.c:                 info->file_transfer_staging_buffer.tail)
../../drivers/hip/hip_device.c:          : info->file_transfer_staging_buffer.tail -
../../drivers/hip/hip_device.c:                info->file_transfer_staging_buffer.head;
../../drivers/hip/hip_device.c:  iree_slim_mutex_unlock(&info->file_transfer_staging_buffer.mutex);
../../drivers/hip/hip_device.c:             data->device, &data->device->devices[data->device_ordinal]) >=
../../drivers/hip/hip_device.c:         data->num_bytes;
../../drivers/hip/hip_device.c:  IREE_ASSERT(size <= device->params.file_transfer_chunk_size,
../../drivers/hip/hip_device.c:      &device->devices[device_ordinal].file_transfer_staging_buffer.notify,
../../drivers/hip/hip_device.c:  iree_hal_hip_per_device_info_t* info = &device->devices[device_ordinal];
../../drivers/hip/hip_device.c:  iree_slim_mutex_lock(&info->file_transfer_staging_buffer.mutex);
../../drivers/hip/hip_device.c:  out_chunks[0].offset = info->file_transfer_staging_buffer.head;
../../drivers/hip/hip_device.c:      iree_min(size, device->params.file_transfer_buffer_size -
../../drivers/hip/hip_device.c:                         info->file_transfer_staging_buffer.head);
../../drivers/hip/hip_device.c:  if (size != out_chunks->size) {
../../drivers/hip/hip_device.c:    out_chunks[1].size = size - out_chunks[0].size;
../../drivers/hip/hip_device.c:    info->file_transfer_staging_buffer.head = out_chunks[1].size;
../../drivers/hip/hip_device.c:    info->file_transfer_staging_buffer.head += size;
../../drivers/hip/hip_device.c:  info->file_transfer_staging_buffer.head %=
../../drivers/hip/hip_device.c:      device->params.file_transfer_buffer_size;
../../drivers/hip/hip_device.c:  iree_slim_mutex_unlock(&info->file_transfer_staging_buffer.mutex);
../../drivers/hip/hip_device.c:  iree_hal_hip_device_t* device = data->base.device;
../../drivers/hip/hip_device.c:  if (!iree_status_is_ok(data->base.status)) {
../../drivers/hip/hip_device.c:    status = iree_status_join(data->base.status, status);
../../drivers/hip/hip_device.c:      iree_math_count_trailing_zeros_u64(data->base.queue_affinity);
../../drivers/hip/hip_device.c:        device->hip_symbols,
../../drivers/hip/hip_device.c:        hipCtxPushCurrent(device->devices[device_ordinal].hip_context));
../../drivers/hip/hip_device.c:        device, device->devices[device_ordinal].hip_dispatch_stream,
../../drivers/hip/hip_device.c:        data->base.wait_semaphore_list, device_ordinal);
../../drivers/hip/hip_device.c:  const iree_hal_hip_dynamic_symbols_t* symbols = device->hip_symbols;
../../drivers/hip/hip_device.c:  iree_device_size_t amount_left = data->length;
../../drivers/hip/hip_device.c:       i < data->num_read_chunks && iree_status_is_ok(status); ++i) {
../../drivers/hip/hip_device.c:        iree_min(device->params.file_transfer_chunk_size, amount_left);
../../drivers/hip/hip_device.c:            data->source_file, data->source_offset + read_offset,
../../drivers/hip/hip_device.c:            device->devices[device_ordinal].file_transfer_staging_buffer.buffer,
../../drivers/hip/hip_device.c:    // because hip stream command buffers are executed at record-time, so we
../../drivers/hip/hip_device.c:          IREE_HAL_COMMAND_CATEGORY_TRANSFER, data->base.queue_affinity, 0,
../../drivers/hip/hip_device.c:            device->devices[device_ordinal].file_transfer_staging_buffer.buffer;
../../drivers/hip/hip_device.c:        dst.buffer = data->target_buffer;
../../drivers/hip/hip_device.c:        dst.offset = data->target_offset + offset;
../../drivers/hip/hip_device.c:      amount_left -= chunks[j].size;
../../drivers/hip/hip_device.c:      data->command_buffers[i] = stream_command_buffer;
../../drivers/hip/hip_device.c:      data->read_chunk_sizes[i] = chunk_size;
../../drivers/hip/hip_device.c:      if (i == data->num_read_chunks - 1) {
../../drivers/hip/hip_device.c:            device, device->devices[device_ordinal].hip_dispatch_stream,
../../drivers/hip/hip_device.c:            device->cleanup_thread, data->base.signal_semaphore_list,
../../drivers/hip/hip_device.c:            device, device->cleanup_thread, device_ordinal,
../../drivers/hip/hip_device.c:  if (device->uses_external_stream) {
../../drivers/hip/hip_device.c:        data->base.external_stream_dispatch_data);
../../drivers/hip/hip_device.c:    for (iree_host_size_t i = 0; i < data->base.signal_semaphore_list.count;
../../drivers/hip/hip_device.c:      iree_hal_semaphore_fail(data->base.signal_semaphore_list.semaphores[i],
../../drivers/hip/hip_device.c:      (length + device->params.file_transfer_chunk_size - 1) /
../../drivers/hip/hip_device.c:      device->params.file_transfer_chunk_size;
../../drivers/hip/hip_device.c:      sizeof(*callback_data->read_chunk_sizes) * chunk_count +
../../drivers/hip/hip_device.c:      sizeof(*callback_data->command_buffers) * chunk_count;
../../drivers/hip/hip_device.c:      &callback_data->base);
../../drivers/hip/hip_device.c:                                      sizeof(*callback_data->read_chunk_sizes) *
../../drivers/hip/hip_device.c:    callback_data->source_file = source_file;
../../drivers/hip/hip_device.c:    callback_data->source_offset = source_offset;
../../drivers/hip/hip_device.c:    callback_data->target_buffer = target_buffer;
../../drivers/hip/hip_device.c:    callback_data->target_offset = target_offset;
../../drivers/hip/hip_device.c:    callback_data->length = length;
../../drivers/hip/hip_device.c:    callback_data->flags = flags;
../../drivers/hip/hip_device.c:    callback_data->read_chunks_completed = 0;
../../drivers/hip/hip_device.c:    callback_data->num_read_chunks = chunk_count;
../../drivers/hip/hip_device.c:    callback_data->read_chunk_sizes = chunk_base;
../../drivers/hip/hip_device.c:    callback_data->command_buffers = command_buffer_base;
../../drivers/hip/hip_device.c:      device, device->host_allocator, queue_affinity, wait_semaphore_list,
../../drivers/hip/hip_device.c:  if (device->uses_external_stream) {
../../drivers/hip/hip_device.c:    external_stream_data = callback_data->base.external_stream_dispatch_data;
../../drivers/hip/hip_device.c:        device->devices[device_ordinal].dispatch_thread,
../../drivers/hip/hip_device.c:                      device->devices[device_ordinal].device_event_pool,
../../drivers/hip/hip_device.c:  if (device->uses_external_stream) {
../../drivers/hip/hip_device.c:  iree_hal_resource_set_free(data->resource_set);
../../drivers/hip/hip_device.c:  iree_hal_hip_semaphore_callback_data_deinitialize(&data->base);
../../drivers/hip/hip_device.c:  iree_allocator_free(data->base.host_allocator, data);
../../drivers/hip/hip_device.c:  iree_hal_hip_device_t* device = data->base.device;
../../drivers/hip/hip_device.c:      iree_math_count_trailing_zeros_u64(data->base.queue_affinity);
../../drivers/hip/hip_device.c:    iree_hal_command_buffer_t* command_buffer = data->command_buffer;
../../drivers/hip/hip_device.c:          command_buffer, data->base.queue_affinity, &command_buffer);
../../drivers/hip/hip_device.c:            device->devices[device_ordinal].tracing_context,
../../drivers/hip/hip_device.c:            device->devices[device_ordinal].tracing_context,
../../drivers/hip/hip_device.c:  for (iree_host_size_t i = 0; i < data->base.signal_semaphore_list.count;
../../drivers/hip/hip_device.c:        data->base.signal_semaphore_list.semaphores[i]));
../../drivers/hip/hip_device.c:  IREE_ASSERT_EQ(iree_math_count_ones_u64(data->base.queue_affinity), 1,
../../drivers/hip/hip_device.c:  iree_hal_hip_device_t* device = data->base.device;
../../drivers/hip/hip_device.c:  status = iree_status_join(status, data->base.status);
../../drivers/hip/hip_device.c:      iree_math_count_trailing_zeros_u64(data->base.queue_affinity);
../../drivers/hip/hip_device.c:        device->hip_symbols,
../../drivers/hip/hip_device.c:        hipCtxPushCurrent(device->devices[device_ordinal].hip_context));
../../drivers/hip/hip_device.c:        device, device->devices[device_ordinal].hip_dispatch_stream,
../../drivers/hip/hip_device.c:        data->base.wait_semaphore_list, device_ordinal);
../../drivers/hip/hip_device.c:  iree_hal_command_buffer_t* command_buffer = data->command_buffer;
../../drivers/hip/hip_device.c:          command_buffer, data->base.queue_affinity, &command_buffer);
../../drivers/hip/hip_device.c:    iree_hal_buffer_binding_table_t binding_table = data->binding_table;
../../drivers/hip/hip_device.c:          (iree_hal_device_t*)device, mode, command_buffer->allowed_categories,
../../drivers/hip/hip_device.c:          data->base.queue_affinity, 0, &stream_command_buffer);
../../drivers/hip/hip_device.c:        status = iree_hal_resource_set_insert(data->resource_set, 1,
../../drivers/hip/hip_device.c:      data->command_buffer = stream_command_buffer;
../../drivers/hip/hip_device.c:          iree_hal_resource_set_insert(data->resource_set, 1, &command_buffer);
../../drivers/hip/hip_device.c:          iree_hal_resource_set_insert(data->resource_set, 1, &command_buffer);
../../drivers/hip/hip_device.c:            device->hip_symbols,
../../drivers/hip/hip_device.c:                exec, device->devices[device_ordinal].hip_dispatch_stream));
../../drivers/hip/hip_device.c:  if (device->uses_external_stream) {
../../drivers/hip/hip_device.c:        data->base.external_stream_dispatch_data);
../../drivers/hip/hip_device.c:  // Store symbols, because the cleanup may trigger off-thread
../../drivers/hip/hip_device.c:  const iree_hal_hip_dynamic_symbols_t* symbols = device->hip_symbols;
../../drivers/hip/hip_device.c:        device, device->devices[device_ordinal].hip_dispatch_stream,
../../drivers/hip/hip_device.c:        device->cleanup_thread, data->base.signal_semaphore_list,
../../drivers/hip/hip_device.c:    for (iree_host_size_t i = 0; i < data->base.signal_semaphore_list.count;
../../drivers/hip/hip_device.c:      iree_hal_semaphore_fail(data->base.signal_semaphore_list.semaphores[i],
../../drivers/hip/hip_device.c:      &callback_data->base);
../../drivers/hip/hip_device.c:    callback_data->command_buffer = command_buffer;
../../drivers/hip/hip_device.c:                                            &callback_data->resource_set);
../../drivers/hip/hip_device.c:    status = iree_hal_resource_set_insert(callback_data->resource_set,
../../drivers/hip/hip_device.c:    status = iree_hal_resource_set_insert(callback_data->resource_set,
../../drivers/hip/hip_device.c:    status = iree_hal_resource_set_insert(callback_data->resource_set, 1,
../../drivers/hip/hip_device.c:    callback_data->binding_table = binding_table;
../../drivers/hip/hip_device.c:    callback_data->binding_table.bindings = binding_element_ptr;
../../drivers/hip/hip_device.c:        callback_data->resource_set, binding_table.count,
../../drivers/hip/hip_device.c:        callback_data->binding_table.bindings,
../../drivers/hip/hip_device.c:      ((iree_hal_queue_affinity_t)1 << device->device_count);
../../drivers/hip/hip_device.c:  queue_affinity_mask = queue_affinity_mask | (queue_affinity_mask - 1);
../../drivers/hip/hip_device.c:      device, device->host_allocator, &device->block_pool, queue_affinity,
../../drivers/hip/hip_device.c:  if (device->uses_external_stream) {
../../drivers/hip/hip_device.c:    external_stream_data = callback_data->base.external_stream_dispatch_data;
../../drivers/hip/hip_device.c:          device->devices[device_ordinal].dispatch_thread,
../../drivers/hip/hip_device.c:                device->devices[device_ordinal].device_event_pool,
../../drivers/hip/hip_device.c:  if (device->uses_external_stream) {
../../drivers/hip/hip_device.c:                                           device->host_allocator);
../../drivers/accel/accel_device.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/accel/registration.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/accel/registration/BUILD.bazel:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/accel/accel_command_buffer.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/accel/accel_command_buffer.c:// These are the C-linkable stubs that call into the accelerator library.
../../drivers/accel/accel_command_buffer.c:                            "only one-shot command buffer usage is supported");
../../drivers/accel/accel_command_buffer.c:        &iree_hal_accel_command_buffer_vtable, &command_buffer->base);
../../drivers/accel/accel_command_buffer.c:    command_buffer->host_allocator = host_allocator;
../../drivers/accel/accel_command_buffer.c:    command_buffer->scope = scope;
../../drivers/accel/accel_command_buffer.c:    iree_arena_initialize(block_pool, &command_buffer->arena);
../../drivers/accel/accel_command_buffer.c:    iree_task_list_initialize(&command_buffer->root_tasks);
../../drivers/accel/accel_command_buffer.c:    iree_task_list_initialize(&command_buffer->leaf_tasks);
../../drivers/accel/accel_command_buffer.c:    memset(&command_buffer->state, 0, sizeof(command_buffer->state));
../../drivers/accel/accel_command_buffer.c:                                            &command_buffer->resource_set);
../../drivers/accel/accel_command_buffer.c:    *out_command_buffer = &command_buffer->base;
../../drivers/accel/accel_command_buffer.c:    iree_hal_command_buffer_release(&command_buffer->base);
../../drivers/accel/accel_command_buffer.c:  iree_allocator_t host_allocator = command_buffer->host_allocator;
../../drivers/accel/accel_command_buffer.c:  memset(&command_buffer->state, 0, sizeof(command_buffer->state));
../../drivers/accel/accel_command_buffer.c:  iree_task_list_discard(&command_buffer->root_tasks);
../../drivers/accel/accel_command_buffer.c:  iree_task_list_discard(&command_buffer->leaf_tasks);
../../drivers/accel/accel_command_buffer.c:  iree_arena_deinitialize(&command_buffer->arena);
../../drivers/accel/accel_command_buffer.c:  iree_hal_resource_set_free(command_buffer->resource_set);
../../drivers/accel/accel_command_buffer.c:  return iree_hal_resource_is(&command_buffer->resource,
../../drivers/accel/accel_command_buffer.c:  if (!iree_task_list_is_empty(&command_buffer->root_tasks)) {
../../drivers/accel/accel_command_buffer.c:                            "command buffer cannot be re-recorded");
../../drivers/accel/accel_command_buffer.c:  // one-shot: no clear/reset needed for resource_set.
../../drivers/accel/accel_command_buffer.c:  if (iree_task_list_is_empty(&command_buffer->root_tasks) &&
../../drivers/accel/accel_command_buffer.c:      !iree_task_list_is_empty(&command_buffer->leaf_tasks)) {
../../drivers/accel/accel_command_buffer.c:    iree_task_list_move(&command_buffer->leaf_tasks,
../../drivers/accel/accel_command_buffer.c:                        &command_buffer->root_tasks);
../../drivers/accel/accel_command_buffer.c:  iree_hal_resource_set_freeze(command_buffer->resource_set);
../../drivers/accel/accel_command_buffer.c:  iree_task_barrier_t* open_barrier = command_buffer->state.open_barrier;
../../drivers/accel/accel_command_buffer.c:        iree_task_list_front(&command_buffer->state.open_tasks);
../../drivers/accel/accel_command_buffer.c:        command_buffer->state.open_task_count;
../../drivers/accel/accel_command_buffer.c:      iree_task_set_completion_task(&open_barrier->header, task_head);
../../drivers/accel/accel_command_buffer.c:          &command_buffer->arena, dependent_task_count * sizeof(iree_task_t*),
../../drivers/accel/accel_command_buffer.c:        task = task->next_task;
../../drivers/accel/accel_command_buffer.c:  command_buffer->state.open_barrier = NULL;
../../drivers/accel/accel_command_buffer.c:  if (command_buffer->state.open_task_count > 0) {
../../drivers/accel/accel_command_buffer.c:    iree_task_list_move(&command_buffer->state.open_tasks,
../../drivers/accel/accel_command_buffer.c:                        &command_buffer->leaf_tasks);
../../drivers/accel/accel_command_buffer.c:    command_buffer->state.open_task_count = 0;
../../drivers/accel/accel_command_buffer.c:  IREE_RETURN_IF_ERROR(iree_arena_allocate(&command_buffer->arena,
../../drivers/accel/accel_command_buffer.c:  iree_task_barrier_initialize_empty(command_buffer->scope, barrier);
../../drivers/accel/accel_command_buffer.c:  for (iree_task_t* task = iree_task_list_front(&command_buffer->leaf_tasks);
../../drivers/accel/accel_command_buffer.c:       task != NULL; task = task->next_task) {
../../drivers/accel/accel_command_buffer.c:    iree_task_set_completion_task(task, &barrier->header);
../../drivers/accel/accel_command_buffer.c:  if (iree_task_list_is_empty(&command_buffer->root_tasks) &&
../../drivers/accel/accel_command_buffer.c:      !iree_task_list_is_empty(&command_buffer->leaf_tasks)) {
../../drivers/accel/accel_command_buffer.c:    iree_task_list_move(&command_buffer->leaf_tasks,
../../drivers/accel/accel_command_buffer.c:                        &command_buffer->root_tasks);
../../drivers/accel/accel_command_buffer.c:      iree_task_list_is_empty(&command_buffer->root_tasks)
../../drivers/accel/accel_command_buffer.c:          ? &command_buffer->root_tasks
../../drivers/accel/accel_command_buffer.c:          : &command_buffer->leaf_tasks;
../../drivers/accel/accel_command_buffer.c:  iree_task_list_push_back(target_task_list, &barrier->header);
../../drivers/accel/accel_command_buffer.c:  command_buffer->state.open_barrier = barrier;
../../drivers/accel/accel_command_buffer.c:  command_buffer->state.open_task_count = 0;
../../drivers/accel/accel_command_buffer.c:  if (command_buffer->state.open_barrier == NULL) {
../../drivers/accel/accel_command_buffer.c:    iree_task_list_push_back(&command_buffer->leaf_tasks, task);
../../drivers/accel/accel_command_buffer.c:    iree_task_list_push_back(&command_buffer->state.open_tasks, task);
../../drivers/accel/accel_command_buffer.c:    ++command_buffer->state.open_task_count;
../../drivers/accel/accel_command_buffer.c:  bool has_root_tasks = !iree_task_list_is_empty(&command_buffer->root_tasks);
../../drivers/accel/accel_command_buffer.c:  bool has_leaf_tasks = !iree_task_list_is_empty(&command_buffer->leaf_tasks);
../../drivers/accel/accel_command_buffer.c:    for (iree_task_t* task = command_buffer->leaf_tasks.head; task != NULL;
../../drivers/accel/accel_command_buffer.c:         task = task->next_task) {
../../drivers/accel/accel_command_buffer.c:    for (iree_task_t* task = command_buffer->root_tasks.head; task != NULL;
../../drivers/accel/accel_command_buffer.c:         task = task->next_task) {
../../drivers/accel/accel_command_buffer.c:                                    &command_buffer->root_tasks);
../../drivers/accel/accel_command_buffer.c:  iree_task_list_initialize(&command_buffer->leaf_tasks);
../../drivers/accel/accel_command_buffer.c:  iree_device_size_t length_per_slice = tile_context->workgroup_size[0];
../../drivers/accel/accel_command_buffer.c:      (iree_device_size_t)tile_context->workgroup_xyz[0] * length_per_slice;
../../drivers/accel/accel_command_buffer.c:  iree_device_size_t remaining_length = cmd->target_ref.length - slice_offset;
../../drivers/accel/accel_command_buffer.c:      cmd->target_ref.buffer, cmd->target_ref.offset + slice_offset,
../../drivers/accel/accel_command_buffer.c:      slice_length, cmd->pattern, cmd->pattern_length);
../../drivers/accel/accel_command_buffer.c:      command_buffer->resource_set, 1, &target_ref.buffer));
../../drivers/accel/accel_command_buffer.c:      iree_arena_allocate(&command_buffer->arena, sizeof(*cmd), (void**)&cmd));
../../drivers/accel/accel_command_buffer.c:      command_buffer->scope,
../../drivers/accel/accel_command_buffer.c:      workgroup_size, workgroup_count, &cmd->task);
../../drivers/accel/accel_command_buffer.c:  cmd->target_ref = target_ref;
../../drivers/accel/accel_command_buffer.c:  memcpy(cmd->pattern, pattern, pattern_length);
../../drivers/accel/accel_command_buffer.c:  cmd->pattern_length = pattern_length;
../../drivers/accel/accel_command_buffer.c:                                                          &cmd->task.header);
../../drivers/accel/accel_command_buffer.c:      iree_hal_buffer_map_write(cmd->target_ref.buffer, cmd->target_ref.offset,
../../drivers/accel/accel_command_buffer.c:                                cmd->source_buffer, cmd->target_ref.length);
../../drivers/accel/accel_command_buffer.c:      command_buffer->resource_set, 1, &target_ref.buffer));
../../drivers/accel/accel_command_buffer.c:  IREE_RETURN_IF_ERROR(iree_arena_allocate(&command_buffer->arena,
../../drivers/accel/accel_command_buffer.c:      command_buffer->scope,
../../drivers/accel/accel_command_buffer.c:      &cmd->task);
../../drivers/accel/accel_command_buffer.c:  cmd->target_ref = target_ref;
../../drivers/accel/accel_command_buffer.c:  memcpy(cmd->source_buffer, (const uint8_t*)source_buffer + source_offset,
../../drivers/accel/accel_command_buffer.c:         cmd->target_ref.length);
../../drivers/accel/accel_command_buffer.c:                                                          &cmd->task.header);
../../drivers/accel/accel_command_buffer.c:  iree_device_size_t length_per_slice = tile_context->workgroup_size[0];
../../drivers/accel/accel_command_buffer.c:      (iree_device_size_t)tile_context->workgroup_xyz[0] * length_per_slice;
../../drivers/accel/accel_command_buffer.c:  iree_device_size_t remaining_length = cmd->target_ref.length - slice_offset;
../../drivers/accel/accel_command_buffer.c:      cmd->source_ref.buffer, cmd->source_ref.offset + slice_offset,
../../drivers/accel/accel_command_buffer.c:      cmd->target_ref.buffer, cmd->target_ref.offset + slice_offset,
../../drivers/accel/accel_command_buffer.c:      command_buffer->resource_set, IREE_ARRAYSIZE(buffers),
../../drivers/accel/accel_command_buffer.c:      iree_arena_allocate(&command_buffer->arena, sizeof(*cmd), (void**)&cmd));
../../drivers/accel/accel_command_buffer.c:      command_buffer->scope,
../../drivers/accel/accel_command_buffer.c:      workgroup_size, workgroup_count, &cmd->task);
../../drivers/accel/accel_command_buffer.c:  cmd->source_ref = source_ref;
../../drivers/accel/accel_command_buffer.c:  cmd->target_ref = target_ref;
../../drivers/accel/accel_command_buffer.c:                                                          &cmd->task.header);
../../drivers/accel/accel_command_buffer.c:  // used (known at compile-time).
../../drivers/accel/accel_command_buffer.c:  // - const uint32_t constants[constant_count];
../../drivers/accel/accel_command_buffer.c:  // - void* binding_ptrs[binding_count];
../../drivers/accel/accel_command_buffer.c:  // - const size_t binding_lengths[binding_count];
../../drivers/accel/accel_command_buffer.c:      .workgroup_size_x = tile_context->workgroup_size[0],
../../drivers/accel/accel_command_buffer.c:      .workgroup_size_y = tile_context->workgroup_size[1],
../../drivers/accel/accel_command_buffer.c:      .workgroup_size_z = tile_context->workgroup_size[2],
../../drivers/accel/accel_command_buffer.c:      .constant_count = cmd->constant_count,
../../drivers/accel/accel_command_buffer.c:      .workgroup_count_x = tile_context->workgroup_count[0],
../../drivers/accel/accel_command_buffer.c:      .workgroup_count_y = tile_context->workgroup_count[1],
../../drivers/accel/accel_command_buffer.c:      .workgroup_count_z = tile_context->workgroup_count[2],
../../drivers/accel/accel_command_buffer.c:          iree_task_affinity_set_count_ones(cmd->task.header.affinity_set),
../../drivers/accel/accel_command_buffer.c:      .binding_count = cmd->binding_count,
../../drivers/accel/accel_command_buffer.c:  cmd_ptr += cmd->constant_count * sizeof(*dispatch_state.constants);
../../drivers/accel/accel_command_buffer.c:  cmd_ptr += cmd->binding_count * sizeof(*dispatch_state.binding_ptrs);
../../drivers/accel/accel_command_buffer.c:  cmd_ptr += cmd->binding_count * sizeof(*dispatch_state.binding_lengths);
../../drivers/accel/accel_command_buffer.c:          .workgroup_id_x = tile_context->workgroup_xyz[0],
../../drivers/accel/accel_command_buffer.c:          .workgroup_id_y = tile_context->workgroup_xyz[1],
../../drivers/accel/accel_command_buffer.c:          .workgroup_id_z = tile_context->workgroup_xyz[2],
../../drivers/accel/accel_command_buffer.c:          .processor_id = tile_context->processor_id,
../../drivers/accel/accel_command_buffer.c:          .local_memory = tile_context->local_memory.data,
../../drivers/accel/accel_command_buffer.c:          .local_memory_size = (size_t)tile_context->local_memory.data_length,
../../drivers/accel/accel_command_buffer.c:      cmd->executable, cmd->ordinal, &dispatch_state, &workgroup_state,
../../drivers/accel/accel_command_buffer.c:      tile_context->worker_id);
../../drivers/accel/accel_command_buffer.c:      z0, iree_hal_buffer_map_range(cmd->bindings[0].buffer,
../../drivers/accel/accel_command_buffer.c:      z0, iree_hal_buffer_map_range(cmd->bindings[1].buffer,
../../drivers/accel/accel_command_buffer.c:      z0, iree_hal_buffer_map_range(cmd->bindings[2].buffer,
../../drivers/accel/accel_command_buffer.c:      iree_hal_buffer_map_range(cmd->bindings[3].buffer,
../../drivers/accel/accel_command_buffer.c:  if (local_executable->library && local_executable->library->exports.names &&
../../drivers/accel/accel_command_buffer.c:      entry_point < local_executable->library->exports.count) {
../../drivers/accel/accel_command_buffer.c:        local_executable->library->exports.names[entry_point]);
../../drivers/accel/accel_command_buffer.c:        iree_arena_allocate(&command_buffer->arena, sizeof(*cmd), (void**)&cmd));
../../drivers/accel/accel_command_buffer.c:        command_buffer->scope,
../../drivers/accel/accel_command_buffer.c:        &cmd->task);
../../drivers/accel/accel_command_buffer.c:    for (int i = 0; i < 4; ++i) cmd->bindings[i] = bindings.values[i];
../../drivers/accel/accel_command_buffer.c:                                                             &cmd->task.header);
../../drivers/accel/accel_command_buffer.c:  if (local_executable->dispatch_attrs) {
../../drivers/accel/accel_command_buffer.c:    dispatch_attrs = local_executable->dispatch_attrs[entry_point];
../../drivers/accel/accel_command_buffer.c:  IREE_RETURN_IF_ERROR(iree_arena_allocate(&command_buffer->arena,
../../drivers/accel/accel_command_buffer.c:      command_buffer->scope,
../../drivers/accel/accel_command_buffer.c:      config.workgroup_size, config.workgroup_count, &cmd->task);
../../drivers/accel/accel_command_buffer.c:  cmd->executable = local_executable;
../../drivers/accel/accel_command_buffer.c:  cmd->ordinal = entry_point;
../../drivers/accel/accel_command_buffer.c:  cmd->constant_count = dispatch_attrs.constant_count;
../../drivers/accel/accel_command_buffer.c:  cmd->binding_count = dispatch_attrs.binding_count;
../../drivers/accel/accel_command_buffer.c:    cmd->task.header.flags |= IREE_TASK_FLAG_DISPATCH_INDIRECT;
../../drivers/accel/accel_command_buffer.c:    cmd->task.workgroup_count.ptr =
../../drivers/accel/accel_command_buffer.c:      command_buffer->resource_set, resource_count,
../../drivers/accel/accel_command_buffer.c:  cmd->task.local_memory_size =
../../drivers/accel/accel_command_buffer.c:                            "constants must be 4-byte aligned");
../../drivers/accel/accel_command_buffer.c:      command_buffer->resource_set, bindings.count, bindings.values,
../../drivers/accel/accel_command_buffer.c:                                                          &cmd->task.header);
../../drivers/accel/registration/accel_driver_module.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/accel/registration/accel_driver_module.c:          "0 will default to a platform-specific number.");
../../drivers/accel/registration/accel_driver_module.c:  // Use a stack-allocated array for the loaders, which is the standard pattern.
../../drivers/accel/registration/accel_driver_module.c:  // A fixed-size capacity is used as the number of loaders is small.
../../drivers/accel/registration/accel_driver_module.c:        //     "accel-bytecode-fb" .
../../drivers/accel/registration/accel_driver_module.c:  // NOTE: loaders array is stack-allocated and does not need to be freed.
../../drivers/accel/registration/CMakeLists.txt:# CMake-only content.                                                          #
../../drivers/init_external.c.in:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/accel/registration/accel_driver_module.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/event_pool.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/event_pool.h://===----------------------------------------------------------------------===//
../../drivers/cuda/event_pool.h://===----------------------------------------------------------------------===//
../../drivers/cuda/event_pool.h:// Thread-safe; multiple threads may retain and release the same event.
../../drivers/cuda/event_pool.h://===----------------------------------------------------------------------===//
../../drivers/cuda/event_pool.h://===----------------------------------------------------------------------===//
../../drivers/cuda/event_pool.h:// Thread-safe; multiple threads may acquire and release events from the pool.
../../drivers/cuda/native_executable.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/native_executable.h:// The max number of per-dispatch bindings allowed in the CUDA HAL
../../drivers/cuda/native_executable.h:// The max number of per-dispatch constants supported by the CUDA HAL
../../drivers/null/api.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/null/api.h://===----------------------------------------------------------------------===//
../../drivers/null/api.h://===----------------------------------------------------------------------===//
../../drivers/null/api.h://===----------------------------------------------------------------------===//
../../drivers/null/api.h://===----------------------------------------------------------------------===//
../../drivers/cuda/event_semaphore.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/event_semaphore.h:// Thread-safe; multiple threads may signal/wait values on the same semaphore.
../../drivers/cuda/event_semaphore.h:// Performs a multi-wait on one or more semaphores. Returns
../../drivers/cuda/stream_command_buffer.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/stream_command_buffer.c:  // Per-stream CUDA tracing context.
../../drivers/cuda/stream_command_buffer.c:  // Staging arena used for host->device transfers.
../../drivers/cuda/stream_command_buffer.c:      &iree_hal_cuda_stream_command_buffer_vtable, &command_buffer->base);
../../drivers/cuda/stream_command_buffer.c:  command_buffer->host_allocator = host_allocator;
../../drivers/cuda/stream_command_buffer.c:  command_buffer->cuda_symbols = cuda_symbols;
../../drivers/cuda/stream_command_buffer.c:  command_buffer->nccl_symbols = nccl_symbols;
../../drivers/cuda/stream_command_buffer.c:  command_buffer->tracing_context = tracing_context;
../../drivers/cuda/stream_command_buffer.c:  command_buffer->tracing_event_list.head = NULL;
../../drivers/cuda/stream_command_buffer.c:  command_buffer->tracing_event_list.tail = NULL;
../../drivers/cuda/stream_command_buffer.c:  command_buffer->cu_stream = stream;
../../drivers/cuda/stream_command_buffer.c:  iree_arena_initialize(block_pool, &command_buffer->arena);
../../drivers/cuda/stream_command_buffer.c:      iree_hal_resource_set_allocate(block_pool, &command_buffer->resource_set);
../../drivers/cuda/stream_command_buffer.c:    iree_hal_collective_batch_initialize(&command_buffer->arena,
../../drivers/cuda/stream_command_buffer.c:                                         command_buffer->resource_set,
../../drivers/cuda/stream_command_buffer.c:                                         &command_buffer->collective_batch);
../../drivers/cuda/stream_command_buffer.c:  *out_command_buffer = &command_buffer->base;
../../drivers/cuda/stream_command_buffer.c:  iree_allocator_t host_allocator = command_buffer->host_allocator;
../../drivers/cuda/stream_command_buffer.c:  iree_hal_stream_tracing_free(command_buffer->tracing_context,
../../drivers/cuda/stream_command_buffer.c:                               &command_buffer->tracing_event_list);
../../drivers/cuda/stream_command_buffer.c:  iree_hal_collective_batch_deinitialize(&command_buffer->collective_batch);
../../drivers/cuda/stream_command_buffer.c:  iree_hal_resource_set_free(command_buffer->resource_set);
../../drivers/cuda/stream_command_buffer.c:  iree_arena_deinitialize(&command_buffer->arena);
../../drivers/cuda/stream_command_buffer.c:  return iree_hal_resource_is(&command_buffer->resource,
../../drivers/cuda/stream_command_buffer.c:  if (!command_buffer->tracing_context) {
../../drivers/cuda/stream_command_buffer.c:  iree_hal_stream_tracing_notify_submitted(command_buffer->tracing_context,
../../drivers/cuda/stream_command_buffer.c:                                           &command_buffer->tracing_event_list);
../../drivers/cuda/stream_command_buffer.c:// Must be called before any other non-collective nodes are added to the graph
../../drivers/cuda/stream_command_buffer.c:  // NOTE: we could move this out into callers by way of an always-inline shim -
../../drivers/cuda/stream_command_buffer.c:          &command_buffer->collective_batch))) {
../../drivers/cuda/stream_command_buffer.c:      command_buffer->nccl_symbols, command_buffer->tracing_context,
../../drivers/cuda/stream_command_buffer.c:      &command_buffer->tracing_event_list, &command_buffer->collective_batch,
../../drivers/cuda/stream_command_buffer.c:      command_buffer->cu_stream);
../../drivers/cuda/stream_command_buffer.c:  iree_hal_collective_batch_clear(&command_buffer->collective_batch);
../../drivers/cuda/stream_command_buffer.c:      command_buffer->tracing_context, &command_buffer->tracing_event_list,
../../drivers/cuda/stream_command_buffer.c:  iree_arena_reset(&command_buffer->arena);
../../drivers/cuda/stream_command_buffer.c:  iree_hal_collective_batch_deinitialize(&command_buffer->collective_batch);
../../drivers/cuda/stream_command_buffer.c:  iree_hal_resource_set_free(command_buffer->resource_set);
../../drivers/cuda/stream_command_buffer.c:      z0, iree_hal_resource_set_allocate(command_buffer->arena.block_pool,
../../drivers/cuda/stream_command_buffer.c:                                         &command_buffer->resource_set));
../../drivers/cuda/stream_command_buffer.c:  iree_hal_collective_batch_initialize(&command_buffer->arena,
../../drivers/cuda/stream_command_buffer.c:                                       command_buffer->resource_set,
../../drivers/cuda/stream_command_buffer.c:                                       &command_buffer->collective_batch);
../../drivers/cuda/stream_command_buffer.c:  IREE_HAL_STREAM_TRACE_ZONE_END(command_buffer->tracing_context,
../../drivers/cuda/stream_command_buffer.c:                                 &command_buffer->tracing_event_list,
../../drivers/cuda/stream_command_buffer.c:      command_buffer->tracing_context, &command_buffer->tracing_event_list,
../../drivers/cuda/stream_command_buffer.c:      location ? location->file.data : NULL, location ? location->file.size : 0,
../../drivers/cuda/stream_command_buffer.c:      location ? location->line : 0,
../../drivers/cuda/stream_command_buffer.c:  IREE_HAL_STREAM_TRACE_ZONE_END(command_buffer->tracing_context,
../../drivers/cuda/stream_command_buffer.c:                                 &command_buffer->tracing_event_list,
../../drivers/cuda/stream_command_buffer.c:                            "non-zero barrier flag not yet supported");
../../drivers/cuda/stream_command_buffer.c:  // Nothing to do for barriers between memory operations or dispatches--CUDA
../../drivers/cuda/stream_command_buffer.c:          z0, command_buffer->cuda_symbols,
../../drivers/cuda/stream_command_buffer.c:                           command_buffer->cu_stream),
../../drivers/cuda/stream_command_buffer.c:          z0, command_buffer->cuda_symbols,
../../drivers/cuda/stream_command_buffer.c:                           command_buffer->cu_stream),
../../drivers/cuda/stream_command_buffer.c:          z0, command_buffer->cuda_symbols,
../../drivers/cuda/stream_command_buffer.c:                          command_buffer->cu_stream),
../../drivers/cuda/stream_command_buffer.c:  if (command_buffer->arena.block_pool) {
../../drivers/cuda/stream_command_buffer.c:        z0, iree_arena_allocate(&command_buffer->arena, target_ref.length,
../../drivers/cuda/stream_command_buffer.c:      z0, command_buffer->cuda_symbols,
../../drivers/cuda/stream_command_buffer.c:      cuMemcpyHtoDAsync(dst, src, target_ref.length, command_buffer->cu_stream),
../../drivers/cuda/stream_command_buffer.c:      z0, command_buffer->cuda_symbols,
../../drivers/cuda/stream_command_buffer.c:      cuMemcpyAsync(dst, src, target_ref.length, command_buffer->cu_stream),
../../drivers/cuda/stream_command_buffer.c:      &command_buffer->collective_batch, channel, op, param, send_binding,
../../drivers/cuda/stream_command_buffer.c:  // Lookup kernel parameters used for side-channeling additional launch
../../drivers/cuda/stream_command_buffer.c:      command_buffer->tracing_context, &command_buffer->tracing_event_list,
../../drivers/cuda/stream_command_buffer.c:      kernel_params->debug_info.source_filename.data,
../../drivers/cuda/stream_command_buffer.c:      kernel_params->debug_info.source_filename.size,
../../drivers/cuda/stream_command_buffer.c:      kernel_params->debug_info.source_line,
../../drivers/cuda/stream_command_buffer.c:      kernel_params->debug_info.function_name.data,
../../drivers/cuda/stream_command_buffer.c:      kernel_params->debug_info.function_name.size,
../../drivers/cuda/stream_command_buffer.c:      z0, iree_hal_resource_set_insert(command_buffer->resource_set, 1,
../../drivers/cuda/stream_command_buffer.c:      kernel_params->binding_count + kernel_params->constant_count;
../../drivers/cuda/stream_command_buffer.c:  // TODO: use packed parameters instead of the indirection mechanism - this
../../drivers/cuda/stream_command_buffer.c:  //   of N pointers. Each pointer, from kernelParams[0] to kernelParams[N-1],
../../drivers/cuda/stream_command_buffer.c:  // https://docs.nvidia.com/cuda/cuda-driver-api/group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g50d871e3bd06c1b835e52f2966ef366b)
../../drivers/cuda/stream_command_buffer.c:      z0, iree_arena_allocate(&command_buffer->arena, total_size,
../../drivers/cuda/stream_command_buffer.c:    if (binding->buffer) {
../../drivers/cuda/stream_command_buffer.c:          z0, iree_hal_resource_set_insert(command_buffer->resource_set, 1,
../../drivers/cuda/stream_command_buffer.c:                                           &binding->buffer));
../../drivers/cuda/stream_command_buffer.c:          iree_hal_buffer_allocated_buffer(binding->buffer));
../../drivers/cuda/stream_command_buffer.c:      iree_device_size_t offset = iree_hal_buffer_byte_offset(binding->buffer);
../../drivers/cuda/stream_command_buffer.c:      device_ptr = device_buffer + offset + binding->offset;
../../drivers/cuda/stream_command_buffer.c:  // just storing a 32-bit value for the push constant here instead. So we must
../../drivers/cuda/stream_command_buffer.c:  // process one element each type, for 64-bit machines.
../../drivers/cuda/stream_command_buffer.c:  for (iree_host_size_t i = 0; i < kernel_params->constant_count; i++) {
../../drivers/cuda/stream_command_buffer.c:    *((uint32_t*)params_ptr[kernel_params->binding_count + i]) =
../../drivers/cuda/stream_command_buffer.c:      z0, command_buffer->cuda_symbols,
../../drivers/cuda/stream_command_buffer.c:      cuLaunchKernel(kernel_params->function, config.workgroup_count[0],
../../drivers/cuda/stream_command_buffer.c:                                              : kernel_params->block_dims[0],
../../drivers/cuda/stream_command_buffer.c:                                              : kernel_params->block_dims[1],
../../drivers/cuda/stream_command_buffer.c:                                              : kernel_params->block_dims[2],
../../drivers/cuda/stream_command_buffer.c:                     kernel_params->block_shared_memory_size,
../../drivers/cuda/stream_command_buffer.c:                     command_buffer->cu_stream, params_ptr, NULL),
../../drivers/cuda/stream_command_buffer.c:  IREE_HAL_STREAM_TRACE_ZONE_END(command_buffer->tracing_context,
../../drivers/cuda/stream_command_buffer.c:                                 &command_buffer->tracing_event_list,
../../drivers/cuda/memory_pools.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/memory_pools.h:  // Used for any host-visible/host-local memory types.
../../drivers/cuda/memory_pools.h:// The allocation will be stream-ordered on |stream|.
../../drivers/cuda/memory_pools.h:// The deallocation will be stream-ordered on |stream|.
../../drivers/cuda/cuda_device.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/cuda_device.c://===----------------------------------------------------------------------===//
../../drivers/cuda/cuda_device.c://===----------------------------------------------------------------------===//
../../drivers/cuda/cuda_device.c:  iree_allocator_free(device_interface->host_allocator, device_interface);
../../drivers/cuda/cuda_device.c:  return IREE_CURESULT_TO_STATUS(device_interface->cuda_symbols,
../../drivers/cuda/cuda_device.c:                                 cuCtxSetCurrent(device_interface->cu_context),
../../drivers/cuda/cuda_device.c:      device_interface->cuda_symbols,
../../drivers/cuda/cuda_device.c:      cuStreamWaitEvent(device_interface->dispatch_cu_stream, (CUevent)event,
../../drivers/cuda/cuda_device.c:      device_interface->cuda_symbols,
../../drivers/cuda/cuda_device.c:      device_interface->cuda_symbols,
../../drivers/cuda/cuda_device.c:      cuEventRecord((CUevent)event, device_interface->dispatch_cu_stream),
../../drivers/cuda/cuda_device.c:  return IREE_CURESULT_TO_STATUS(device_interface->cuda_symbols,
../../drivers/cuda/cuda_device.c:  return IREE_CURESULT_TO_STATUS(device_interface->cuda_symbols,
../../drivers/cuda/cuda_device.c:      device_interface->cuda_symbols,
../../drivers/cuda/cuda_device.c:          device_interface->dispatch_cu_stream,
../../drivers/cuda/cuda_device.c:      device_interface->device, mode, categories, 0, out);
../../drivers/cuda/cuda_device.c:        device_interface->cuda_symbols,
../../drivers/cuda/cuda_device.c:        cuGraphLaunch(exec, device_interface->dispatch_cu_stream));
../../drivers/cuda/cuda_device.c:  iree_allocator_free(device_interface->host_allocator, device_interface);
../../drivers/cuda/cuda_device.c:  return IREE_CURESULT_TO_STATUS(device_interface->cuda_symbols,
../../drivers/cuda/cuda_device.c:      device_interface->cuda_symbols,
../../drivers/cuda/cuda_device.c:  return IREE_CURESULT_TO_STATUS(device_interface->cuda_symbols,
../../drivers/cuda/cuda_device.c:      device_interface->cuda_symbols,
../../drivers/cuda/cuda_device.c:  IREE_CUDA_IGNORE_ERROR(device_interface->cuda_symbols,
../../drivers/cuda/cuda_device.c:      device_interface->cuda_symbols,
../../drivers/cuda/cuda_device.c:      cuEventRecord((CUevent)base_event, device_interface->dispatch_cu_stream));
../../drivers/cuda/cuda_device.c:      device_interface->cuda_symbols,
../../drivers/cuda/cuda_device.c:  out_params->arena_block_size = 32 * 1024;
../../drivers/cuda/cuda_device.c:  out_params->event_pool_capacity = 32;
../../drivers/cuda/cuda_device.c:  out_params->queue_count = 1;
../../drivers/cuda/cuda_device.c:  out_params->command_buffer_mode = IREE_HAL_CUDA_COMMAND_BUFFER_MODE_GRAPH;
../../drivers/cuda/cuda_device.c:  out_params->stream_tracing = 0;
../../drivers/cuda/cuda_device.c:  out_params->async_allocations = true;
../../drivers/cuda/cuda_device.c:  if (params->arena_block_size < 4096) {
../../drivers/cuda/cuda_device.c:  if (params->queue_count == 0) {
../../drivers/cuda/cuda_device.c:  iree_hal_resource_initialize(&iree_hal_cuda_device_vtable, &device->resource);
../../drivers/cuda/cuda_device.c:      identifier, &device->identifier,
../../drivers/cuda/cuda_device.c:  iree_arena_block_pool_initialize(params->arena_block_size, host_allocator,
../../drivers/cuda/cuda_device.c:                                   &device->block_pool);
../../drivers/cuda/cuda_device.c:  device->driver = driver;
../../drivers/cuda/cuda_device.c:  iree_hal_driver_retain(device->driver);
../../drivers/cuda/cuda_device.c:  device->cuda_symbols = cuda_symbols;
../../drivers/cuda/cuda_device.c:  device->nccl_symbols = nccl_symbols;
../../drivers/cuda/cuda_device.c:  device->params = *params;
../../drivers/cuda/cuda_device.c:  device->cu_context = context;
../../drivers/cuda/cuda_device.c:  device->cu_device = cu_device;
../../drivers/cuda/cuda_device.c:  device->dispatch_cu_stream = dispatch_stream;
../../drivers/cuda/cuda_device.c:  device->host_allocator = host_allocator;
../../drivers/cuda/cuda_device.c:  device_interface->base.vtable =
../../drivers/cuda/cuda_device.c:  device_interface->cu_context = context;
../../drivers/cuda/cuda_device.c:  device_interface->cuda_symbols = cuda_symbols;
../../drivers/cuda/cuda_device.c:  device_interface->cu_device = cu_device;
../../drivers/cuda/cuda_device.c:  device_interface->device = (iree_hal_device_t*)device;
../../drivers/cuda/cuda_device.c:  device_interface->dispatch_cu_stream = dispatch_stream;
../../drivers/cuda/cuda_device.c:  device_interface->host_allocator = host_allocator;
../../drivers/cuda/cuda_device.c:      &device->block_pool, host_allocator, &device->work_queue);
../../drivers/cuda/cuda_device.c:  // Enable tracing for the (currently only) stream - no-op if disabled.
../../drivers/cuda/cuda_device.c:  if (iree_status_is_ok(status) && device->params.stream_tracing) {
../../drivers/cuda/cuda_device.c:    if (device->params.stream_tracing >=
../../drivers/cuda/cuda_device.c:        device->params.stream_tracing < IREE_HAL_STREAM_TRACING_VERBOSITY_OFF) {
../../drivers/cuda/cuda_device.c:    tracing_device_interface->base.vtable =
../../drivers/cuda/cuda_device.c:    tracing_device_interface->cu_context = context;
../../drivers/cuda/cuda_device.c:    tracing_device_interface->cu_device = cu_device;
../../drivers/cuda/cuda_device.c:    tracing_device_interface->dispatch_cu_stream = dispatch_stream;
../../drivers/cuda/cuda_device.c:    tracing_device_interface->host_allocator = host_allocator;
../../drivers/cuda/cuda_device.c:    tracing_device_interface->cuda_symbols = cuda_symbols;
../../drivers/cuda/cuda_device.c:        device->identifier, device->params.stream_tracing, &device->block_pool,
../../drivers/cuda/cuda_device.c:        host_allocator, &device->tracing_context);
../../drivers/cuda/cuda_device.c:  if (iree_status_is_ok(status) && params->async_allocations) {
../../drivers/cuda/cuda_device.c:    device->supports_memory_pools = supports_memory_pools != 0;
../../drivers/cuda/cuda_device.c:  if (iree_status_is_ok(status) && device->supports_memory_pools) {
../../drivers/cuda/cuda_device.c:        &params->memory_pools, host_allocator, &device->memory_pools);
../../drivers/cuda/cuda_device.c:        device->supports_memory_pools ? &device->memory_pools : NULL,
../../drivers/cuda/cuda_device.c:        host_allocator, &device->device_allocator);
../../drivers/cuda/cuda_device.c:    if (dispatch_stream) cuda_symbols->cuStreamDestroy(dispatch_stream);
../../drivers/cuda/cuda_device.c:    if (context) cuda_symbols->cuDevicePrimaryCtxRelease(device);
../../drivers/cuda/cuda_device.c:    status = iree_event_pool_allocate(params->event_pool_capacity,
../../drivers/cuda/cuda_device.c:        cuda_symbols, params->event_pool_capacity, host_allocator,
../../drivers/cuda/cuda_device.c:        host_event_pool, device_event_pool, params->event_pool_capacity,
../../drivers/cuda/cuda_device.c:    cuda_device->host_event_pool = host_event_pool;
../../drivers/cuda/cuda_device.c:    cuda_device->device_event_pool = device_event_pool;
../../drivers/cuda/cuda_device.c:    cuda_device->timepoint_pool = timepoint_pool;
../../drivers/cuda/cuda_device.c:  return device->cu_context;
../../drivers/cuda/cuda_device.c:  return device->cuda_symbols;
../../drivers/cuda/cuda_device.c:  const iree_hal_cuda_dynamic_symbols_t* symbols = device->cuda_symbols;
../../drivers/cuda/cuda_device.c:  iree_hal_deferred_work_queue_destroy(device->work_queue);
../../drivers/cuda/cuda_device.c:  iree_hal_allocator_release(device->device_allocator);
../../drivers/cuda/cuda_device.c:  iree_hal_channel_provider_release(device->channel_provider);
../../drivers/cuda/cuda_device.c:  iree_hal_cuda_memory_pools_deinitialize(&device->memory_pools);
../../drivers/cuda/cuda_device.c:  iree_hal_stream_tracing_context_free(device->tracing_context);
../../drivers/cuda/cuda_device.c:  if (device->timepoint_pool) {
../../drivers/cuda/cuda_device.c:    iree_hal_cuda_timepoint_pool_free(device->timepoint_pool);
../../drivers/cuda/cuda_device.c:  if (device->device_event_pool) {
../../drivers/cuda/cuda_device.c:    iree_hal_cuda_event_pool_release(device->device_event_pool);
../../drivers/cuda/cuda_device.c:  if (device->host_event_pool) iree_event_pool_free(device->host_event_pool);
../../drivers/cuda/cuda_device.c:  IREE_CUDA_IGNORE_ERROR(symbols, cuStreamDestroy(device->dispatch_cu_stream));
../../drivers/cuda/cuda_device.c:  IREE_CUDA_IGNORE_ERROR(symbols, cuDevicePrimaryCtxRelease(device->cu_device));
../../drivers/cuda/cuda_device.c:  iree_arena_block_pool_deinitialize(&device->block_pool);
../../drivers/cuda/cuda_device.c:  iree_hal_driver_release(device->driver);
../../drivers/cuda/cuda_device.c:  return device->identifier;
../../drivers/cuda/cuda_device.c:  return device->host_allocator;
../../drivers/cuda/cuda_device.c:  return device->device_allocator;
../../drivers/cuda/cuda_device.c:  iree_hal_allocator_release(device->device_allocator);
../../drivers/cuda/cuda_device.c:  device->device_allocator = new_allocator;
../../drivers/cuda/cuda_device.c:  iree_hal_channel_provider_release(device->channel_provider);
../../drivers/cuda/cuda_device.c:  device->channel_provider = new_provider;
../../drivers/cuda/cuda_device.c:  iree_arena_block_pool_trim(&device->block_pool);
../../drivers/cuda/cuda_device.c:  IREE_RETURN_IF_ERROR(iree_hal_allocator_trim(device->device_allocator));
../../drivers/cuda/cuda_device.c:  if (device->supports_memory_pools) {
../../drivers/cuda/cuda_device.c:        &device->memory_pools, &device->params.memory_pools));
../../drivers/cuda/cuda_device.c:      device->cuda_symbols,
../../drivers/cuda/cuda_device.c:      cuDeviceGetAttribute(&value, attribute, device->cu_device),
../../drivers/cuda/cuda_device.c:        iree_string_view_match_pattern(device->identifier, key) ? 1 : 0;
../../drivers/cuda/cuda_device.c:    *out_value = iree_string_view_equal(key, IREE_SV("cuda-nvptx-fb")) ? 1 : 0;
../../drivers/cuda/cuda_device.c:  if (!device->nccl_symbols || !device->nccl_symbols->dylib) {
../../drivers/cuda/cuda_device.c:  if (device->channel_provider &&
../../drivers/cuda/cuda_device.c:            device->channel_provider, &params.rank, &params.count),
../../drivers/cuda/cuda_device.c:    if (!device->channel_provider) {
../../drivers/cuda/cuda_device.c:          iree_hal_cuda_nccl_get_unique_id(device->nccl_symbols, &id),
../../drivers/cuda/cuda_device.c:                             device->channel_provider,
../../drivers/cuda/cuda_device.c:    // User provided the ID - we treat it as opaque here and let NCCL validate.
../../drivers/cuda/cuda_device.c:      device->cuda_symbols, device->nccl_symbols, &id, params.rank,
../../drivers/cuda/cuda_device.c:      params.count, device->host_allocator, out_channel);
../../drivers/cuda/cuda_device.c:      iree_hal_device_allocator(base_device), device->cuda_symbols,
../../drivers/cuda/cuda_device.c:      device->nccl_symbols, device->tracing_context, mode, command_categories,
../../drivers/cuda/cuda_device.c:      binding_capacity, device->dispatch_cu_stream, &device->block_pool,
../../drivers/cuda/cuda_device.c:      device->host_allocator, out_command_buffer);
../../drivers/cuda/cuda_device.c:  switch (device->params.command_buffer_mode) {
../../drivers/cuda/cuda_device.c:      // TODO(indirect-cmd): when we can record indirect graphs we won't need
../../drivers/cuda/cuda_device.c:      // to use deferred command buffers - this is here to emulate indirect
../../drivers/cuda/cuda_device.c:            queue_affinity, binding_capacity, &device->block_pool,
../../drivers/cuda/cuda_device.c:            iree_hal_device_allocator(base_device), device->cuda_symbols,
../../drivers/cuda/cuda_device.c:            device->tracing_context, device->cu_context, mode,
../../drivers/cuda/cuda_device.c:            &device->block_pool, device->host_allocator, out_command_buffer);
../../drivers/cuda/cuda_device.c:          queue_affinity, binding_capacity, &device->block_pool,
../../drivers/cuda/cuda_device.c:      identifier, device->cuda_symbols, device->cu_device,
../../drivers/cuda/cuda_device.c:      device->host_allocator, out_executable_cache);
../../drivers/cuda/cuda_device.c:      initial_value, device->cuda_symbols, device->timepoint_pool,
../../drivers/cuda/cuda_device.c:      device->work_queue, device->host_allocator, out_semaphore);
../../drivers/cuda/cuda_device.c:  if (device->supports_memory_pools &&
../../drivers/cuda/cuda_device.c:        &device->memory_pools, device->dispatch_cu_stream, pool, params,
../../drivers/cuda/cuda_device.c:  // Only signal if not returning a synchronous error - synchronous failure
../../drivers/cuda/cuda_device.c:  if (device->supports_memory_pools) {
../../drivers/cuda/cuda_device.c:        &device->memory_pools, device->dispatch_cu_stream, buffer, flags);
../../drivers/cuda/cuda_device.c:  // Only signal if not returning a synchronous error - synchronous failure
../../drivers/cuda/cuda_device.c:      device->work_queue, iree_hal_cuda_device_collect_tracing_context,
../../drivers/cuda/cuda_device.c:      device->tracing_context, wait_semaphore_list, signal_semaphore_list,
../../drivers/cuda/cuda_device.c:    status = iree_hal_deferred_work_queue_issue(device->work_queue);
../../drivers/cuda/cuda_device.c:  iree_status_t status = iree_hal_deferred_work_queue_issue(device->work_queue);
../../drivers/cuda/cuda_device.c:                                            &device->block_pool);
../../drivers/cuda/cuda_buffer.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/cuda_allocator.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/cuda_allocator.c:  // To support device-local + host-visible memory we need concurrent managed
../../drivers/cuda/cuda_allocator.c:  // all device-local + host-visible memory into host-local + device-visible
../../drivers/cuda/cuda_allocator.c:  // page-locked memory. The compiler tries to avoid this for high-traffic
../../drivers/cuda/cuda_allocator.c:                "device-local + host-visible memory)");
../../drivers/cuda/cuda_allocator.c:                               &allocator->resource);
../../drivers/cuda/cuda_allocator.c:  allocator->parent_device = parent_device;
../../drivers/cuda/cuda_allocator.c:  allocator->device = device;
../../drivers/cuda/cuda_allocator.c:  allocator->stream = stream;
../../drivers/cuda/cuda_allocator.c:  allocator->pools = pools;
../../drivers/cuda/cuda_allocator.c:  allocator->symbols = cuda_symbols;
../../drivers/cuda/cuda_allocator.c:  allocator->host_allocator = host_allocator;
../../drivers/cuda/cuda_allocator.c:  allocator->supports_concurrent_managed_access =
../../drivers/cuda/cuda_allocator.c:  allocator->supports_read_only_host_register =
../../drivers/cuda/cuda_allocator.c:  iree_allocator_free(allocator->host_allocator, allocator);
../../drivers/cuda/cuda_allocator.c:  return allocator->host_allocator;
../../drivers/cuda/cuda_allocator.c:    memcpy(out_statistics, &allocator->statistics, sizeof(*out_statistics));
../../drivers/cuda/cuda_allocator.c:    if (allocator->pools) {
../../drivers/cuda/cuda_allocator.c:      iree_hal_cuda_memory_pools_merge_statistics(allocator->pools,
../../drivers/cuda/cuda_allocator.c:  if (allocator->supports_concurrent_managed_access) {
../../drivers/cuda/cuda_allocator.c:    ++count;  // device-local | host-visible
../../drivers/cuda/cuda_allocator.c:    // NOTE: lightweight as this is hit in normal pre-sizing usage.
../../drivers/cuda/cuda_allocator.c:  // page-locked memory and it'd be good to enforce that.
../../drivers/cuda/cuda_allocator.c:  // Device-local memory (dispatch resources):
../../drivers/cuda/cuda_allocator.c:  if (allocator->supports_concurrent_managed_access) {
../../drivers/cuda/cuda_allocator.c:    // Device-local managed memory with host mapping support:
../../drivers/cuda/cuda_allocator.c:  // Write-combined page-locked host-local memory (upload):
../../drivers/cuda/cuda_allocator.c:  // Cached page-locked host-local memory (download):
../../drivers/cuda/cuda_allocator.c:  // self-consistent and just look at whether we can get a device pointer.
../../drivers/cuda/cuda_allocator.c:  if (iree_all_bits_set(params->type, IREE_HAL_MEMORY_TYPE_DEVICE_VISIBLE)) {
../../drivers/cuda/cuda_allocator.c:  if (iree_all_bits_set(params->type, IREE_HAL_MEMORY_TYPE_DEVICE_VISIBLE)) {
../../drivers/cuda/cuda_allocator.c:    if (iree_any_bit_set(params->usage, IREE_HAL_BUFFER_USAGE_TRANSFER)) {
../../drivers/cuda/cuda_allocator.c:    if (iree_any_bit_set(params->usage,
../../drivers/cuda/cuda_allocator.c:  // If concurrent managed access is not supported then make device-local +
../../drivers/cuda/cuda_allocator.c:  // host-visible allocations fall back to host-local + device-visible
../../drivers/cuda/cuda_allocator.c:  // page-locked memory. This will be significantly slower for the device to
../../drivers/cuda/cuda_allocator.c:  if (!allocator->supports_concurrent_managed_access &&
../../drivers/cuda/cuda_allocator.c:      iree_all_bits_set(params->type, IREE_HAL_MEMORY_TYPE_DEVICE_LOCAL |
../../drivers/cuda/cuda_allocator.c:    params->type &= ~(IREE_HAL_MEMORY_TYPE_DEVICE_LOCAL |
../../drivers/cuda/cuda_allocator.c:    params->type |=
../../drivers/cuda/cuda_allocator.c:  params->type &= ~IREE_HAL_MEMORY_TYPE_OPTIMAL;
../../drivers/cuda/cuda_allocator.c:  // application is unlikely to do anything when requesting a 0-byte buffer; but
../../drivers/cuda/cuda_allocator.c:        iree_hal_memory_type_format(params->type, &temp0);
../../drivers/cuda/cuda_allocator.c:        iree_hal_buffer_usage_format(params->usage, &temp1);
../../drivers/cuda/cuda_allocator.c:          allocator->symbols, cuMemAllocManaged(&device_ptr, allocation_size,
../../drivers/cuda/cuda_allocator.c:          allocator->supports_concurrent_managed_access) {
../../drivers/cuda/cuda_allocator.c:            allocator->symbols,
../../drivers/cuda/cuda_allocator.c:            cuMemPrefetchAsync(device_ptr, allocation_size, allocator->device,
../../drivers/cuda/cuda_allocator.c:                               allocator->stream));
../../drivers/cuda/cuda_allocator.c:          allocator->symbols, cuMemAlloc(&device_ptr, allocation_size));
../../drivers/cuda/cuda_allocator.c:        allocator->symbols, cuMemHostAlloc(&host_ptr, allocation_size, flags));
../../drivers/cuda/cuda_allocator.c:          allocator->symbols,
../../drivers/cuda/cuda_allocator.c:        .device = allocator->parent_device,
../../drivers/cuda/cuda_allocator.c:        .queue_affinity = params->queue_affinity ? params->queue_affinity
../../drivers/cuda/cuda_allocator.c:        &allocator->statistics, compat_params.type, allocation_size));
../../drivers/cuda/cuda_allocator.c:      iree_hal_cuda_buffer_free(allocator->symbols, buffer_type, device_ptr,
../../drivers/cuda/cuda_allocator.c:  // buffers. The load on this will be lighter when queue-ordered allocations
../../drivers/cuda/cuda_allocator.c:  // the same way and if we were deallocating this buffer as part of a tear-down
../../drivers/cuda/cuda_allocator.c:  iree_hal_cuda_buffer_free(allocator->symbols, buffer_type,
../../drivers/cuda/cuda_allocator.c:          &allocator->statistics, iree_hal_buffer_memory_type(base_buffer),
../../drivers/cuda/cuda_allocator.c:  iree_hal_cuda_buffer_free(allocator->symbols, buffer_type,
../../drivers/cuda/cuda_allocator.c:          &allocator->statistics, iree_hal_buffer_memory_type(buffer),
../../drivers/cuda/cuda_allocator.c:  iree_device_size_t allocation_size = external_buffer->size;
../../drivers/cuda/cuda_allocator.c:        iree_hal_memory_type_format(params->type, &temp0);
../../drivers/cuda/cuda_allocator.c:        iree_hal_buffer_usage_format(params->usage, &temp1);
../../drivers/cuda/cuda_allocator.c:  switch (external_buffer->type) {
../../drivers/cuda/cuda_allocator.c:            "unable to register host allocations as device-local memory");
../../drivers/cuda/cuda_allocator.c:      host_ptr = external_buffer->handle.host_allocation.ptr;
../../drivers/cuda/cuda_allocator.c:          allocator->supports_read_only_host_register) {
../../drivers/cuda/cuda_allocator.c:          allocator->symbols,
../../drivers/cuda/cuda_allocator.c:          cuMemHostRegister(host_ptr, external_buffer->size, register_flags),
../../drivers/cuda/cuda_allocator.c:            allocator->symbols,
../../drivers/cuda/cuda_allocator.c:      device_ptr = (CUdeviceptr)external_buffer->handle.device_allocation.ptr;
../../drivers/cuda/cuda_allocator.c:                              "handle-based imports not yet implemented");
../../drivers/cuda/cuda_allocator.c:        .device = allocator->parent_device,
../../drivers/cuda/cuda_allocator.c:        .queue_affinity = params->queue_affinity ? params->queue_affinity
../../drivers/cuda/cuda_allocator.c:        compat_params.usage, external_buffer->size, /*byte_offset=*/0,
../../drivers/cuda/cuda_allocator.c:        /*byte_length=*/external_buffer->size, buffer_type, device_ptr,
../../drivers/cuda/cuda_allocator.c:      iree_hal_cuda_buffer_free(allocator->symbols, buffer_type, device_ptr,
../../drivers/cuda/cuda_allocator.c:          out_external_buffer->flags = requested_flags;
../../drivers/cuda/cuda_allocator.c:          out_external_buffer->type = requested_type;
../../drivers/cuda/cuda_allocator.c:          out_external_buffer->handle.device_allocation.ptr =
../../drivers/cuda/cuda_allocator.c:          out_external_buffer->size = iree_hal_buffer_allocation_size(buffer);
../../drivers/cuda/cuda_dynamic_symbols.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/cuda_dynamic_symbols.h:// Initializes |out_syms| in-place with dynamically loaded CUDA symbols.
../../drivers/cuda/graph_command_buffer.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/graph_command_buffer.c:  // Per-stream CUDA tracing context.
../../drivers/cuda/graph_command_buffer.c:  // Staging arena used for host->device transfers.
../../drivers/cuda/graph_command_buffer.c:  if (IREE_UNLIKELY(command_buffer->graph_node_count != 0)) {
../../drivers/cuda/graph_command_buffer.c:      &command_buffer->cu_graph_nodes[command_buffer->graph_node_count++];
../../drivers/cuda/graph_command_buffer.c:  size_t dependency_count = command_buffer->cu_barrier_node ? 1 : 0;
../../drivers/cuda/graph_command_buffer.c:      command_buffer->tracing_context, &command_buffer->tracing_event_list,
../../drivers/cuda/graph_command_buffer.c:      (iree_hal_stream_tracing_native_graph_t*)command_buffer->cu_graph,
../../drivers/cuda/graph_command_buffer.c:          ->cu_barrier_node,
../../drivers/cuda/graph_command_buffer.c:  command_buffer->cu_barrier_node = *tracing_event_node;
../../drivers/cuda/graph_command_buffer.c:  if (IREE_UNLIKELY(command_buffer->graph_node_count != 0)) {
../../drivers/cuda/graph_command_buffer.c:      &command_buffer->cu_graph_nodes[command_buffer->graph_node_count++];
../../drivers/cuda/graph_command_buffer.c:  size_t dependency_count = command_buffer->cu_barrier_node ? 1 : 0;
../../drivers/cuda/graph_command_buffer.c:      command_buffer->tracing_context, &command_buffer->tracing_event_list,
../../drivers/cuda/graph_command_buffer.c:      (iree_hal_stream_tracing_native_graph_t*)command_buffer->cu_graph,
../../drivers/cuda/graph_command_buffer.c:          ->cu_barrier_node,
../../drivers/cuda/graph_command_buffer.c:  // GPU tracing zones are first-in, last-out.
../../drivers/cuda/graph_command_buffer.c:  command_buffer->cu_barrier_node = *tracing_event_node;
../../drivers/cuda/graph_command_buffer.c:      &iree_hal_cuda_graph_command_buffer_vtable, &command_buffer->base);
../../drivers/cuda/graph_command_buffer.c:  command_buffer->host_allocator = host_allocator;
../../drivers/cuda/graph_command_buffer.c:  command_buffer->symbols = cuda_symbols;
../../drivers/cuda/graph_command_buffer.c:  command_buffer->tracing_context = tracing_context;
../../drivers/cuda/graph_command_buffer.c:  command_buffer->tracing_event_list.head = NULL;
../../drivers/cuda/graph_command_buffer.c:  command_buffer->tracing_event_list.tail = NULL;
../../drivers/cuda/graph_command_buffer.c:  iree_arena_initialize(block_pool, &command_buffer->arena);
../../drivers/cuda/graph_command_buffer.c:  command_buffer->cu_context = context;
../../drivers/cuda/graph_command_buffer.c:  command_buffer->cu_graph = NULL;
../../drivers/cuda/graph_command_buffer.c:  command_buffer->cu_graph_exec = NULL;
../../drivers/cuda/graph_command_buffer.c:  command_buffer->cu_barrier_node = NULL;
../../drivers/cuda/graph_command_buffer.c:  command_buffer->graph_node_count = 0;
../../drivers/cuda/graph_command_buffer.c:      iree_hal_resource_set_allocate(block_pool, &command_buffer->resource_set);
../../drivers/cuda/graph_command_buffer.c:    iree_hal_collective_batch_initialize(&command_buffer->arena,
../../drivers/cuda/graph_command_buffer.c:                                         command_buffer->resource_set,
../../drivers/cuda/graph_command_buffer.c:                                         &command_buffer->collective_batch);
../../drivers/cuda/graph_command_buffer.c:    *out_command_buffer = &command_buffer->base;
../../drivers/cuda/graph_command_buffer.c:    iree_hal_command_buffer_release(&command_buffer->base);
../../drivers/cuda/graph_command_buffer.c:  iree_allocator_t host_allocator = command_buffer->host_allocator;
../../drivers/cuda/graph_command_buffer.c:  iree_hal_stream_tracing_free(command_buffer->tracing_context,
../../drivers/cuda/graph_command_buffer.c:                               &command_buffer->tracing_event_list);
../../drivers/cuda/graph_command_buffer.c:  iree_hal_collective_batch_clear(&command_buffer->collective_batch);
../../drivers/cuda/graph_command_buffer.c:  if (command_buffer->cu_graph != NULL) {
../../drivers/cuda/graph_command_buffer.c:    IREE_CUDA_IGNORE_ERROR(command_buffer->symbols,
../../drivers/cuda/graph_command_buffer.c:                           cuGraphDestroy(command_buffer->cu_graph));
../../drivers/cuda/graph_command_buffer.c:    command_buffer->cu_graph = NULL;
../../drivers/cuda/graph_command_buffer.c:  if (command_buffer->cu_graph_exec != NULL) {
../../drivers/cuda/graph_command_buffer.c:    IREE_CUDA_IGNORE_ERROR(command_buffer->symbols,
../../drivers/cuda/graph_command_buffer.c:                           cuGraphExecDestroy(command_buffer->cu_graph_exec));
../../drivers/cuda/graph_command_buffer.c:    command_buffer->cu_graph_exec = NULL;
../../drivers/cuda/graph_command_buffer.c:  command_buffer->cu_barrier_node = NULL;
../../drivers/cuda/graph_command_buffer.c:  command_buffer->graph_node_count = 0;
../../drivers/cuda/graph_command_buffer.c:  iree_hal_collective_batch_deinitialize(&command_buffer->collective_batch);
../../drivers/cuda/graph_command_buffer.c:  iree_hal_resource_set_free(command_buffer->resource_set);
../../drivers/cuda/graph_command_buffer.c:  iree_arena_deinitialize(&command_buffer->arena);
../../drivers/cuda/graph_command_buffer.c:  return iree_hal_resource_is(&command_buffer->resource,
../../drivers/cuda/graph_command_buffer.c:  return command_buffer->cu_graph_exec;
../../drivers/cuda/graph_command_buffer.c:  if (!command_buffer->tracing_context) {
../../drivers/cuda/graph_command_buffer.c:  iree_hal_stream_tracing_notify_submitted(command_buffer->tracing_context,
../../drivers/cuda/graph_command_buffer.c:                                           &command_buffer->tracing_event_list);
../../drivers/cuda/graph_command_buffer.c:// Must be called before any other non-collective nodes are added to the graph
../../drivers/cuda/graph_command_buffer.c:  // NOTE: we could move this out into callers by way of an always-inline shim -
../../drivers/cuda/graph_command_buffer.c:          &command_buffer->collective_batch))) {
../../drivers/cuda/graph_command_buffer.c:  // https://docs.nvidia.com/deeplearning/nccl/user-guide/docs/usage/cudagraph.html
../../drivers/cuda/graph_command_buffer.c:  //  syms->cuStreamBeginCapture(nccl_stream);
../../drivers/cuda/graph_command_buffer.c:  //  iree_hal_cuda_nccl_submit_batch(command_buffer->context,
../../drivers/cuda/graph_command_buffer.c:  //                                  &command_buffer->collective_batch,
../../drivers/cuda/graph_command_buffer.c:  //  syms->cuStreamEndCapture(nccl_stream, &child_graph);
../../drivers/cuda/graph_command_buffer.c:  //  syms->cuGraphAddChildGraphNode(..., child_graph);
../../drivers/cuda/graph_command_buffer.c:  //  syms->cuGraphDestroy(child_graph);  // probably, I think it gets cloned
../../drivers/cuda/graph_command_buffer.c:  // capture - we could memoize that on the command buffer or on the device
../../drivers/cuda/graph_command_buffer.c:  // stream mode for these capture-only streams that is lighter weight than a
../../drivers/cuda/graph_command_buffer.c:  iree_hal_collective_batch_clear(&command_buffer->collective_batch);
../../drivers/cuda/graph_command_buffer.c:  if (command_buffer->cu_graph != NULL) {
../../drivers/cuda/graph_command_buffer.c:                            "command buffer cannot be re-recorded");
../../drivers/cuda/graph_command_buffer.c:      command_buffer->symbols,
../../drivers/cuda/graph_command_buffer.c:      cuGraphCreate(&command_buffer->cu_graph, /*flags=*/0), "cuGraphCreate");
../../drivers/cuda/graph_command_buffer.c:  command_buffer->cu_barrier_node = NULL;
../../drivers/cuda/graph_command_buffer.c:  command_buffer->graph_node_count = 0;
../../drivers/cuda/graph_command_buffer.c:      command_buffer->symbols,
../../drivers/cuda/graph_command_buffer.c:      cuGraphInstantiate(&command_buffer->cu_graph_exec,
../../drivers/cuda/graph_command_buffer.c:                         command_buffer->cu_graph, &error_node,
../../drivers/cuda/graph_command_buffer.c:    IREE_CUDA_IGNORE_ERROR(command_buffer->symbols,
../../drivers/cuda/graph_command_buffer.c:                           cuGraphDestroy(command_buffer->cu_graph));
../../drivers/cuda/graph_command_buffer.c:    command_buffer->cu_graph = NULL;
../../drivers/cuda/graph_command_buffer.c:  iree_hal_resource_set_freeze(command_buffer->resource_set);
../../drivers/cuda/graph_command_buffer.c:      location ? location->file.data : NULL, location ? location->file.size : 0,
../../drivers/cuda/graph_command_buffer.c:      location ? location->line : 0,
../../drivers/cuda/graph_command_buffer.c:  IREE_ASSERT_GT(command_buffer->graph_node_count, 0,
../../drivers/cuda/graph_command_buffer.c:  if (IREE_LIKELY(command_buffer->graph_node_count == 1)) {
../../drivers/cuda/graph_command_buffer.c:    command_buffer->cu_barrier_node = command_buffer->cu_graph_nodes[0];
../../drivers/cuda/graph_command_buffer.c:    command_buffer->graph_node_count = 0;
../../drivers/cuda/graph_command_buffer.c:      command_buffer->symbols,
../../drivers/cuda/graph_command_buffer.c:          &command_buffer->cu_barrier_node, command_buffer->cu_graph,
../../drivers/cuda/graph_command_buffer.c:          command_buffer->cu_graph_nodes, command_buffer->graph_node_count),
../../drivers/cuda/graph_command_buffer.c:  command_buffer->graph_node_count = 0;
../../drivers/cuda/graph_command_buffer.c:      z0, iree_hal_resource_set_insert(command_buffer->resource_set, 1,
../../drivers/cuda/graph_command_buffer.c:  if (command_buffer->graph_node_count >=
../../drivers/cuda/graph_command_buffer.c:  size_t dependency_count = command_buffer->cu_barrier_node ? 1 : 0;
../../drivers/cuda/graph_command_buffer.c:      z0, command_buffer->symbols,
../../drivers/cuda/graph_command_buffer.c:          &command_buffer->cu_graph_nodes[command_buffer->graph_node_count++],
../../drivers/cuda/graph_command_buffer.c:          command_buffer->cu_graph, &command_buffer->cu_barrier_node,
../../drivers/cuda/graph_command_buffer.c:          dependency_count, &params, command_buffer->cu_context),
../../drivers/cuda/graph_command_buffer.c:      z0, iree_arena_allocate(&command_buffer->arena, target_ref.length,
../../drivers/cuda/graph_command_buffer.c:      z0, iree_hal_resource_set_insert(command_buffer->resource_set, 1,
../../drivers/cuda/graph_command_buffer.c:  if (command_buffer->graph_node_count >=
../../drivers/cuda/graph_command_buffer.c:  size_t dependency_count = command_buffer->cu_barrier_node ? 1 : 0;
../../drivers/cuda/graph_command_buffer.c:      z0, command_buffer->symbols,
../../drivers/cuda/graph_command_buffer.c:          &command_buffer->cu_graph_nodes[command_buffer->graph_node_count++],
../../drivers/cuda/graph_command_buffer.c:          command_buffer->cu_graph, &command_buffer->cu_barrier_node,
../../drivers/cuda/graph_command_buffer.c:          dependency_count, &params, command_buffer->cu_context),
../../drivers/cuda/graph_command_buffer.c:      z0, iree_hal_resource_set_insert(command_buffer->resource_set,
../../drivers/cuda/graph_command_buffer.c:  if (command_buffer->graph_node_count >=
../../drivers/cuda/graph_command_buffer.c:  size_t dependency_count = command_buffer->cu_barrier_node ? 1 : 0;
../../drivers/cuda/graph_command_buffer.c:      z0, command_buffer->symbols,
../../drivers/cuda/graph_command_buffer.c:          &command_buffer->cu_graph_nodes[command_buffer->graph_node_count++],
../../drivers/cuda/graph_command_buffer.c:          command_buffer->cu_graph, &command_buffer->cu_barrier_node,
../../drivers/cuda/graph_command_buffer.c:          dependency_count, &params, command_buffer->cu_context),
../../drivers/cuda/graph_command_buffer.c:  return iree_hal_collective_batch_append(&command_buffer->collective_batch,
../../drivers/cuda/graph_command_buffer.c:  // Lookup kernel parameters used for side-channeling additional launch
../../drivers/cuda/graph_command_buffer.c:      kernel_params->debug_info.source_filename.data,
../../drivers/cuda/graph_command_buffer.c:      kernel_params->debug_info.source_filename.size,
../../drivers/cuda/graph_command_buffer.c:      kernel_params->debug_info.source_line,
../../drivers/cuda/graph_command_buffer.c:      kernel_params->debug_info.function_name.data,
../../drivers/cuda/graph_command_buffer.c:      kernel_params->debug_info.function_name.size, /*name=*/NULL, 0);
../../drivers/cuda/graph_command_buffer.c:      z0, iree_hal_resource_set_insert(command_buffer->resource_set, 1,
../../drivers/cuda/graph_command_buffer.c:      kernel_params->binding_count + kernel_params->constant_count;
../../drivers/cuda/graph_command_buffer.c:  // TODO: use packed parameters instead of the indirection mechanism - this
../../drivers/cuda/graph_command_buffer.c:  //   of N pointers. Each pointer, from kernelParams[0] to kernelParams[N-1],
../../drivers/cuda/graph_command_buffer.c:  // https://docs.nvidia.com/cuda/cuda-driver-api/group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g50d871e3bd06c1b835e52f2966ef366b)
../../drivers/cuda/graph_command_buffer.c:      z0, iree_arena_allocate(&command_buffer->arena, total_size,
../../drivers/cuda/graph_command_buffer.c:    if (binding->buffer) {
../../drivers/cuda/graph_command_buffer.c:          z0, iree_hal_resource_set_insert(command_buffer->resource_set, 1,
../../drivers/cuda/graph_command_buffer.c:                                           &binding->buffer));
../../drivers/cuda/graph_command_buffer.c:          iree_hal_buffer_allocated_buffer(binding->buffer));
../../drivers/cuda/graph_command_buffer.c:      iree_device_size_t offset = iree_hal_buffer_byte_offset(binding->buffer);
../../drivers/cuda/graph_command_buffer.c:      device_ptr = device_buffer + offset + binding->offset;
../../drivers/cuda/graph_command_buffer.c:  // just storing a 32-bit value for the push constant here instead. So we must
../../drivers/cuda/graph_command_buffer.c:  // process one element each type, for 64-bit machines.
../../drivers/cuda/graph_command_buffer.c:  for (iree_host_size_t i = 0; i < kernel_params->constant_count; i++) {
../../drivers/cuda/graph_command_buffer.c:    *((uint32_t*)params_ptr[kernel_params->binding_count + i]) =
../../drivers/cuda/graph_command_buffer.c:      .func = kernel_params->function,
../../drivers/cuda/graph_command_buffer.c:                                            : kernel_params->block_dims[0],
../../drivers/cuda/graph_command_buffer.c:                                            : kernel_params->block_dims[1],
../../drivers/cuda/graph_command_buffer.c:                                            : kernel_params->block_dims[2],
../../drivers/cuda/graph_command_buffer.c:      .sharedMemBytes = kernel_params->block_shared_memory_size,
../../drivers/cuda/graph_command_buffer.c:  if (command_buffer->graph_node_count >=
../../drivers/cuda/graph_command_buffer.c:  size_t dependency_count = command_buffer->cu_barrier_node ? 1 : 0;
../../drivers/cuda/graph_command_buffer.c:      z0, command_buffer->symbols,
../../drivers/cuda/graph_command_buffer.c:          &command_buffer->cu_graph_nodes[command_buffer->graph_node_count++],
../../drivers/cuda/graph_command_buffer.c:          command_buffer->cu_graph, &command_buffer->cu_barrier_node,
../../drivers/cuda/memory_pools.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/memory_pools.c:// device-specific ones by malloc() and leaking (with LSAN note) unique string
../../drivers/cuda/memory_pools.c:    "CUDA pool: device-local reserved";
../../drivers/cuda/memory_pools.c:  out_pools->parent_device = parent_device;
../../drivers/cuda/memory_pools.c:  out_pools->cuda_symbols = cuda_symbols;
../../drivers/cuda/memory_pools.c:  out_pools->host_allocator = host_allocator;
../../drivers/cuda/memory_pools.c:                                              pooling_params->device_local,
../../drivers/cuda/memory_pools.c:                                              &out_pools->device_local);
../../drivers/cuda/memory_pools.c:        cuda_symbols, cu_device, pooling_params->other, &out_pools->other);
../../drivers/cuda/memory_pools.c:  if (pools->device_local) {
../../drivers/cuda/memory_pools.c:    IREE_CUDA_IGNORE_ERROR(pools->cuda_symbols,
../../drivers/cuda/memory_pools.c:                           cuMemPoolDestroy(pools->device_local));
../../drivers/cuda/memory_pools.c:    pools->device_local = NULL;
../../drivers/cuda/memory_pools.c:  if (pools->other) {
../../drivers/cuda/memory_pools.c:    IREE_CUDA_IGNORE_ERROR(pools->cuda_symbols, cuMemPoolDestroy(pools->other));
../../drivers/cuda/memory_pools.c:    pools->other = NULL;
../../drivers/cuda/memory_pools.c:        is_device_local ? &pools->statistics.device_bytes_allocated
../../drivers/cuda/memory_pools.c:                        : &pools->statistics.host_bytes_allocated;
../../drivers/cuda/memory_pools.c:        is_device_local ? &pools->statistics.device_bytes_freed
../../drivers/cuda/memory_pools.c:                        : &pools->statistics.host_bytes_freed;
../../drivers/cuda/memory_pools.c:    statistics->device_bytes_allocated = iree_atomic_load(
../../drivers/cuda/memory_pools.c:        &pools->statistics.device_bytes_allocated, iree_memory_order_relaxed);
../../drivers/cuda/memory_pools.c:    statistics->host_bytes_allocated = iree_atomic_load(
../../drivers/cuda/memory_pools.c:        &pools->statistics.host_bytes_allocated, iree_memory_order_relaxed);
../../drivers/cuda/memory_pools.c:    statistics->device_bytes_freed = iree_atomic_load(
../../drivers/cuda/memory_pools.c:        &pools->statistics.device_bytes_freed, iree_memory_order_relaxed);
../../drivers/cuda/memory_pools.c:    statistics->host_bytes_freed = iree_atomic_load(
../../drivers/cuda/memory_pools.c:        &pools->statistics.host_bytes_freed, iree_memory_order_relaxed);
../../drivers/cuda/memory_pools.c:    if (pools->device_local) {
../../drivers/cuda/memory_pools.c:          pools->cuda_symbols,
../../drivers/cuda/memory_pools.c:          cuMemPoolGetAttribute(pools->device_local,
../../drivers/cuda/memory_pools.c:      statistics->device_bytes_peak += (iree_device_size_t)pool_peak;
../../drivers/cuda/memory_pools.c:    if (pools->other) {
../../drivers/cuda/memory_pools.c:          pools->cuda_symbols,
../../drivers/cuda/memory_pools.c:          cuMemPoolGetAttribute(pools->other, CU_MEMPOOL_ATTR_USED_MEM_HIGH,
../../drivers/cuda/memory_pools.c:      statistics->host_bytes_peak += (iree_device_size_t)pool_peak;
../../drivers/cuda/memory_pools.c:      pools->cuda_symbols,
../../drivers/cuda/memory_pools.c:      cuMemPoolTrimTo(pools->device_local,
../../drivers/cuda/memory_pools.c:                      pooling_params->device_local.minimum_capacity),
../../drivers/cuda/memory_pools.c:      pools->cuda_symbols,
../../drivers/cuda/memory_pools.c:      cuMemPoolTrimTo(pools->other, pooling_params->other.minimum_capacity),
../../drivers/cuda/memory_pools.c:// the release callback so that this isn't called and we don't double-free.
../../drivers/cuda/memory_pools.c:  IREE_CUDA_IGNORE_ERROR(pools->cuda_symbols, cuMemFree(device_ptr));
../../drivers/cuda/memory_pools.c:          ? pools->device_local
../../drivers/cuda/memory_pools.c:          : pools->other;
../../drivers/cuda/memory_pools.c:      pools->cuda_symbols,
../../drivers/cuda/memory_pools.c:        .device = pools->parent_device,
../../drivers/cuda/memory_pools.c:        device_ptr, /*host_ptr=*/NULL, release_callback, pools->host_allocator,
../../drivers/cuda/memory_pools.c:    IREE_CUDA_IGNORE_ERROR(pools->cuda_symbols,
../../drivers/cuda/memory_pools.c:    status = IREE_CURESULT_TO_STATUS(pools->cuda_symbols,
../../drivers/cuda/memory_pools.c:      // Drop the release callback so that we don't try to double-free the
../../drivers/metal/executable.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/metal/executable.h://===----------------------------------------------------------------------===//
../../drivers/metal/executable.h://===----------------------------------------------------------------------===//
../../drivers/metal/executable.h:// - Argument buffer tier 1 binding limits:
../../drivers/metal/executable.h://   - iOS: 31 buffers (on A11 and later, 96 buffers)
../../drivers/metal/executable.h://   - macOS: 64 buffers
../../drivers/metal/executable.h:// - Argument buffer tier 2 binding limits:
../../drivers/metal/executable.h://   - 500,000 buffers or textures
../../drivers/metal/executable.h:// setting up resource location attributes during cross compiling SPIR-V to MSL.
../../drivers/metal/executable.h:  (IREE_HAL_METAL_MAX_DESCRIPTOR_SET_COUNT - 1)
../../drivers/metal/executable.h://===----------------------------------------------------------------------===//
../../drivers/metal/executable.h://===----------------------------------------------------------------------===//
../../drivers/metal/executable.h:  // Total number of 32-bit constants.
../../drivers/metal/executable.h:  // One bit per binding indicating whether it is read-only.
../../drivers/metal/CMakeLists.txt:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/metal/CMakeLists.txt:    "-framework Foundation"
../../drivers/metal/CMakeLists.txt:    "-framework Metal"
../../drivers/cuda/graph_command_buffer.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/graph_command_buffer.h:// Returns true if |command_buffer| is a CUDA graph-based command buffer.
../../drivers/cuda/nccl_channel.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/nccl_channel.c:  // guaranteed to be unique - only use for informational purposes.
../../drivers/cuda/nccl_channel.c:    hash += id->data[i];
../../drivers/cuda/nccl_channel.c:                               &channel->resource);
../../drivers/cuda/nccl_channel.c:  channel->cuda_symbols = cuda_symbols;
../../drivers/cuda/nccl_channel.c:  channel->nccl_symbols = nccl_symbols;
../../drivers/cuda/nccl_channel.c:  channel->host_allocator = host_allocator;
../../drivers/cuda/nccl_channel.c:  channel->parent_channel = NULL;
../../drivers/cuda/nccl_channel.c:  channel->rank = rank;
../../drivers/cuda/nccl_channel.c:  channel->count = count;
../../drivers/cuda/nccl_channel.c:  channel->comm = comm;
../../drivers/cuda/nccl_channel.c:  IREE_TRACE(channel->id_hash = id_hash);
../../drivers/cuda/nccl_channel.c:  IREE_TRACE_ZONE_APPEND_VALUE_I64(z0, channel->id_hash);
../../drivers/cuda/nccl_channel.c:  IREE_TRACE_ZONE_APPEND_VALUE_I64(z0, channel->rank);
../../drivers/cuda/nccl_channel.c:  IREE_TRACE_ZONE_APPEND_VALUE_I64(z0, channel->count);
../../drivers/cuda/nccl_channel.c:  iree_allocator_t host_allocator = channel->host_allocator;
../../drivers/cuda/nccl_channel.c:  //   ncclCommFinalize(channel->comm);  // non-blocking!
../../drivers/cuda/nccl_channel.c:  //   ncclCommDestroy(channel->comm)
../../drivers/cuda/nccl_channel.c:  //   ncclCommDestroy(channel->comm)
../../drivers/cuda/nccl_channel.c:  IREE_NCCL_IGNORE_ERROR(channel->nccl_symbols,
../../drivers/cuda/nccl_channel.c:                         ncclCommFinalize(channel->comm));
../../drivers/cuda/nccl_channel.c:  IREE_NCCL_IGNORE_ERROR(channel->nccl_symbols, ncclCommDestroy(channel->comm));
../../drivers/cuda/nccl_channel.c:  iree_hal_channel_release(channel->parent_channel);
../../drivers/cuda/nccl_channel.c:  // TODO: see if we need to set the sharing config - we may always want to.
../../drivers/cuda/nccl_channel.c:      channel->nccl_symbols,
../../drivers/cuda/nccl_channel.c:      ncclCommSplit(channel->comm, color, key, &split_comm, &config),
../../drivers/cuda/nccl_channel.c:      channel->nccl_symbols, ncclCommUserRank(split_comm, &split_rank),
../../drivers/cuda/nccl_channel.c:    status = IREE_NCCL_RESULT_TO_STATUS(channel->nccl_symbols,
../../drivers/cuda/nccl_channel.c:        iree_allocator_malloc(channel->host_allocator, sizeof(*split_channel),
../../drivers/cuda/nccl_channel.c:                                 &split_channel->resource);
../../drivers/cuda/nccl_channel.c:    split_channel->cuda_symbols = channel->cuda_symbols;
../../drivers/cuda/nccl_channel.c:    split_channel->nccl_symbols = channel->nccl_symbols;
../../drivers/cuda/nccl_channel.c:    split_channel->host_allocator = channel->host_allocator;
../../drivers/cuda/nccl_channel.c:    split_channel->parent_channel = base_channel;
../../drivers/cuda/nccl_channel.c:    split_channel->rank = split_rank;
../../drivers/cuda/nccl_channel.c:    split_channel->count = split_count;
../../drivers/cuda/nccl_channel.c:    split_channel->comm = split_comm;
../../drivers/cuda/nccl_channel.c:    IREE_NCCL_IGNORE_ERROR(channel->nccl_symbols, ncclCommDestroy(split_comm));
../../drivers/cuda/nccl_channel.c:  // NOTE: since it's cheap we keep rank/count local - this lets us trace them
../../drivers/cuda/nccl_channel.c:  *out_rank = channel->rank;
../../drivers/cuda/nccl_channel.c:  *out_count = channel->count;
../../drivers/cuda/nccl_channel.c:  return channel->comm;
../../drivers/cuda/nccl_channel.c:      iree_hal_cuda_nccl_channel_cast(entry->channel);
../../drivers/cuda/nccl_channel.c:  const iree_hal_cuda_nccl_dynamic_symbols_t* symbols = channel->nccl_symbols;
../../drivers/cuda/nccl_channel.c:  ncclComm_t comm = iree_hal_cuda_nccl_channel_comm(entry->channel);
../../drivers/cuda/nccl_channel.c:      iree_hal_cuda_get_nccl_data_type(entry->op.element_type, &datatype));
../../drivers/cuda/nccl_channel.c:  switch (entry->op.kind) {
../../drivers/cuda/nccl_channel.c:              iree_hal_buffer_allocated_buffer(entry->send_binding.buffer)) +
../../drivers/cuda/nccl_channel.c:          iree_hal_buffer_byte_offset(entry->send_binding.buffer) +
../../drivers/cuda/nccl_channel.c:          entry->send_binding.offset;
../../drivers/cuda/nccl_channel.c:              iree_hal_buffer_allocated_buffer(entry->recv_binding.buffer)) +
../../drivers/cuda/nccl_channel.c:          iree_hal_buffer_byte_offset(entry->recv_binding.buffer) +
../../drivers/cuda/nccl_channel.c:          entry->recv_binding.offset;
../../drivers/cuda/nccl_channel.c:                        entry->element_count, datatype, comm, stream),
../../drivers/cuda/nccl_channel.c:              iree_hal_buffer_allocated_buffer(entry->send_binding.buffer)) +
../../drivers/cuda/nccl_channel.c:          iree_hal_buffer_byte_offset(entry->send_binding.buffer) +
../../drivers/cuda/nccl_channel.c:          entry->send_binding.offset;
../../drivers/cuda/nccl_channel.c:              iree_hal_buffer_allocated_buffer(entry->recv_binding.buffer)) +
../../drivers/cuda/nccl_channel.c:          iree_hal_buffer_byte_offset(entry->recv_binding.buffer) +
../../drivers/cuda/nccl_channel.c:          entry->recv_binding.offset;
../../drivers/cuda/nccl_channel.c:          iree_hal_cuda_get_nccl_reduction_type(entry->op.reduction, &redop));
../../drivers/cuda/nccl_channel.c:                        entry->element_count, datatype, redop, comm, stream),
../../drivers/cuda/nccl_channel.c:              iree_hal_buffer_allocated_buffer(entry->send_binding.buffer)) +
../../drivers/cuda/nccl_channel.c:          iree_hal_buffer_byte_offset(entry->send_binding.buffer) +
../../drivers/cuda/nccl_channel.c:          entry->send_binding.offset;
../../drivers/cuda/nccl_channel.c:              iree_hal_buffer_allocated_buffer(entry->recv_binding.buffer)) +
../../drivers/cuda/nccl_channel.c:          iree_hal_buffer_byte_offset(entry->recv_binding.buffer) +
../../drivers/cuda/nccl_channel.c:          entry->recv_binding.offset;
../../drivers/cuda/nccl_channel.c:      iree_device_size_t send_count = entry->element_count / channel->count;
../../drivers/cuda/nccl_channel.c:          iree_hal_collective_element_byte_count(entry->op.element_type);
../../drivers/cuda/nccl_channel.c:      for (iree_host_size_t r = 0; r < channel->count; ++r) {
../../drivers/cuda/nccl_channel.c:              iree_hal_buffer_allocated_buffer(entry->send_binding.buffer)) +
../../drivers/cuda/nccl_channel.c:          iree_hal_buffer_byte_offset(entry->send_binding.buffer) +
../../drivers/cuda/nccl_channel.c:          entry->send_binding.offset;
../../drivers/cuda/nccl_channel.c:              iree_hal_buffer_allocated_buffer(entry->recv_binding.buffer)) +
../../drivers/cuda/nccl_channel.c:          iree_hal_buffer_byte_offset(entry->recv_binding.buffer) +
../../drivers/cuda/nccl_channel.c:          entry->recv_binding.offset;
../../drivers/cuda/nccl_channel.c:                        entry->element_count, datatype, entry->param, comm,
../../drivers/cuda/nccl_channel.c:              iree_hal_buffer_allocated_buffer(entry->send_binding.buffer)) +
../../drivers/cuda/nccl_channel.c:          iree_hal_buffer_byte_offset(entry->send_binding.buffer) +
../../drivers/cuda/nccl_channel.c:          entry->send_binding.offset;
../../drivers/cuda/nccl_channel.c:              iree_hal_buffer_allocated_buffer(entry->recv_binding.buffer)) +
../../drivers/cuda/nccl_channel.c:          iree_hal_buffer_byte_offset(entry->recv_binding.buffer) +
../../drivers/cuda/nccl_channel.c:          entry->recv_binding.offset;
../../drivers/cuda/nccl_channel.c:          iree_hal_cuda_get_nccl_reduction_type(entry->op.reduction, &redop));
../../drivers/cuda/nccl_channel.c:                     entry->element_count, datatype, redop, entry->param, comm,
../../drivers/cuda/nccl_channel.c:              iree_hal_buffer_allocated_buffer(entry->send_binding.buffer)) +
../../drivers/cuda/nccl_channel.c:          iree_hal_buffer_byte_offset(entry->send_binding.buffer) +
../../drivers/cuda/nccl_channel.c:          entry->send_binding.offset;
../../drivers/cuda/nccl_channel.c:              iree_hal_buffer_allocated_buffer(entry->recv_binding.buffer)) +
../../drivers/cuda/nccl_channel.c:          iree_hal_buffer_byte_offset(entry->recv_binding.buffer) +
../../drivers/cuda/nccl_channel.c:          entry->recv_binding.offset;
../../drivers/cuda/nccl_channel.c:          iree_hal_cuda_get_nccl_reduction_type(entry->op.reduction, &redop));
../../drivers/cuda/nccl_channel.c:                            entry->element_count, datatype, redop, comm,
../../drivers/cuda/nccl_channel.c:              iree_hal_buffer_allocated_buffer(entry->send_binding.buffer)) +
../../drivers/cuda/nccl_channel.c:          iree_hal_buffer_byte_offset(entry->send_binding.buffer) +
../../drivers/cuda/nccl_channel.c:          entry->send_binding.offset;
../../drivers/cuda/nccl_channel.c:          ncclSend((const void*)sendbuff, entry->element_count, datatype,
../../drivers/cuda/nccl_channel.c:                   entry->param, comm, stream),
../../drivers/cuda/nccl_channel.c:              iree_hal_buffer_allocated_buffer(entry->recv_binding.buffer)) +
../../drivers/cuda/nccl_channel.c:          iree_hal_buffer_byte_offset(entry->recv_binding.buffer) +
../../drivers/cuda/nccl_channel.c:          entry->recv_binding.offset;
../../drivers/cuda/nccl_channel.c:                                ncclRecv((void*)recvbuff, entry->element_count,
../../drivers/cuda/nccl_channel.c:                                         datatype, entry->param, comm, stream),
../../drivers/cuda/nccl_channel.c:              iree_hal_buffer_allocated_buffer(entry->send_binding.buffer)) +
../../drivers/cuda/nccl_channel.c:          iree_hal_buffer_byte_offset(entry->send_binding.buffer) +
../../drivers/cuda/nccl_channel.c:          entry->send_binding.offset;
../../drivers/cuda/nccl_channel.c:              iree_hal_buffer_allocated_buffer(entry->recv_binding.buffer)) +
../../drivers/cuda/nccl_channel.c:          iree_hal_buffer_byte_offset(entry->recv_binding.buffer) +
../../drivers/cuda/nccl_channel.c:          entry->recv_binding.offset;
../../drivers/cuda/nccl_channel.c:      memcpy(&sendid, &entry->param, 2);
../../drivers/cuda/nccl_channel.c:      memcpy(&recvid, (char*)&entry->param + 2, 2);
../../drivers/cuda/nccl_channel.c:      if (sendid != -1) {
../../drivers/cuda/nccl_channel.c:            ncclSend((const void*)sendbuff, entry->element_count, datatype,
../../drivers/cuda/nccl_channel.c:      if (recvid != -1) {
../../drivers/cuda/nccl_channel.c:            ncclRecv((void*)recvbuff, entry->element_count, datatype, recvid,
../../drivers/cuda/nccl_channel.c:            entry->element_count *
../../drivers/cuda/nccl_channel.c:            iree_hal_collective_element_byte_count(entry->op.element_type);
../../drivers/cuda/nccl_channel.c:            channel->cuda_symbols,
../../drivers/cuda/nccl_channel.c:  for (iree_host_size_t i = 0; i < batch->count; ++i) {
../../drivers/cuda/nccl_channel.c:    iree_hal_collective_batch_entry_t* entry = &batch->entries[i];
../../drivers/cuda/nccl_channel.c:        iree_hal_collective_op_format(&entry->op, &string_temp);
../../drivers/cuda/nccl_channel.c:  for (iree_host_size_t i = 0; i < batch->count; ++i) {
../../drivers/cuda/nccl_channel.c:        iree_hal_cuda_nccl_submit_batch_entry(&batch->entries[i], stream));
../../drivers/cuda/nccl_channel.c:  // End all zones we began above - note that these are just simply nested so
../../drivers/cuda/nccl_channel.c:  for (iree_host_size_t i = 0; i < batch->count; ++i) {
../../drivers/cuda/cuda_buffer.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/cuda_buffer.c:    iree_hal_buffer_initialize(placement, &buffer->base, allocation_size,
../../drivers/cuda/cuda_buffer.c:                               &iree_hal_cuda_buffer_vtable, &buffer->base);
../../drivers/cuda/cuda_buffer.c:    buffer->host_allocator = host_allocator;
../../drivers/cuda/cuda_buffer.c:    buffer->type = buffer_type;
../../drivers/cuda/cuda_buffer.c:    buffer->host_ptr = host_ptr;
../../drivers/cuda/cuda_buffer.c:    buffer->device_ptr = device_ptr;
../../drivers/cuda/cuda_buffer.c:    buffer->release_callback = release_callback;
../../drivers/cuda/cuda_buffer.c:    *out_buffer = &buffer->base;
../../drivers/cuda/cuda_buffer.c:  iree_allocator_t host_allocator = buffer->host_allocator;
../../drivers/cuda/cuda_buffer.c:  if (buffer->release_callback.fn) {
../../drivers/cuda/cuda_buffer.c:    buffer->release_callback.fn(buffer->release_callback.user_data,
../../drivers/cuda/cuda_buffer.c:  IREE_ASSERT(buffer->host_ptr, "mappable buffers require host pointers");
../../drivers/cuda/cuda_buffer.c:  uint8_t* data_ptr = (uint8_t*)(buffer->host_ptr) + local_byte_offset;
../../drivers/cuda/cuda_buffer.c:  mapping->contents = iree_make_byte_span(data_ptr, local_byte_length);
../../drivers/cuda/cuda_buffer.c:  return buffer->type;
../../drivers/cuda/cuda_buffer.c:  return buffer->device_ptr;
../../drivers/cuda/cuda_buffer.c:  return buffer->host_ptr;
../../drivers/cuda/cuda_buffer.c:  buffer->release_callback = iree_hal_buffer_release_callback_null();
../../drivers/cuda/nccl_headers.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/metal/staging_buffer.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/metal/staging_buffer.h:// consumption of 500 dispatches x worst-case 256B per dispatch of parameters
../../drivers/metal/staging_buffer.h:// This allows for high-frequency writes of parameters at appropriate alignment.
../../drivers/metal/staging_buffer.h:  // Non-recursive mutex guarding access to the offset field.
../../drivers/metal/nop_executable_cache.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/metal/nop_executable_cache.h:// Creates a no-op executable cache that does not cache at all.
../../drivers/metal/builtin_executables.m:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/metal/builtin_executables.m:    {IREE_SVL("fill_buffer_16byte"), 1},  // Buffer fills; 16-byte aligned offset/length
../../drivers/metal/builtin_executables.m:    {IREE_SVL("fill_buffer_4byte"), 1},   // Buffer fills; 4-byte aligned offset/length
../../drivers/metal/builtin_executables.m:    {IREE_SVL("fill_buffer_1byte"), 1},   // Buffer fills; 1-byte aligned offset/length
../../drivers/metal/builtin_executables.m:    {IREE_SVL("copy_buffer_1byte"), 0},   // Buffer copies; 1-byte aligned offset/length
../../drivers/metal/builtin_executables.m:  uint32_t pattern;        // 32-bit fill pattern
../../drivers/metal/builtin_executables.m:  // Embedding source files is an anti-pattern.
../../drivers/metal/builtin_executables.m:    [libraries release];  // -1
../../drivers/metal/builtin_executables.m:    out_pipeline->pipeline_state = pipeline_state;
../../drivers/metal/builtin_executables.m:      sizeof(*executable) + pipeline_count * sizeof(executable->pipelines[0]);
../../drivers/metal/builtin_executables.m:  executable->host_allocator = host_allocator;
../../drivers/metal/builtin_executables.m:  executable->pipeline_count = pipeline_count;
../../drivers/metal/builtin_executables.m:  iree_status_t status = iree_hal_metal_load_builtin_libraries(device, &executable->libraries);
../../drivers/metal/builtin_executables.m:      IREE_TRACE_ZONE_APPEND_TEXT(z_pipeline, pipeline_info->entry_point.data,
../../drivers/metal/builtin_executables.m:                                  pipeline_info->entry_point.size);
../../drivers/metal/builtin_executables.m:      iree_hal_metal_builtin_pipeline_t* pipeline = &executable->pipelines[i];
../../drivers/metal/builtin_executables.m:        iree_file_toc_t source_file = embedded_files[pipeline_info->file_index];
../../drivers/metal/builtin_executables.m:        pipeline->source_location.func_name = pipeline_info->entry_point;
../../drivers/metal/builtin_executables.m:        pipeline->source_location.file_name = IREE_SV(source_file.name);
../../drivers/metal/builtin_executables.m:        pipeline->source_location.line = 0;
../../drivers/metal/builtin_executables.m:          [executable->libraries objectAtIndex:pipeline_info->file_index];  // unretained
../../drivers/metal/builtin_executables.m:      status = iree_hal_metal_create_builtin_pipeline(device, library, pipeline_info->entry_point,
../../drivers/metal/builtin_executables.m:  for (iree_host_size_t i = 0; i < executable->pipeline_count; ++i) {
../../drivers/metal/builtin_executables.m:    iree_hal_metal_builtin_pipeline_t* pipeline = &executable->pipelines[i];
../../drivers/metal/builtin_executables.m:    [pipeline->pipeline_state release];
../../drivers/metal/builtin_executables.m:  [executable->libraries release];
../../drivers/metal/builtin_executables.m:  iree_allocator_free(executable->host_allocator, executable);
../../drivers/metal/builtin_executables.m:  if (target_offset % 16 == 0 && length % 16 == 0) {  // 16-byte aligned case
../../drivers/metal/builtin_executables.m:    pipeline_state = executable->pipelines[0].pipeline_state;
../../drivers/metal/builtin_executables.m:  } else if (target_offset % 4 == 0 && length % 4 == 0) {  // 4-byte aligned case
../../drivers/metal/builtin_executables.m:    pipeline_state = executable->pipelines[1].pipeline_state;
../../drivers/metal/builtin_executables.m:  } else {  // 1-byte aligned case
../../drivers/metal/builtin_executables.m:    pipeline_state = executable->pipelines[2].pipeline_state;
../../drivers/metal/builtin_executables.m:    // We may potentially need to read some 32-bit scalars at unaligned addresses.
../../drivers/metal/builtin_executables.m:    int64_t middle_byte_count = length - left_byte_count - right_byte_count;
../../drivers/metal/builtin_executables.m:  // buffer(0) is the target buffer to fill. Note that we MUST set 0 as offset here--the offset
../../drivers/metal/builtin_executables.m:  id<MTLComputePipelineState> pipeline_state = executable->pipelines[3].pipeline_state;
../../drivers/metal/builtin_executables.m:  // buffer(0) is the source buffer. Note that we MUST set 0 as offset here--the offset is to be
../../drivers/metal/builtin_executables.m:  // buffer(0) is the target buffer. Note that we MUST set 0 as offset here--the offset is to be
../../drivers/cuda/nop_executable_cache.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/nop_executable_cache.h:// Creates a no-op executable cache that does not cache at all.
../../drivers/cuda/CMakeLists.txt:# CMake-only content.                                                          #
../../drivers/cuda/cuda_device.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/cuda_device.h:// Creates a CUDA stream-backed command buffer using resources from the the
../../drivers/cuda/native_executable.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/native_executable.c:      cuDeviceGetAttribute(&out_limits->max_block_dims[0],
../../drivers/cuda/native_executable.c:      cuDeviceGetAttribute(&out_limits->max_block_dims[1],
../../drivers/cuda/native_executable.c:      cuDeviceGetAttribute(&out_limits->max_block_dims[2],
../../drivers/cuda/native_executable.c:          &out_limits->max_block_shared_memory_size,
../../drivers/cuda/native_executable.c:  // Run flatcc generated verification. This ensures all pointers are in-bounds
../../drivers/cuda/native_executable.c:      if (block_dims->x > limits->max_block_dims[0] ||
../../drivers/cuda/native_executable.c:          block_dims->y > limits->max_block_dims[1] ||
../../drivers/cuda/native_executable.c:          block_dims->z > limits->max_block_dims[2]) {
../../drivers/cuda/native_executable.c:            i, block_dims->x, block_dims->y, block_dims->z,
../../drivers/cuda/native_executable.c:            limits->max_block_dims[0], limits->max_block_dims[1],
../../drivers/cuda/native_executable.c:            limits->max_block_dims[2]);
../../drivers/cuda/native_executable.c:    if (block_shared_memory_size > limits->max_block_shared_memory_size) {
../../drivers/cuda/native_executable.c:                              limits->max_block_shared_memory_size);
../../drivers/cuda/native_executable.c:              executable_params->executable_data, &limits));
../../drivers/cuda/native_executable.c:          executable_params->executable_data.data);
../../drivers/cuda/native_executable.c:      sizeof(*executable) + module_count * sizeof(executable->modules[0]) +
../../drivers/cuda/native_executable.c:      export_count * sizeof(executable->exports[0]) + total_export_info_length;
../../drivers/cuda/native_executable.c:                               &executable->resource);
../../drivers/cuda/native_executable.c:  executable->host_allocator = host_allocator;
../../drivers/cuda/native_executable.c:  executable->symbols = symbols;
../../drivers/cuda/native_executable.c:  executable->module_count = module_count;
../../drivers/cuda/native_executable.c:  executable->modules =
../../drivers/cuda/native_executable.c:                  export_count * sizeof(executable->exports[0]));
../../drivers/cuda/native_executable.c:  executable->export_count = export_count;
../../drivers/cuda/native_executable.c:                 ((uint8_t*)executable->modules +
../../drivers/cuda/native_executable.c:                  module_count * sizeof(executable->modules[0])));
../../drivers/cuda/native_executable.c:    executable->modules[i] = module;
../../drivers/cuda/native_executable.c:      CUmodule module = executable->modules[module_ordinal];
../../drivers/cuda/native_executable.c:      iree_hal_cuda_kernel_params_t* kernel_info = &executable->exports[i];
../../drivers/cuda/native_executable.c:      kernel_info->function = function;
../../drivers/cuda/native_executable.c:      kernel_info->block_dims[0] = block_dims->x;
../../drivers/cuda/native_executable.c:      kernel_info->block_dims[1] = block_dims->y;
../../drivers/cuda/native_executable.c:      kernel_info->block_dims[2] = block_dims->z;
../../drivers/cuda/native_executable.c:      kernel_info->block_shared_memory_size =
../../drivers/cuda/native_executable.c:      kernel_info->constant_count =
../../drivers/cuda/native_executable.c:      kernel_info->binding_count =
../../drivers/cuda/native_executable.c:        kernel_info->debug_info.function_name = export_info->function_name;
../../drivers/cuda/native_executable.c:        kernel_info->debug_info.source_filename = export_info->source_filename;
../../drivers/cuda/native_executable.c:        kernel_info->debug_info.source_line = export_info->source_line;
../../drivers/cuda/native_executable.c:  iree_allocator_t host_allocator = executable->host_allocator;
../../drivers/cuda/native_executable.c:  for (iree_host_size_t i = 0; i < executable->module_count; ++i) {
../../drivers/cuda/native_executable.c:    if (executable->modules[i]) {
../../drivers/cuda/native_executable.c:      IREE_CUDA_IGNORE_ERROR(executable->symbols,
../../drivers/cuda/native_executable.c:                             cuModuleUnload(executable->modules[i]));
../../drivers/cuda/native_executable.c:  if (ordinal >= executable->export_count) {
../../drivers/cuda/native_executable.c:        ordinal, executable->export_count);
../../drivers/cuda/native_executable.c:  *out_params = &executable->exports[ordinal];
../../drivers/metal/direct_allocator.m:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/metal/direct_allocator.m:    iree_hal_resource_initialize(&iree_hal_metal_allocator_vtable, &allocator->resource);
../../drivers/metal/direct_allocator.m:    allocator->parent_device = parent_device;
../../drivers/metal/direct_allocator.m:    allocator->device = [device retain];  // +1
../../drivers/metal/direct_allocator.m:    allocator->is_unified_memory = [device hasUnifiedMemory];
../../drivers/metal/direct_allocator.m:    allocator->resource_tracking_mode = resource_tracking_mode;
../../drivers/metal/direct_allocator.m:    allocator->host_allocator = host_allocator;
../../drivers/metal/direct_allocator.m:  iree_allocator_t host_allocator = allocator->host_allocator;
../../drivers/metal/direct_allocator.m:  [allocator->device release];  // -1
../../drivers/metal/direct_allocator.m:  return allocator->host_allocator;
../../drivers/metal/direct_allocator.m:  return allocator->queue;
../../drivers/metal/direct_allocator.m:    memcpy(out_statistics, &allocator->statistics, sizeof(*out_statistics));
../../drivers/metal/direct_allocator.m:  if (iree_any_bit_set(params->usage, IREE_HAL_BUFFER_USAGE_TRANSFER)) {
../../drivers/metal/direct_allocator.m:  if (iree_all_bits_set(params->type, IREE_HAL_MEMORY_TYPE_DEVICE_VISIBLE)) {
../../drivers/metal/direct_allocator.m:    if (iree_any_bit_set(params->usage, IREE_HAL_BUFFER_USAGE_TRANSFER)) {
../../drivers/metal/direct_allocator.m:    if (iree_any_bit_set(params->usage, IREE_HAL_BUFFER_USAGE_DISPATCH_STORAGE)) {
../../drivers/metal/direct_allocator.m:  if (iree_all_bits_set(params->type,
../../drivers/metal/direct_allocator.m:    if (allocator->is_unified_memory) {
../../drivers/metal/direct_allocator.m:      params->type &= ~(IREE_HAL_MEMORY_TYPE_DEVICE_LOCAL | IREE_HAL_MEMORY_TYPE_HOST_VISIBLE);
../../drivers/metal/direct_allocator.m:      params->type |= IREE_HAL_MEMORY_TYPE_HOST_LOCAL | IREE_HAL_MEMORY_TYPE_DEVICE_VISIBLE;
../../drivers/metal/direct_allocator.m:  params->type &= ~IREE_HAL_MEMORY_TYPE_OPTIMAL;
../../drivers/metal/direct_allocator.m:  // to do anything when requesting a 0-byte buffer; but it can happen in real world use cases. So
../../drivers/metal/direct_allocator.m:      // case for macOS devices with non-uniform memory.
../../drivers/metal/direct_allocator.m:    // A write-combined CPU cache mode that is optimized for resources that the CPU writes into, but
../../drivers/metal/direct_allocator.m:    iree_string_view_t memory_type_str = iree_hal_memory_type_format(params->type, &temp0);
../../drivers/metal/direct_allocator.m:    iree_string_view_t usage_str = iree_hal_buffer_usage_format(params->usage, &temp1);
../../drivers/metal/direct_allocator.m:      compat_params.type, allocator->is_unified_memory, allocator->resource_tracking_mode);
../../drivers/metal/direct_allocator.m:  id<MTLBuffer> metal_buffer = [allocator->device newBufferWithLength:allocation_size
../../drivers/metal/direct_allocator.m:      .device = allocator->parent_device,
../../drivers/metal/direct_allocator.m:          params->queue_affinity ? params->queue_affinity : IREE_HAL_QUEUE_AFFINITY_ANY,
../../drivers/metal/direct_allocator.m:      allocator->queue,
../../drivers/metal/direct_allocator.m:      allocator->host_allocator, &buffer);  // +1
../../drivers/metal/direct_allocator.m:        &allocator->statistics, compat_params.type, allocation_size));
../../drivers/metal/direct_allocator.m:  [metal_buffer release];  // -1
../../drivers/metal/direct_allocator.m:        &allocator->statistics, iree_hal_buffer_memory_type(base_buffer),
../../drivers/metal/direct_allocator.m:  iree_hal_buffer_destroy(base_buffer);  // -1
../../drivers/metal/direct_allocator.m:  //     params->type, allocator->is_unified_memory, allocator->resource_tracking_mode);
../../drivers/metal/direct_allocator.m:      [allocator->device newBufferWithBytesNoCopy:external_buffer->handle.host_allocation.ptr
../../drivers/metal/direct_allocator.m:                                           length:(NSUInteger)external_buffer->size
../../drivers/metal/direct_allocator.m:      .device = allocator->parent_device,
../../drivers/metal/direct_allocator.m:          params->queue_affinity ? params->queue_affinity : IREE_HAL_QUEUE_AFFINITY_ANY,
../../drivers/metal/direct_allocator.m:                                    allocator->queue,
../../drivers/metal/direct_allocator.m:                                    metal_buffer, params->type, params->access, params->usage,
../../drivers/metal/direct_allocator.m:                                    external_buffer->size,
../../drivers/metal/direct_allocator.m:                                    /*byte_offset=*/0, /*byte_length=*/external_buffer->size,
../../drivers/metal/direct_allocator.m:                                    release_callback, allocator->host_allocator, out_buffer);  // +1
../../drivers/metal/direct_allocator.m:      (__bridge id<MTLBuffer>)external_buffer->handle.device_allocation.ptr;
../../drivers/metal/direct_allocator.m:  // Wrap the externally-provided buffer in a HAL buffer handle that will retain the MTLBuffer until
../../drivers/metal/direct_allocator.m:      .device = allocator->parent_device,
../../drivers/metal/direct_allocator.m:          params->queue_affinity ? params->queue_affinity : IREE_HAL_QUEUE_AFFINITY_ANY,
../../drivers/metal/direct_allocator.m:                                    allocator->queue,
../../drivers/metal/direct_allocator.m:                                    metal_buffer, params->type, params->access, params->usage,
../../drivers/metal/direct_allocator.m:                                    external_buffer->size, /*byte_offset=*/0,
../../drivers/metal/direct_allocator.m:                                    /*byte_length=*/external_buffer->size, release_callback,
../../drivers/metal/direct_allocator.m:                                    allocator->host_allocator, out_buffer);  // +1
../../drivers/metal/direct_allocator.m:  switch (external_buffer->type) {
../../drivers/cuda/nccl_status_util.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/nccl_status_util.h:  iree_hal_cuda_nccl_result_to_status((syms), ((syms)->expr), __FILE__, \
../../drivers/cuda/nccl_status_util.h:                           (syms), ((syms)->expr), __FILE__, __LINE__), \
../../drivers/cuda/nccl_status_util.h:      iree_hal_cuda_nccl_result_to_status((syms), ((syms)->expr), __FILE__, \
../../drivers/cuda/nccl_status_util.h:      (syms), ((syms)->expr), __FILE__, __LINE__))
../../drivers/metal/api.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/metal/api.h://===----------------------------------------------------------------------===//
../../drivers/metal/api.h://===----------------------------------------------------------------------===//
../../drivers/metal/api.h:  // Total size in bytes of per-queue uniform buffers for uploading parameters
../../drivers/metal/api.h://===----------------------------------------------------------------------===//
../../drivers/metal/api.h://===----------------------------------------------------------------------===//
../../drivers/cuda/dynamic_symbols_test.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/cuda_status_util.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/cuda_status_util.c:  if (!syms->cuGetErrorName ||
../../drivers/cuda/cuda_status_util.c:      syms->cuGetErrorName(result, &error_name) != CUDA_SUCCESS) {
../../drivers/cuda/cuda_status_util.c:  if (!syms->cuGetErrorString ||
../../drivers/cuda/cuda_status_util.c:      syms->cuGetErrorString(result, &error_string) != CUDA_SUCCESS) {
../../drivers/cuda/cuda_dynamic_symbol_table.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/metal/shared_event.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/nccl_dynamic_symbol_table.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/metal/metal_device.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/metal/builtin/fill_buffer_generic.metal:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/metal/builtin/fill_buffer_generic.metal:// Polyfill Metal kernels for buffer fills without aligned offsets / 4-byte patterns.
../../drivers/metal/builtin/fill_buffer_generic.metal:  uint32_t pattern;        // 32-bit fill pattern
../../drivers/metal/builtin/fill_buffer_generic.metal:// The target |buffer| is assumed to have 16-byte aligned offset/length.
../../drivers/metal/builtin/fill_buffer_generic.metal:// Each thread fills one 4-compoment 32-bit element vector.
../../drivers/metal/builtin/fill_buffer_generic.metal:// The target |buffer| is assumed to have 4-byte aligned offset/length.
../../drivers/metal/builtin/fill_buffer_generic.metal:// Each thread fills one 32-bit scalar.
../../drivers/metal/builtin/fill_buffer_generic.metal:// The target |buffer| is assumed to have 1-byte aligned offset/length.
../../drivers/metal/builtin/fill_buffer_generic.metal:// Each thread fills one 8-bit scalar.
../../drivers/metal/builtin/fill_buffer_generic.metal:  // 1. Left bytes: containing (0 to 3) bytes before the first 4-byte aligned address
../../drivers/metal/builtin/fill_buffer_generic.metal:  // 2. Middle bytes: aligned 32-bit scalars in the middle
../../drivers/metal/builtin/fill_buffer_generic.metal:  // 3. Right bytes: containing (0 to 3) bytes since the last 4-byte aligned address
../../drivers/metal/builtin/fill_buffer_generic.metal:  // Threads are distributed from the perspecitve of handling middle 32-bit scalars.
../../drivers/metal/builtin/fill_buffer_generic.metal:  // endian*, left bytes will replace high bits of the leftmost touched 32-bit scalar,
../../drivers/metal/builtin/fill_buffer_generic.metal:  // while right bytes will replace low bits of the rightmost touched 32-bit scalar.
../../drivers/metal/builtin/fill_buffer_generic.metal:  uint32_t left_mask = ~((uint64_t(1) << (8 * (4 - left_byte_count))) - 1);
../../drivers/metal/builtin/fill_buffer_generic.metal:  uint32_t right_mask = (uint64_t(1) << (8 * right_byte_count)) - 1;
../../drivers/metal/builtin/CMakeLists.txt:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/timepoint_pool.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/timepoint_pool.c://===----------------------------------------------------------------------===//
../../drivers/cuda/timepoint_pool.c://===----------------------------------------------------------------------===//
../../drivers/cuda/timepoint_pool.c:  timepoint->host_allocator = host_allocator;
../../drivers/cuda/timepoint_pool.c:  timepoint->pool = pool;
../../drivers/cuda/timepoint_pool.c:  iree_allocator_t host_allocator = timepoint->host_allocator;
../../drivers/cuda/timepoint_pool.c:  iree_hal_cuda_timepoint_pool_t* pool = timepoint->pool;
../../drivers/cuda/timepoint_pool.c:  timepoint->host_allocator = host_allocator;
../../drivers/cuda/timepoint_pool.c:  timepoint->pool = pool;
../../drivers/cuda/timepoint_pool.c:  iree_allocator_t host_allocator = timepoint->host_allocator;
../../drivers/cuda/timepoint_pool.c:  IREE_ASSERT(timepoint->kind == IREE_HAL_CUDA_TIMEPOINT_KIND_NONE);
../../drivers/cuda/timepoint_pool.c://===----------------------------------------------------------------------===//
../../drivers/cuda/timepoint_pool.c://===----------------------------------------------------------------------===//
../../drivers/cuda/timepoint_pool.c:      available_capacity * sizeof(*timepoint_pool->available_list);
../../drivers/cuda/timepoint_pool.c:  timepoint_pool->host_allocator = host_allocator;
../../drivers/cuda/timepoint_pool.c:  timepoint_pool->host_event_pool = host_event_pool;
../../drivers/cuda/timepoint_pool.c:  timepoint_pool->device_event_pool = device_event_pool;
../../drivers/cuda/timepoint_pool.c:  iree_slim_mutex_initialize(&timepoint_pool->timepoint_mutex);
../../drivers/cuda/timepoint_pool.c:  timepoint_pool->available_capacity = available_capacity;
../../drivers/cuda/timepoint_pool.c:  timepoint_pool->available_count = 0;
../../drivers/cuda/timepoint_pool.c:        &timepoint_pool->available_list[timepoint_pool->available_count++]);
../../drivers/cuda/timepoint_pool.c:  iree_allocator_t host_allocator = timepoint_pool->host_allocator;
../../drivers/cuda/timepoint_pool.c:  for (iree_host_size_t i = 0; i < timepoint_pool->available_count; ++i) {
../../drivers/cuda/timepoint_pool.c:    iree_hal_cuda_timepoint_free(timepoint_pool->available_list[i]);
../../drivers/cuda/timepoint_pool.c:  iree_slim_mutex_deinitialize(&timepoint_pool->timepoint_mutex);
../../drivers/cuda/timepoint_pool.c:  iree_slim_mutex_lock(&timepoint_pool->timepoint_mutex);
../../drivers/cuda/timepoint_pool.c:      iree_min(timepoint_pool->available_count, timepoint_count);
../../drivers/cuda/timepoint_pool.c:        timepoint_pool->available_count - from_pool_count;
../../drivers/cuda/timepoint_pool.c:    memcpy(out_timepoints, &timepoint_pool->available_list[pool_base_index],
../../drivers/cuda/timepoint_pool.c:           from_pool_count * sizeof(*timepoint_pool->available_list));
../../drivers/cuda/timepoint_pool.c:    timepoint_pool->available_count -= from_pool_count;
../../drivers/cuda/timepoint_pool.c:    remaining_count -= from_pool_count;
../../drivers/cuda/timepoint_pool.c:  iree_slim_mutex_unlock(&timepoint_pool->timepoint_mutex);
../../drivers/cuda/timepoint_pool.c:    IREE_TRACE_ZONE_BEGIN_NAMED(z1, "timepoint-pool-unpooled-acquire");
../../drivers/cuda/timepoint_pool.c:          timepoint_pool, timepoint_pool->host_allocator,
../../drivers/cuda/timepoint_pool.c:      timepoint_count * sizeof((*out_timepoints)->timepoint.host_wait));
../../drivers/cuda/timepoint_pool.c:      z0, iree_event_pool_acquire(timepoint_pool->host_event_pool,
../../drivers/cuda/timepoint_pool.c:    out_timepoints[i]->kind = IREE_HAL_CUDA_TIMEPOINT_KIND_HOST_WAIT;
../../drivers/cuda/timepoint_pool.c:    out_timepoints[i]->timepoint.host_wait = host_events[i];
../../drivers/cuda/timepoint_pool.c:      timepoint_count * sizeof((*out_timepoints)->timepoint.device_signal));
../../drivers/cuda/timepoint_pool.c:      z0, iree_hal_cuda_event_pool_acquire(timepoint_pool->device_event_pool,
../../drivers/cuda/timepoint_pool.c:    out_timepoints[i]->kind = IREE_HAL_CUDA_TIMEPOINT_KIND_DEVICE_SIGNAL;
../../drivers/cuda/timepoint_pool.c:    out_timepoints[i]->timepoint.device_signal = device_events[i];
../../drivers/cuda/timepoint_pool.c:      timepoint_count * sizeof((*out_timepoints)->timepoint.device_wait));
../../drivers/cuda/timepoint_pool.c:      z0, iree_hal_cuda_event_pool_acquire(timepoint_pool->device_event_pool,
../../drivers/cuda/timepoint_pool.c:    out_timepoints[i]->kind = IREE_HAL_CUDA_TIMEPOINT_KIND_DEVICE_WAIT;
../../drivers/cuda/timepoint_pool.c:    out_timepoints[i]->timepoint.device_wait = device_events[i];
../../drivers/cuda/timepoint_pool.c:    switch (timepoints[i]->kind) {
../../drivers/cuda/timepoint_pool.c:        iree_event_pool_release(timepoint_pool->host_event_pool, 1,
../../drivers/cuda/timepoint_pool.c:                                &timepoints[i]->timepoint.host_wait);
../../drivers/cuda/timepoint_pool.c:        iree_hal_cuda_event_release(timepoints[i]->timepoint.device_signal);
../../drivers/cuda/timepoint_pool.c:        iree_hal_cuda_event_release(timepoints[i]->timepoint.device_wait);
../../drivers/cuda/timepoint_pool.c:  iree_slim_mutex_lock(&timepoint_pool->timepoint_mutex);
../../drivers/cuda/timepoint_pool.c:      timepoint_pool->available_capacity - timepoint_pool->available_count,
../../drivers/cuda/timepoint_pool.c:    iree_host_size_t pool_base_index = timepoint_pool->available_count;
../../drivers/cuda/timepoint_pool.c:    memcpy(&timepoint_pool->available_list[pool_base_index], timepoints,
../../drivers/cuda/timepoint_pool.c:           to_pool_count * sizeof(*timepoint_pool->available_list));
../../drivers/cuda/timepoint_pool.c:    timepoint_pool->available_count += to_pool_count;
../../drivers/cuda/timepoint_pool.c:    remaining_count -= to_pool_count;
../../drivers/cuda/timepoint_pool.c:  iree_slim_mutex_unlock(&timepoint_pool->timepoint_mutex);
../../drivers/cuda/timepoint_pool.c:    IREE_TRACE_ZONE_BEGIN_NAMED(z1, "timepoint-pool-unpooled-release");
../../drivers/metal/builtin/copy_buffer_generic.metal:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/metal/builtin/copy_buffer_generic.metal:// Polyfill Metal kernels for buffer copies without 4-byte aligned offsets / lengths.
../../drivers/cuda/api.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/api.h://===----------------------------------------------------------------------===//
../../drivers/cuda/api.h://===----------------------------------------------------------------------===//
../../drivers/cuda/api.h:  // TODO: per-device access permissions array.
../../drivers/cuda/api.h:// Parameters for each CUmemoryPool used for queue-ordered allocations.
../../drivers/cuda/api.h:  // Used for any host-visible/host-local memory types.
../../drivers/cuda/api.h:  // NOTE: tracing has a non-trivial overhead and will skew the timing of
../../drivers/cuda/api.h:  // from there; be wary of whole-program tracing with this enabled.
../../drivers/cuda/api.h:  // Parameters for each CUmemoryPool used for queue-ordered allocations.
../../drivers/cuda/api.h://===----------------------------------------------------------------------===//
../../drivers/cuda/api.h://===----------------------------------------------------------------------===//
../../drivers/metal/executable.m:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/metal/executable.m:  // Run flatcc generated verification. This ensures all pointers are in-bounds and that we can
../../drivers/metal/executable.m:    [libraries release];  // -1
../../drivers/metal/executable.m:    out_pipeline->function = [library newFunctionWithName:function_name];  // +1
../../drivers/metal/executable.m:    if (IREE_UNLIKELY(out_pipeline->function == nil)) {
../../drivers/metal/executable.m:      [descriptor setComputeFunction:out_pipeline->function];
../../drivers/metal/executable.m:      out_pipeline->pipeline_state =
../../drivers/metal/executable.m:      if (IREE_UNLIKELY(out_pipeline->pipeline_state == nil)) {
../../drivers/metal/executable.m:    out_pipeline->threadgroup_size =
../../drivers/metal/executable.m:        MTLSizeMake(threadgroup_size->x, threadgroup_size->y, threadgroup_size->z);
../../drivers/metal/executable.m:    out_pipeline->constant_count = iree_hal_metal_PipelineDef_constant_count_get(pipeline_def);
../../drivers/metal/executable.m:    out_pipeline->binding_count = iree_hal_metal_BindingBits_vec_len(binding_flags_vec);
../../drivers/metal/executable.m:    out_pipeline->binding_read_only_bits = 0;
../../drivers/metal/executable.m:    for (iree_host_size_t i = 0; i < out_pipeline->binding_count; ++i) {
../../drivers/metal/executable.m:        out_pipeline->binding_read_only_bits |= 1ull << i;
../../drivers/metal/executable.m:      iree_hal_metal_executable_flatbuffer_verify(executable_params->executable_data));
../../drivers/metal/executable.m:      iree_hal_metal_ExecutableDef_as_root(executable_params->executable_data.data);
../../drivers/metal/executable.m:                                pipeline_count * sizeof(executable->pipelines[0]) +
../../drivers/metal/executable.m:  iree_hal_resource_initialize(&iree_hal_metal_executable_vtable, &executable->resource);
../../drivers/metal/executable.m:  executable->host_allocator = host_allocator;
../../drivers/metal/executable.m:  executable->pipeline_count = pipeline_count;
../../drivers/metal/executable.m:  IREE_TRACE(uint8_t* export_info_ptr = ((uint8_t*)executable->pipelines +
../../drivers/metal/executable.m:                                         pipeline_count * sizeof(executable->pipelines[0])));
../../drivers/metal/executable.m:      iree_hal_metal_load_libraries(device, libraries_vec, &executable->libraries);
../../drivers/metal/executable.m:      id<MTLLibrary> library = [executable->libraries objectAtIndex:library_ordinal];  // unretained
../../drivers/metal/executable.m:      iree_hal_metal_pipeline_t* pipeline = &executable->pipelines[i];
../../drivers/metal/executable.m:        pipeline->source_location.func_name = export_info->function_name;
../../drivers/metal/executable.m:        pipeline->source_location.file_name = export_info->source_filename;
../../drivers/metal/executable.m:        pipeline->source_location.line = export_info->source_line;
../../drivers/metal/executable.m:  for (iree_host_size_t i = 0; i < executable->pipeline_count; ++i) {
../../drivers/metal/executable.m:    iree_hal_metal_pipeline_t* entry_point = &executable->pipelines[i];
../../drivers/metal/executable.m:    [entry_point->pipeline_state release];  // -1
../../drivers/metal/executable.m:    [entry_point->function release];        // -1
../../drivers/metal/executable.m:  [executable->libraries release];  // -1
../../drivers/metal/executable.m:  iree_allocator_free(executable->host_allocator, executable);
../../drivers/metal/executable.m:  if (entry_point >= executable->pipeline_count) {
../../drivers/metal/executable.m:  *out_pipeline = &executable->pipelines[entry_point];
../../drivers/metal/registration/driver_module.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/nop_executable_cache.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/nop_executable_cache.c:                               &executable_cache->resource);
../../drivers/cuda/nop_executable_cache.c:  executable_cache->host_allocator = host_allocator;
../../drivers/cuda/nop_executable_cache.c:  executable_cache->symbols = symbols;
../../drivers/cuda/nop_executable_cache.c:  executable_cache->device = device;
../../drivers/cuda/nop_executable_cache.c:  iree_allocator_t host_allocator = executable_cache->host_allocator;
../../drivers/cuda/nop_executable_cache.c:      executable_cache->symbols, executable_cache->device, executable_params,
../../drivers/cuda/nop_executable_cache.c:      executable_cache->host_allocator, out_executable);
../../drivers/metal/cts/CMakeLists.txt:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/metal/cts/CMakeLists.txt:    "metal-spirv"
../../drivers/metal/cts/CMakeLists.txt:    # https://github.com/iree-org/iree/pull/17080#discussion_r1569867998
../../drivers/cuda/event_pool.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/event_pool.c://===----------------------------------------------------------------------===//
../../drivers/cuda/event_pool.c://===----------------------------------------------------------------------===//
../../drivers/cuda/event_pool.c:  // * 1 - when inside the event pool and to be acquired;
../../drivers/cuda/event_pool.c:  // * >= 1 - when acquired outside of the event pool;
../../drivers/cuda/event_pool.c:  // * 0 - when before releasing back to the pool or destruction.
../../drivers/cuda/event_pool.c:  return event->cu_event;
../../drivers/cuda/event_pool.c:  iree_allocator_t host_allocator = event->host_allocator;
../../drivers/cuda/event_pool.c:  const iree_hal_cuda_dynamic_symbols_t* symbols = event->symbols;
../../drivers/cuda/event_pool.c:  IREE_ASSERT_REF_COUNT_ZERO(&event->ref_count);
../../drivers/cuda/event_pool.c:  IREE_CUDA_IGNORE_ERROR(symbols, cuEventDestroy(event->cu_event));
../../drivers/cuda/event_pool.c:  iree_atomic_ref_count_init(&event->ref_count);  // -> 1
../../drivers/cuda/event_pool.c:  event->host_allocator = host_allocator;
../../drivers/cuda/event_pool.c:  event->symbols = symbols;
../../drivers/cuda/event_pool.c:  event->pool = pool;
../../drivers/cuda/event_pool.c:  event->cu_event = NULL;
../../drivers/cuda/event_pool.c:      symbols, cuEventCreate(&event->cu_event, CU_EVENT_DISABLE_TIMING),
../../drivers/cuda/event_pool.c:    iree_atomic_ref_count_dec(&event->ref_count);  // -> 0
../../drivers/cuda/event_pool.c:  iree_atomic_ref_count_inc(&event->ref_count);
../../drivers/cuda/event_pool.c:  if (iree_atomic_ref_count_dec(&event->ref_count) == 1) {
../../drivers/cuda/event_pool.c:    iree_hal_cuda_event_pool_t* pool = event->pool;
../../drivers/cuda/event_pool.c:    iree_hal_cuda_event_pool_release(pool);  // -1
../../drivers/cuda/event_pool.c://===----------------------------------------------------------------------===//
../../drivers/cuda/event_pool.c://===----------------------------------------------------------------------===//
../../drivers/cuda/event_pool.c:      available_capacity * sizeof(*event_pool->available_list);
../../drivers/cuda/event_pool.c:  iree_atomic_ref_count_init(&event_pool->ref_count);  // -> 1
../../drivers/cuda/event_pool.c:  event_pool->host_allocator = host_allocator;
../../drivers/cuda/event_pool.c:  event_pool->symbols = symbols;
../../drivers/cuda/event_pool.c:  iree_slim_mutex_initialize(&event_pool->event_mutex);
../../drivers/cuda/event_pool.c:  event_pool->available_capacity = available_capacity;
../../drivers/cuda/event_pool.c:  event_pool->available_count = 0;
../../drivers/cuda/event_pool.c:        &event_pool->available_list[event_pool->available_count++]);
../../drivers/cuda/event_pool.c:  iree_allocator_t host_allocator = event_pool->host_allocator;
../../drivers/cuda/event_pool.c:  for (iree_host_size_t i = 0; i < event_pool->available_count; ++i) {
../../drivers/cuda/event_pool.c:    iree_hal_cuda_event_t* event = event_pool->available_list[i];
../../drivers/cuda/event_pool.c:    iree_atomic_ref_count_dec(&event->ref_count);  // -> 0
../../drivers/cuda/event_pool.c:  IREE_ASSERT_REF_COUNT_ZERO(&event_pool->ref_count);
../../drivers/cuda/event_pool.c:  iree_slim_mutex_deinitialize(&event_pool->event_mutex);
../../drivers/cuda/event_pool.c:  iree_atomic_ref_count_inc(&event_pool->ref_count);
../../drivers/cuda/event_pool.c:  if (iree_atomic_ref_count_dec(&event_pool->ref_count) == 1) {
../../drivers/cuda/event_pool.c:  iree_slim_mutex_lock(&event_pool->event_mutex);
../../drivers/cuda/event_pool.c:      iree_min(event_pool->available_count, event_count);
../../drivers/cuda/event_pool.c:        event_pool->available_count - from_pool_count;
../../drivers/cuda/event_pool.c:    memcpy(out_events, &event_pool->available_list[pool_base_index],
../../drivers/cuda/event_pool.c:           from_pool_count * sizeof(*event_pool->available_list));
../../drivers/cuda/event_pool.c:    event_pool->available_count -= from_pool_count;
../../drivers/cuda/event_pool.c:    remaining_count -= from_pool_count;
../../drivers/cuda/event_pool.c:  iree_slim_mutex_unlock(&event_pool->event_mutex);
../../drivers/cuda/event_pool.c:    IREE_TRACE_ZONE_BEGIN_NAMED(z1, "event-pool-unpooled-acquire");
../../drivers/cuda/event_pool.c:      status = iree_hal_cuda_event_create(event_pool->symbols, event_pool,
../../drivers/cuda/event_pool.c:                                          event_pool->host_allocator,
../../drivers/cuda/event_pool.c:    iree_hal_cuda_event_pool_retain(out_events[i]->pool);  // +1
../../drivers/cuda/event_pool.c:  iree_slim_mutex_lock(&event_pool->event_mutex);
../../drivers/cuda/event_pool.c:      iree_min(event_pool->available_capacity - event_pool->available_count,
../../drivers/cuda/event_pool.c:      IREE_ASSERT_REF_COUNT_ZERO(&events[i]->ref_count);
../../drivers/cuda/event_pool.c:      iree_hal_cuda_event_retain(events[i]);  // -> 1
../../drivers/cuda/event_pool.c:    iree_host_size_t pool_base_index = event_pool->available_count;
../../drivers/cuda/event_pool.c:    memcpy(&event_pool->available_list[pool_base_index], events,
../../drivers/cuda/event_pool.c:           to_pool_count * sizeof(*event_pool->available_list));
../../drivers/cuda/event_pool.c:    event_pool->available_count += to_pool_count;
../../drivers/cuda/event_pool.c:    remaining_count -= to_pool_count;
../../drivers/cuda/event_pool.c:  iree_slim_mutex_unlock(&event_pool->event_mutex);
../../drivers/cuda/event_pool.c:    IREE_TRACE_ZONE_BEGIN_NAMED(z1, "event-pool-unpooled-release");
../../drivers/cuda/cuda_driver.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/cuda_driver.c:#define IREE_DEVICE_ID_TO_CUDEVICE(device_id) (CUdevice)((device_id) - 1)
../../drivers/cuda/cuda_driver.c:  // NCCL API dynamic symbols to use collectives (multi-gpu/multi-node).
../../drivers/cuda/cuda_driver.c:  out_options->default_device_index = 0;
../../drivers/cuda/cuda_driver.c:  iree_hal_resource_initialize(&iree_hal_cuda_driver_vtable, &driver->resource);
../../drivers/cuda/cuda_driver.c:  driver->host_allocator = host_allocator;
../../drivers/cuda/cuda_driver.c:      identifier, &driver->identifier,
../../drivers/cuda/cuda_driver.c:  driver->default_device_index = options->default_device_index;
../../drivers/cuda/cuda_driver.c:      host_allocator, &driver->cuda_symbols);
../../drivers/cuda/cuda_driver.c:        host_allocator, &driver->cuda_symbols, &driver->nccl_symbols);
../../drivers/cuda/cuda_driver.c:  memcpy(&driver->device_params, device_params, sizeof(driver->device_params));
../../drivers/cuda/cuda_driver.c:  iree_allocator_t host_allocator = driver->host_allocator;
../../drivers/cuda/cuda_driver.c:  iree_hal_cuda_nccl_dynamic_symbols_deinitialize(&driver->nccl_symbols);
../../drivers/cuda/cuda_driver.c:  iree_hal_cuda_dynamic_symbols_deinitialize(&driver->cuda_symbols);
../../drivers/cuda/cuda_driver.c:      IREE_CURESULT_TO_STATUS(&driver->cuda_symbols, cuInit(0), "cuInit");
../../drivers/cuda/cuda_driver.c:  out_device_info->device_id = IREE_CUDEVICE_TO_DEVICE_ID(device);
../../drivers/cuda/cuda_driver.c:  // This matches the output of `nvidia-smi -L`.
../../drivers/cuda/cuda_driver.c:           "GPU-"
../../drivers/cuda/cuda_driver.c:           "%02x%02x%02x%02x-"
../../drivers/cuda/cuda_driver.c:           "%02x%02x-"
../../drivers/cuda/cuda_driver.c:           "%02x%02x-"
../../drivers/cuda/cuda_driver.c:           "%02x%02x-"
../../drivers/cuda/cuda_driver.c:                            IREE_ARRAYSIZE(device_path_str) - 1),
../../drivers/cuda/cuda_driver.c:      &out_device_info->path, (char*)buffer_ptr);
../../drivers/cuda/cuda_driver.c:      device_name_str, &out_device_info->name, (char*)buffer_ptr);
../../drivers/cuda/cuda_driver.c:  IREE_CUDA_RETURN_AND_END_ZONE_IF_ERROR(z0, &driver->cuda_symbols,
../../drivers/cuda/cuda_driver.c:      status = IREE_CURESULT_TO_STATUS(&driver->cuda_symbols,
../../drivers/cuda/cuda_driver.c:          device, &driver->cuda_symbols, buffer_ptr, &buffer_ptr,
../../drivers/cuda/cuda_driver.c:      &driver->cuda_symbols,                                                 \
../../drivers/cuda/cuda_driver.c:      builder, "\n- gpu-compute-capability: %d.%d", compute_capability_major,
../../drivers/cuda/cuda_driver.c:  IREE_CUDA_RETURN_IF_ERROR(&driver->cuda_symbols,
../../drivers/cuda/cuda_driver.c:      builder, "\n- driver-max-cuda-version: %d.%d", driver_version / 1000,
../../drivers/cuda/cuda_driver.c:      builder, "\n- launch-max-block-dims: (%d, %d, %d)", max_block_dim_x,
../../drivers/cuda/cuda_driver.c:      builder, "\n- launch-max-grid-dims: (%d, %d, %d)", max_grid_dim_x,
../../drivers/cuda/cuda_driver.c:      builder, "\n- block-max-thread-count: %d", max_threads_per_block));
../../drivers/cuda/cuda_driver.c:      builder, "\n- block-max-32-bit-register-count: %d",
../../drivers/cuda/cuda_driver.c:      builder, "\n- block-max-shared-memory: %d bytes",
../../drivers/cuda/cuda_driver.c:      builder, "\n- multiprocessor-max-thread-count: %d",
../../drivers/cuda/cuda_driver.c:      builder, "\n- multiprocessor-max-block-count: %d",
../../drivers/cuda/cuda_driver.c:      builder, "\n- multiprocessor-max-32-bit-register-count: %d",
../../drivers/cuda/cuda_driver.c:      builder, "\n- multiprocessor-max-shared-memory: %d bytes",
../../drivers/cuda/cuda_driver.c:      builder, "\n- memory-is-integrated-memory: %d", is_integrated_memory));
../../drivers/cuda/cuda_driver.c:      builder, "\n- memory-has-unified-address-space: %d",
../../drivers/cuda/cuda_driver.c:      builder, "\n- memory-supports-managed-memory: %d",
../../drivers/cuda/cuda_driver.c:      builder, "\n- memory-can-map-host-memory-to-device: %d",
../../drivers/cuda/cuda_driver.c:      builder, "\n- memory-supports-pageable-memory-access-from-device: %d",
../../drivers/cuda/cuda_driver.c:      builder, "\n- memory-supports-concurrent-managed-access: %d",
../../drivers/cuda/cuda_driver.c:      builder, "\n- memory-supports-memory-pools: %d", supports_memory_pools));
../../drivers/cuda/cuda_driver.c:      builder, "\n- memory-l2-cache-size: %d bytes", l2_cache_size));
../../drivers/cuda/cuda_driver.c:      builder, "\n- sync-supports-64-bit-stream-mem-ops: %d",
../../drivers/cuda/cuda_driver.c:      builder, "\n- sync-supports-timeline-semaphore-interop: %d",
../../drivers/cuda/cuda_driver.c:      builder, "\n- sync-mem-domain-count: %d", mem_sync_domain_count));
../../drivers/cuda/cuda_driver.c:      builder, "\n- gpu-multiprocessor-count: %d", multiprocessor_count));
../../drivers/cuda/cuda_driver.c:      builder, "\n- gpu-clock-rate: %d kHz", clock_rate));
../../drivers/cuda/cuda_driver.c:      builder, "\n- gpu-warp-size: %d", warp_size));
../../drivers/cuda/cuda_driver.c:      builder, "\n- kernel-has-execution-timeout: %d", execution_timeout));
../../drivers/cuda/cuda_driver.c:                base_driver, &driver->cuda_symbols,
../../drivers/cuda/cuda_driver.c:                driver->default_device_index, host_allocator, &device));
../../drivers/cuda/cuda_driver.c:      base_driver, device_name, &driver->device_params, &driver->cuda_symbols,
../../drivers/cuda/cuda_driver.c:      &driver->nccl_symbols, device, host_allocator, out_device);
../../drivers/cuda/cuda_driver.c:  IREE_CUDA_RETURN_IF_ERROR(&driver->cuda_symbols,
../../drivers/cuda/cuda_driver.c:    IREE_CUDA_RETURN_IF_ERROR(&driver->cuda_symbols, cuDeviceGet(&device, i),
../../drivers/cuda/cuda_driver.c:    IREE_CUDA_RETURN_IF_ERROR(&driver->cuda_symbols,
../../drivers/cuda/cuda_driver.c:    if (memcmp(&device_uuid->bytes[0], &query_uuid.bytes[0],
../../drivers/cuda/cuda_driver.c:        "CUDA device with UUID GPU-"
../../drivers/cuda/cuda_driver.c:        "%02x%02x%02x%02x-"
../../drivers/cuda/cuda_driver.c:        "%02x%02x-"
../../drivers/cuda/cuda_driver.c:        "%02x%02x-"
../../drivers/cuda/cuda_driver.c:        "%02x%02x-"
../../drivers/cuda/cuda_driver.c:        (uint8_t)device_uuid->bytes[0], (uint8_t)device_uuid->bytes[1],
../../drivers/cuda/cuda_driver.c:        (uint8_t)device_uuid->bytes[2], (uint8_t)device_uuid->bytes[3],
../../drivers/cuda/cuda_driver.c:        (uint8_t)device_uuid->bytes[4], (uint8_t)device_uuid->bytes[5],
../../drivers/cuda/cuda_driver.c:        (uint8_t)device_uuid->bytes[6], (uint8_t)device_uuid->bytes[7],
../../drivers/cuda/cuda_driver.c:        (uint8_t)device_uuid->bytes[8], (uint8_t)device_uuid->bytes[9],
../../drivers/cuda/cuda_driver.c:        (uint8_t)device_uuid->bytes[10], (uint8_t)device_uuid->bytes[11],
../../drivers/cuda/cuda_driver.c:        (uint8_t)device_uuid->bytes[12], (uint8_t)device_uuid->bytes[13],
../../drivers/cuda/cuda_driver.c:        (uint8_t)device_uuid->bytes[14], (uint8_t)device_uuid->bytes[15]);
../../drivers/cuda/cuda_driver.c:  IREE_CUDA_RETURN_IF_ERROR(&driver->cuda_symbols,
../../drivers/cuda/cuda_driver.c:  IREE_CUDA_RETURN_IF_ERROR(&driver->cuda_symbols,
../../drivers/cuda/cuda_driver.c:  if (iree_string_view_consume_prefix(&device_path, IREE_SV("GPU-"))) {
../../drivers/CMakeLists.txt:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/CMakeLists.txt:# have init.c generated too. That'd require bazel goo; today by having the hand-
../../drivers/CMakeLists.txt:# coded file we can use it in bazel as-is.
../../drivers/CMakeLists.txt:  IMPORTED_LOCATION "/home/jueun/park/renode/renode-latest/renode-dpi-examples/samples/axi_sa16/axi_sa16/build/libVtop.so"
../../drivers/CMakeLists.txt:      "Driver passed to -DIREE_EXTERNAL_HAL_DRIVERS=${_DRIVER_NAME} is not found. Available: "
../../drivers/CMakeLists.txt:  string(REGEX REPLACE "-" "_" _DRIVER_VAR ${_DRIVER_VAR})
../../drivers/CMakeLists.txt:  set(_INIT_EXTERNAL_COPTS "-DIREE_HAVE_HAL_EXTERNAL_DRIVERS=1")
../../drivers/CMakeLists.txt:    string(REGEX REPLACE "-" "_" _DRIVER_VAR ${_DRIVER_VAR})
../../drivers/metal/registration/driver_module.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/metal/staging_buffer.m:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/metal/staging_buffer.m:  // "For small-sized data that changes frequently, choose the Shared mode. The overhead of copying
../../drivers/metal/staging_buffer.m:  out_staging_buffer->capacity = (uint32_t)buffer_capacity;
../../drivers/metal/staging_buffer.m:  out_staging_buffer->metal_buffer = metal_buffer;
../../drivers/metal/staging_buffer.m:  out_staging_buffer->host_buffer = metal_buffer.contents;
../../drivers/metal/staging_buffer.m:  iree_slim_mutex_initialize(&out_staging_buffer->offset_mutex);
../../drivers/metal/staging_buffer.m:  out_staging_buffer->offset = 0;
../../drivers/metal/staging_buffer.m:  iree_atomic_store(&out_staging_buffer->pending_command_buffers, 0, iree_memory_order_relaxed);
../../drivers/metal/staging_buffer.m:  iree_slim_mutex_deinitialize(&staging_buffer->offset_mutex);
../../drivers/metal/staging_buffer.m:  [staging_buffer->metal_buffer release];  // -1
../../drivers/metal/staging_buffer.m:  if (length > staging_buffer->capacity) {
../../drivers/metal/staging_buffer.m:                            length, staging_buffer->capacity);
../../drivers/metal/staging_buffer.m:  iree_slim_mutex_lock(&staging_buffer->offset_mutex);
../../drivers/metal/staging_buffer.m:  uint32_t aligned_offset = iree_host_align(staging_buffer->offset, alignment);
../../drivers/metal/staging_buffer.m:  if (aligned_offset + length > staging_buffer->capacity) {
../../drivers/metal/staging_buffer.m:    iree_slim_mutex_unlock(&staging_buffer->offset_mutex);
../../drivers/metal/staging_buffer.m:  staging_buffer->offset = aligned_offset + length;
../../drivers/metal/staging_buffer.m:  iree_slim_mutex_unlock(&staging_buffer->offset_mutex);
../../drivers/metal/staging_buffer.m:  *out_reservation = iree_make_byte_span(staging_buffer->host_buffer + aligned_offset, length);
../../drivers/metal/staging_buffer.m:  iree_slim_mutex_lock(&staging_buffer->offset_mutex);
../../drivers/metal/staging_buffer.m:  staging_buffer->offset = 0;
../../drivers/metal/staging_buffer.m:  iree_slim_mutex_unlock(&staging_buffer->offset_mutex);
../../drivers/metal/staging_buffer.m:  iree_atomic_fetch_add(&staging_buffer->pending_command_buffers, 1, iree_memory_order_relaxed);
../../drivers/metal/staging_buffer.m:  if (iree_atomic_fetch_sub(&staging_buffer->pending_command_buffers, 1,
../../drivers/metal/metal_driver.m:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/metal/metal_driver.m:  if (params->arena_block_size < 4096) {
../../drivers/metal/metal_driver.m:  iree_hal_resource_initialize(&iree_hal_metal_driver_vtable, &driver->resource);
../../drivers/metal/metal_driver.m:  driver->host_allocator = host_allocator;
../../drivers/metal/metal_driver.m:  iree_string_view_append_to_buffer(identifier, &driver->identifier,
../../drivers/metal/metal_driver.m:  driver->device_params = *device_params;
../../drivers/metal/metal_driver.m:  driver->devices = iree_hal_metal_device_copy();
../../drivers/metal/metal_driver.m:  iree_allocator_t host_allocator = driver->host_allocator;
../../drivers/metal/metal_driver.m:  [driver->devices release];  // -1
../../drivers/metal/metal_driver.m:  out_device_info->device_id = METAL_DEVICE_TO_DEVICE_ID(device);
../../drivers/metal/metal_driver.m:  // For Metal devices, we don't have a 128-bit UUID; so just use the 64-bit registry ID here.
../../drivers/metal/metal_driver.m:      iree_make_string_view(device_path, IREE_ARRAYSIZE(device_path) - 1), &out_device_info->path,
../../drivers/metal/metal_driver.m:                                                  &out_device_info->name, (char*)buffer_ptr);
../../drivers/metal/metal_driver.m:  NSArray<id<MTLDevice>>* devices = driver->devices;
../../drivers/metal/metal_driver.m:  IREE_RETURN_IF_ERROR(iree_string_builder_append_cstring(builder, "- gpu-family:"));
../../drivers/metal/metal_driver.m:  IREE_RETURN_IF_ERROR(iree_string_builder_append_format(builder, "\n- unified-memory: %d",
../../drivers/metal/metal_driver.m:  IREE_RETURN_IF_ERROR(iree_string_builder_append_cstring(builder, "\n- argument-buffer-tier: "));
../../drivers/metal/metal_driver.m:  IREE_RETURN_IF_ERROR(iree_string_builder_append_cstring(builder, "\n- max-buffer-size: "));
../../drivers/metal/metal_driver.m:      iree_string_builder_append_cstring(builder, "\n- max-threadgroup-memory-size: "));
../../drivers/metal/metal_driver.m:      iree_string_builder_append_cstring(builder, "\n- max-threads-per-threadgroup: "));
../../drivers/metal/metal_driver.m:  // Dump SIMD-scoped operation features.
../../drivers/metal/metal_driver.m:  IREE_RETURN_IF_ERROR(iree_string_builder_append_cstring(builder, "\n- simd-scoped-operation:"));
../../drivers/metal/metal_driver.m:    IREE_RETURN_IF_ERROR(iree_string_builder_append_cstring(builder, " shift-and-fill"));
../../drivers/metal/metal_driver.m:  NSArray<id<MTLDevice>>* devices = driver->devices;
../../drivers/metal/metal_driver.m:  iree_status_t status = iree_hal_metal_device_create(device_name, &driver->device_params, device,
../../drivers/metal/metal_driver.m:  NSArray<id<MTLDevice>>* devices = driver->devices;
../../drivers/metal/nop_executable_cache.m:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/metal/nop_executable_cache.m:                                 &executable_cache->resource);
../../drivers/metal/nop_executable_cache.m:    executable_cache->device = [device retain];  // +1
../../drivers/metal/nop_executable_cache.m:    executable_cache->host_allocator = host_allocator;
../../drivers/metal/nop_executable_cache.m:  [executable_cache->device release];  // -1
../../drivers/metal/nop_executable_cache.m:  iree_allocator_free(executable_cache->host_allocator, executable_cache);
../../drivers/metal/nop_executable_cache.m:  return iree_hal_metal_executable_create(executable_cache->device, executable_params,
../../drivers/metal/nop_executable_cache.m:                                          executable_cache->host_allocator, out_executable);
../../drivers/metal/direct_command_buffer.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/metal/direct_command_buffer.h:// Such command buffers are one shot--they can only be submitted once.
../../drivers/metal/builtin_executables.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/metal/direct_command_buffer.m:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/metal/direct_command_buffer.m://===------------------------------------------------------------------------------------------===//
../../drivers/metal/direct_command_buffer.m://===------------------------------------------------------------------------------------------===//
../../drivers/metal/direct_command_buffer.m:// Unlike Vulkan, Metal adopts a multi-level command recording model--memory/dispatch commands are
../../drivers/metal/direct_command_buffer.m:  // Workgroup count information--if |workgroups_buffer| is not nil, then indirect dispatch;
../../drivers/metal/direct_command_buffer.m:  segment->next_segment = list->head;
../../drivers/metal/direct_command_buffer.m:  list->head = segment;
../../drivers/metal/direct_command_buffer.m:  if (!list->tail) list->tail = segment;
../../drivers/metal/direct_command_buffer.m:  segment->next_segment = NULL;
../../drivers/metal/direct_command_buffer.m:  if (list->tail) {
../../drivers/metal/direct_command_buffer.m:    list->tail->next_segment = segment;
../../drivers/metal/direct_command_buffer.m:    list->tail = segment;
../../drivers/metal/direct_command_buffer.m:    list->head = list->tail = segment;
../../drivers/metal/direct_command_buffer.m://===------------------------------------------------------------------------------------------===//
../../drivers/metal/direct_command_buffer.m://===------------------------------------------------------------------------------------------===//
../../drivers/metal/direct_command_buffer.m:  // Per-queue shared uniform staging buffer for uploading parameters to the GPU, including argument
../../drivers/metal/direct_command_buffer.m://===------------------------------------------------------------------------------------------===//
../../drivers/metal/direct_command_buffer.m://===------------------------------------------------------------------------------------------===//
../../drivers/metal/direct_command_buffer.m:  return command_buffer->command_buffer;
../../drivers/metal/direct_command_buffer.m:  if (command_buffer->state.compute_encoder) {
../../drivers/metal/direct_command_buffer.m:    [command_buffer->state.compute_encoder endEncoding];
../../drivers/metal/direct_command_buffer.m:    [command_buffer->state.compute_encoder release];  // -1
../../drivers/metal/direct_command_buffer.m:    command_buffer->state.compute_encoder = nil;
../../drivers/metal/direct_command_buffer.m:  if (command_buffer->state.blit_encoder) {
../../drivers/metal/direct_command_buffer.m:    [command_buffer->state.blit_encoder endEncoding];
../../drivers/metal/direct_command_buffer.m:    [command_buffer->state.blit_encoder release];  // -1
../../drivers/metal/direct_command_buffer.m:    command_buffer->state.blit_encoder = nil;
../../drivers/metal/direct_command_buffer.m:  iree_hal_metal_command_segment_list_reset(&command_buffer->segments);
../../drivers/metal/direct_command_buffer.m:  iree_arena_reset(&command_buffer->arena);
../../drivers/metal/direct_command_buffer.m:  id<MTLCommandBuffer> metal_handle = command_buffer->command_buffer;
../../drivers/metal/direct_command_buffer.m:  if (command_buffer->state.blit_encoder) {
../../drivers/metal/direct_command_buffer.m:    encoder_event_value = command_buffer->state.next_encoder_event_value++;
../../drivers/metal/direct_command_buffer.m:    [metal_handle encodeSignalEvent:command_buffer->state.encoder_event value:encoder_event_value];
../../drivers/metal/direct_command_buffer.m:  if (!command_buffer->state.compute_encoder) {
../../drivers/metal/direct_command_buffer.m:      [metal_handle encodeWaitForEvent:command_buffer->state.encoder_event
../../drivers/metal/direct_command_buffer.m:      command_buffer->state.compute_encoder = [[metal_handle
../../drivers/metal/direct_command_buffer.m:          computeCommandEncoderWithDispatchType:command_buffer->dispatch_type] retain];  // +1
../../drivers/metal/direct_command_buffer.m:  return command_buffer->state.compute_encoder;
../../drivers/metal/direct_command_buffer.m:  id<MTLCommandBuffer> metal_handle = command_buffer->command_buffer;
../../drivers/metal/direct_command_buffer.m:  if (command_buffer->state.compute_encoder) {
../../drivers/metal/direct_command_buffer.m:    encoder_event_value = command_buffer->state.next_encoder_event_value++;
../../drivers/metal/direct_command_buffer.m:    [metal_handle encodeSignalEvent:command_buffer->state.encoder_event value:encoder_event_value];
../../drivers/metal/direct_command_buffer.m:  if (!command_buffer->state.blit_encoder) {
../../drivers/metal/direct_command_buffer.m:      [metal_handle encodeWaitForEvent:command_buffer->state.encoder_event
../../drivers/metal/direct_command_buffer.m:      command_buffer->state.blit_encoder = [[metal_handle blitCommandEncoder] retain];  // +1
../../drivers/metal/direct_command_buffer.m:  return command_buffer->state.blit_encoder;
../../drivers/metal/direct_command_buffer.m:                                     &iree_hal_metal_command_buffer_vtable, &command_buffer->base);
../../drivers/metal/direct_command_buffer.m:  command_buffer->device = device;
../../drivers/metal/direct_command_buffer.m:  command_buffer->queue = [queue retain];  // +1
../../drivers/metal/direct_command_buffer.m:  command_buffer->builtin_executable = builtin_executable;
../../drivers/metal/direct_command_buffer.m:  iree_arena_initialize(block_pool, &command_buffer->arena);
../../drivers/metal/direct_command_buffer.m:  command_buffer->staging_buffer = staging_buffer;
../../drivers/metal/direct_command_buffer.m:  command_buffer->host_allocator = host_allocator;
../../drivers/metal/direct_command_buffer.m:  iree_status_t status = iree_hal_resource_set_allocate(block_pool, &command_buffer->resource_set);
../../drivers/metal/direct_command_buffer.m:    iree_hal_metal_command_segment_list_reset(&command_buffer->segments);
../../drivers/metal/direct_command_buffer.m:      command_buffer->command_buffer =
../../drivers/metal/direct_command_buffer.m:      [descriptor release];                                         // -1
../../drivers/metal/direct_command_buffer.m:    command_buffer->dispatch_type =
../../drivers/metal/direct_command_buffer.m:        params->command_dispatch_type == IREE_HAL_METAL_COMMAND_DISPATCH_TYPE_CONCURRENT
../../drivers/metal/direct_command_buffer.m:    command_buffer->state.compute_encoder = nil;
../../drivers/metal/direct_command_buffer.m:    command_buffer->state.blit_encoder = nil;
../../drivers/metal/direct_command_buffer.m:    command_buffer->state.encoder_event = [queue.device newEvent];  // +1
../../drivers/metal/direct_command_buffer.m:    command_buffer->state.next_encoder_event_value = 1;
../../drivers/metal/direct_command_buffer.m:    *out_command_buffer = &command_buffer->base;
../../drivers/metal/direct_command_buffer.m:    iree_hal_metal_command_buffer_destroy_internal(&command_buffer->base);
../../drivers/metal/direct_command_buffer.m:  [command_buffer->state.encoder_event release];  // -1
../../drivers/metal/direct_command_buffer.m:  IREE_ASSERT_EQ(command_buffer->state.compute_encoder, nil);
../../drivers/metal/direct_command_buffer.m:  IREE_ASSERT_EQ(command_buffer->state.blit_encoder, nil);
../../drivers/metal/direct_command_buffer.m:  [command_buffer->command_buffer release];  // -1
../../drivers/metal/direct_command_buffer.m:  [command_buffer->queue release];           // -1
../../drivers/metal/direct_command_buffer.m:  iree_hal_resource_set_free(command_buffer->resource_set);
../../drivers/metal/direct_command_buffer.m:  iree_arena_deinitialize(&command_buffer->arena);
../../drivers/metal/direct_command_buffer.m:  iree_allocator_free(command_buffer->host_allocator, command_buffer);
../../drivers/metal/direct_command_buffer.m:  iree_hal_device_t* device = command_buffer->device;
../../drivers/metal/direct_command_buffer.m:  if (command_buffer->staging_buffer) {
../../drivers/metal/direct_command_buffer.m:    iree_hal_metal_staging_buffer_decrease_command_buffer_refcount(command_buffer->staging_buffer);
../../drivers/metal/direct_command_buffer.m:  return iree_hal_resource_is(&command_buffer->resource, &iree_hal_metal_command_buffer_vtable);
../../drivers/metal/direct_command_buffer.m:    return iree_make_status(IREE_STATUS_UNIMPLEMENTED, "non-zero barrier flag not yet supported");
../../drivers/metal/direct_command_buffer.m:      z0, iree_arena_allocate(&command_buffer->arena, sizeof(*segment) + buffer_barrier_length,
../../drivers/metal/direct_command_buffer.m:  // memory barriers because in Metal there is only coarse-grained full memory barrier affecting
../../drivers/metal/direct_command_buffer.m:  // all buffers, regardless of the fine-grained details from IREE HAL barriers.
../../drivers/metal/direct_command_buffer.m:  segment->action = IREE_HAL_METAL_COMMAND_SEGMENT_ACTION_BARRIER;
../../drivers/metal/direct_command_buffer.m:  iree_hal_metal_command_segment_list_push_back(&command_buffer->segments, segment);
../../drivers/metal/direct_command_buffer.m:  segment->barrier.memory_barrier_count = memory_barrier_count;
../../drivers/metal/direct_command_buffer.m:  segment->barrier.buffer_barrier_count = buffer_barrier_count;
../../drivers/metal/direct_command_buffer.m:  segment->barrier.buffer_barriers = (const iree_hal_buffer_barrier_t*)barrier_ptr;
../../drivers/metal/direct_command_buffer.m:  if (segment->memory_barrier_count == 0 && segment->buffer_barrier_count == 0) {
../../drivers/metal/direct_command_buffer.m:    id<MTLCommandBuffer> metal_handle = command_buffer->command_buffer;
../../drivers/metal/direct_command_buffer.m:    uint64_t event_value = command_buffer->state.next_encoder_event_value++;
../../drivers/metal/direct_command_buffer.m:    [metal_handle encodeSignalEvent:command_buffer->state.encoder_event value:event_value];
../../drivers/metal/direct_command_buffer.m:    [metal_handle encodeWaitForEvent:command_buffer->state.encoder_event value:event_value];
../../drivers/metal/direct_command_buffer.m:  if (segment->memory_barrier_count != 0) {
../../drivers/metal/direct_command_buffer.m:    // If there is a memory barrier specified, we have to place a catch-all barrier for all buffers.
../../drivers/metal/direct_command_buffer.m:    // Metal does not provide a more fine-grained control here.
../../drivers/metal/direct_command_buffer.m:  if (segment->buffer_barrier_count != 0) {
../../drivers/metal/direct_command_buffer.m:        (id<MTLResource>*)iree_alloca(sizeof(id<MTLResource>) * segment->buffer_barrier_count);
../../drivers/metal/direct_command_buffer.m:    for (iree_host_size_t i = 0; i < segment->buffer_barrier_count; ++i) {
../../drivers/metal/direct_command_buffer.m:          iree_hal_buffer_allocated_buffer(segment->buffer_barriers[i].buffer_ref.buffer));
../../drivers/metal/direct_command_buffer.m:    [encoder memoryBarrierWithResources:resources count:segment->buffer_barrier_count];
../../drivers/metal/direct_command_buffer.m:// Duplicates the given |pattern| into 4-bytes and returns the value.
../../drivers/metal/direct_command_buffer.m:      z0, iree_arena_allocate(&command_buffer->arena, sizeof(*segment) + pattern_length,
../../drivers/metal/direct_command_buffer.m:  segment->action = IREE_HAL_METAL_COMMAND_SEGMENT_ACTION_FILL_BUFFER;
../../drivers/metal/direct_command_buffer.m:  iree_hal_metal_command_segment_list_push_back(&command_buffer->segments, segment);
../../drivers/metal/direct_command_buffer.m:  segment->fill_buffer.target_buffer = target_device_buffer;
../../drivers/metal/direct_command_buffer.m:  segment->fill_buffer.target_offset = target_offset;
../../drivers/metal/direct_command_buffer.m:  segment->fill_buffer.length = target_ref.length;
../../drivers/metal/direct_command_buffer.m:  segment->fill_buffer.pattern = (const void*)pattern_ptr;
../../drivers/metal/direct_command_buffer.m:  segment->fill_buffer.pattern_length = pattern_length;
../../drivers/metal/direct_command_buffer.m:      iree_hal_resource_set_insert(command_buffer->resource_set, 1, &target_ref.buffer);
../../drivers/metal/direct_command_buffer.m:  const bool can_use_metal_api = segment->target_offset % 4 == 0 && segment->length % 4 == 0 &&
../../drivers/metal/direct_command_buffer.m:                                     segment->pattern, segment->pattern_length, &pattern_1byte);
../../drivers/metal/direct_command_buffer.m:      segment->pattern, segment->pattern_length, &pattern_1byte);
../../drivers/metal/direct_command_buffer.m:    [encoder fillBuffer:segment->target_buffer
../../drivers/metal/direct_command_buffer.m:                  range:NSMakeRange(segment->target_offset, segment->length)
../../drivers/metal/direct_command_buffer.m:      iree_hal_metal_duplicate_to_four_byte_value(segment->pattern, segment->pattern_length);
../../drivers/metal/direct_command_buffer.m:      command_buffer->builtin_executable, compute_encoder, segment->target_buffer,
../../drivers/metal/direct_command_buffer.m:      segment->target_offset, segment->length, pattern_4byte);
../../drivers/metal/direct_command_buffer.m:      z0, iree_arena_allocate(&command_buffer->arena, sizeof(*segment), (void**)&storage_base));
../../drivers/metal/direct_command_buffer.m:  segment->action = IREE_HAL_METAL_COMMAND_SEGMENT_ACTION_COPY_BUFFER;
../../drivers/metal/direct_command_buffer.m:  iree_hal_metal_command_segment_list_push_back(&command_buffer->segments, segment);
../../drivers/metal/direct_command_buffer.m:  segment->copy_buffer.source_buffer = source_device_buffer;
../../drivers/metal/direct_command_buffer.m:  segment->copy_buffer.source_offset = source_offset;
../../drivers/metal/direct_command_buffer.m:  segment->copy_buffer.target_buffer = target_device_buffer;
../../drivers/metal/direct_command_buffer.m:  segment->copy_buffer.target_offset = target_offset;
../../drivers/metal/direct_command_buffer.m:  segment->copy_buffer.length = length;
../../drivers/metal/direct_command_buffer.m:  bool can_use_metal_api = segment->source_offset % 4 == 0 && segment->target_offset % 4 == 0 &&
../../drivers/metal/direct_command_buffer.m:                           segment->length % 4 == 0;
../../drivers/metal/direct_command_buffer.m:    [encoder copyFromBuffer:segment->source_buffer
../../drivers/metal/direct_command_buffer.m:               sourceOffset:segment->source_offset
../../drivers/metal/direct_command_buffer.m:                   toBuffer:segment->target_buffer
../../drivers/metal/direct_command_buffer.m:          destinationOffset:segment->target_offset
../../drivers/metal/direct_command_buffer.m:                       size:segment->length];
../../drivers/metal/direct_command_buffer.m:        command_buffer->builtin_executable, encoder, segment->source_buffer, segment->source_offset,
../../drivers/metal/direct_command_buffer.m:        segment->target_buffer, segment->target_offset, segment->length);
../../drivers/metal/direct_command_buffer.m:      z0, iree_hal_metal_staging_buffer_append(command_buffer->staging_buffer, source_data_span,
../../drivers/metal/direct_command_buffer.m:      z0, iree_hal_resource_set_insert(command_buffer->resource_set, 1, &target_ref.buffer));
../../drivers/metal/direct_command_buffer.m:      command_buffer, command_buffer->staging_buffer->metal_buffer, offset, target_device_buffer,
../../drivers/metal/direct_command_buffer.m:      z0, iree_hal_resource_set_insert(command_buffer->resource_set, IREE_ARRAYSIZE(resources),
../../drivers/metal/direct_command_buffer.m:      z0, iree_hal_resource_set_insert(command_buffer->resource_set, resource_count, &executable));
../../drivers/metal/direct_command_buffer.m:      z0, iree_arena_allocate(&command_buffer->arena, total_size, (void**)&storage_base));
../../drivers/metal/direct_command_buffer.m:  segment->action = IREE_HAL_METAL_COMMAND_SEGMENT_ACTION_DISPATCH;
../../drivers/metal/direct_command_buffer.m:  iree_hal_metal_command_segment_list_push_back(&command_buffer->segments, segment);
../../drivers/metal/direct_command_buffer.m:  segment->dispatch.pipeline = pipeline;
../../drivers/metal/direct_command_buffer.m:  segment->dispatch.threadgroup_size =
../../drivers/metal/direct_command_buffer.m:                               : pipeline->threadgroup_size;
../../drivers/metal/direct_command_buffer.m:  segment->dispatch.descriptor_count = bindings.count;
../../drivers/metal/direct_command_buffer.m:  segment->dispatch.descriptors = (iree_hal_metal_descriptor_t*)(storage_base + sizeof(*segment));
../../drivers/metal/direct_command_buffer.m:    iree_hal_metal_descriptor_t* descriptor = &segment->dispatch.descriptors[i];
../../drivers/metal/direct_command_buffer.m:    descriptor->binding = i;
../../drivers/metal/direct_command_buffer.m:    descriptor->buffer = bindings.values[i].buffer;
../../drivers/metal/direct_command_buffer.m:    descriptor->offset = bindings.values[i].offset;
../../drivers/metal/direct_command_buffer.m:    if (iree_any_bit_set(pipeline->binding_read_only_bits, binding_bit)) {
../../drivers/metal/direct_command_buffer.m:    descriptor->usage = usage;
../../drivers/metal/direct_command_buffer.m:    if (descriptor->buffer) {
../../drivers/metal/direct_command_buffer.m:          z0, iree_hal_resource_set_insert(command_buffer->resource_set, 1, &descriptor->buffer));
../../drivers/metal/direct_command_buffer.m:  segment->dispatch.constant_count = constants.data_length / sizeof(uint32_t);
../../drivers/metal/direct_command_buffer.m:  segment->dispatch.constants = (uint32_t*)constant_ptr;
../../drivers/metal/direct_command_buffer.m:    segment->dispatch.workgroups_buffer = iree_hal_metal_buffer_handle(
../../drivers/metal/direct_command_buffer.m:    segment->dispatch.workgroups_offset = config.workgroup_count_ref.offset;
../../drivers/metal/direct_command_buffer.m:    segment->dispatch.workgroup_count = MTLSizeMake(
../../drivers/metal/direct_command_buffer.m:  [compute_encoder setComputePipelineState:segment->pipeline->pipeline_state];
../../drivers/metal/direct_command_buffer.m:  if (segment->constant_count != 0) {
../../drivers/metal/direct_command_buffer.m:    [compute_encoder setBytes:(void*)segment->constants
../../drivers/metal/direct_command_buffer.m:                       length:segment->constant_count * sizeof(int32_t)
../../drivers/metal/direct_command_buffer.m:  iree_hal_metal_descriptor_t* descriptors = segment->descriptors;
../../drivers/metal/direct_command_buffer.m:  id<MTLBuffer> argument_buffer = command_buffer->staging_buffer->metal_buffer;
../../drivers/metal/direct_command_buffer.m:      [segment->pipeline->function newArgumentEncoderWithBufferIndex:0];  // +1
../../drivers/metal/direct_command_buffer.m:              command_buffer->staging_buffer, argument_encoder.encodedLength,
../../drivers/metal/direct_command_buffer.m:  for (iree_host_size_t i = 0; i < segment->descriptor_count; ++i) {
../../drivers/metal/direct_command_buffer.m:  [argument_encoder release];  // -1
../../drivers/metal/direct_command_buffer.m:  if (segment->workgroups_buffer == nil) {
../../drivers/metal/direct_command_buffer.m:    [compute_encoder dispatchThreadgroups:segment->workgroup_count
../../drivers/metal/direct_command_buffer.m:                    threadsPerThreadgroup:segment->threadgroup_size];
../../drivers/metal/direct_command_buffer.m:    [compute_encoder dispatchThreadgroupsWithIndirectBuffer:segment->workgroups_buffer
../../drivers/metal/direct_command_buffer.m:                                       indirectBufferOffset:segment->workgroups_offset
../../drivers/metal/direct_command_buffer.m:                                      threadsPerThreadgroup:segment->threadgroup_size];
../../drivers/metal/direct_command_buffer.m:  for (iree_hal_metal_command_segment_t* segment = command_buffer->segments.head; segment;
../../drivers/metal/direct_command_buffer.m:       segment = segment->next_segment) {
../../drivers/metal/direct_command_buffer.m:    switch (segment->action) {
../../drivers/metal/direct_command_buffer.m:            z0, iree_hal_metal_command_segment_record_barrier(command_buffer, &segment->barrier));
../../drivers/metal/direct_command_buffer.m:            z0, iree_hal_metal_command_segment_record_dispatch(command_buffer, &segment->dispatch));
../../drivers/metal/direct_command_buffer.m:                                                  command_buffer, &segment->fill_buffer));
../../drivers/metal/direct_command_buffer.m:                                                  command_buffer, &segment->copy_buffer));
../../drivers/cuda/registration/CMakeLists.txt:# CMake-only content.                                                          #
../../drivers/cuda/nccl_dynamic_symbols.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/nccl_dynamic_symbols.c:        syms->dylib, name, (void**)&syms->nccl_symbol_name)); \
../../drivers/cuda/nccl_dynamic_symbols.c:        syms->dylib, name, (void**)&syms->nccl_symbol_name)); \
../../drivers/cuda/nccl_dynamic_symbols.c:  if (!cuda_library->dylib) {
../../drivers/cuda/nccl_dynamic_symbols.c:      host_allocator, &out_syms->dylib);
../../drivers/cuda/nccl_dynamic_symbols.c:    status = iree_hal_cuda_nccl_check_version(out_syms->dylib);
../../drivers/cuda/nccl_dynamic_symbols.c:    iree_dynamic_library_release(out_syms->dylib);
../../drivers/cuda/nccl_dynamic_symbols.c:    out_syms->dylib = NULL;
../../drivers/cuda/nccl_dynamic_symbols.c:  iree_dynamic_library_release(syms->dylib);
../../drivers/metal/registration/CMakeLists.txt:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/cts/CMakeLists.txt:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/cts/CMakeLists.txt:    "--cuda_use_streams=false"
../../drivers/cuda/cts/CMakeLists.txt:    requires-gpu-nvidia
../../drivers/cuda/cts/CMakeLists.txt:    "--cuda_use_streams=true"
../../drivers/cuda/cts/CMakeLists.txt:    requires-gpu-nvidia
../../drivers/cuda/timepoint_pool.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/timepoint_pool.h://===----------------------------------------------------------------------===//
../../drivers/cuda/timepoint_pool.h://===----------------------------------------------------------------------===//
../../drivers/cuda/timepoint_pool.h:// Thread-compatible; a timepoint is typically only accessed by one thread.
../../drivers/cuda/timepoint_pool.h://===----------------------------------------------------------------------===//
../../drivers/cuda/timepoint_pool.h://===----------------------------------------------------------------------===//
../../drivers/cuda/timepoint_pool.h:// Thread-safe; multiple threads may acquire and release timepoints from the
../../drivers/cuda/registration/driver_module.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/registration/driver_module.c:    "Enables CUDA asynchronous stream-ordered allocations when supported.");
../../drivers/cuda/registration/driver_module.c:    "   2 : fine-grained kernel level tracing enabled.\n");
../../drivers/cuda/cuda_allocator.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/registration/BUILD.bazel:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/metal/direct_allocator.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/registration/driver_module.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/README.md:[source]: ../../../../../../docs/website/docs/developers/design-docs/cuda-hal-driver.md
../../drivers/cuda/README.md:[website]: https://iree.dev/developers/design-docs/cuda-hal-driver
../../drivers/metal/shared_event.m:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/metal/shared_event.m:  return semaphore->shared_event;
../../drivers/metal/shared_event.m:    iree_hal_resource_initialize(&iree_hal_metal_shared_event_vtable, &semaphore->resource);
../../drivers/metal/shared_event.m:    semaphore->shared_event = [device newSharedEvent];  // +1
../../drivers/metal/shared_event.m:    semaphore->shared_event.signaledValue = initial_value;
../../drivers/metal/shared_event.m:    semaphore->event_listener = listener;
../../drivers/metal/shared_event.m:    semaphore->host_allocator = host_allocator;
../../drivers/metal/shared_event.m:    iree_slim_mutex_initialize(&semaphore->state_mutex);
../../drivers/metal/shared_event.m:    semaphore->failure_state = iree_ok_status();
../../drivers/metal/shared_event.m:  [semaphore->shared_event release];  // -1
../../drivers/metal/shared_event.m:  iree_slim_mutex_deinitialize(&semaphore->state_mutex);
../../drivers/metal/shared_event.m:  iree_allocator_free(semaphore->host_allocator, semaphore);
../../drivers/metal/shared_event.m:  uint64_t value = semaphore->shared_event.signaledValue;
../../drivers/metal/shared_event.m:    iree_slim_mutex_lock(&semaphore->state_mutex);
../../drivers/metal/shared_event.m:    status = semaphore->failure_state;
../../drivers/metal/shared_event.m:    iree_slim_mutex_unlock(&semaphore->state_mutex);
../../drivers/metal/shared_event.m:  uint64_t value = semaphore->shared_event.signaledValue;
../../drivers/metal/shared_event.m:    iree_slim_mutex_lock(&semaphore->state_mutex);
../../drivers/metal/shared_event.m:    status = semaphore->failure_state;
../../drivers/metal/shared_event.m:    iree_slim_mutex_unlock(&semaphore->state_mutex);
../../drivers/metal/shared_event.m:  semaphore->shared_event.signaledValue = new_value;
../../drivers/metal/shared_event.m:  iree_slim_mutex_lock(&semaphore->state_mutex);
../../drivers/metal/shared_event.m:  semaphore->failure_state = status;
../../drivers/metal/shared_event.m:  semaphore->shared_event.signaledValue = IREE_HAL_SEMAPHORE_FAILURE_VALUE;
../../drivers/metal/shared_event.m:  iree_slim_mutex_unlock(&semaphore->state_mutex);
../../drivers/metal/shared_event.m:    timeout_ns = (uint64_t)(deadline_ns - now_ns);
../../drivers/metal/shared_event.m:  [semaphore->shared_event notifyListener:semaphore->event_listener
../../drivers/metal/shared_event.m:  if (semaphore_list->count == 0) return iree_ok_status();
../../drivers/metal/shared_event.m:  if (semaphore_list->count == 1) {
../../drivers/metal/shared_event.m:    return iree_hal_metal_shared_event_wait(semaphore_list->semaphores[0],
../../drivers/metal/shared_event.m:                                            semaphore_list->payload_values[0], timeout);
../../drivers/metal/shared_event.m:    timeout_ns = (uint64_t)(deadline_ns - now_ns);
../../drivers/metal/shared_event.m:  iree_host_size_t total_count = (wait_mode == IREE_HAL_WAIT_MODE_ALL) ? semaphore_list->count : 1;
../../drivers/metal/shared_event.m:  for (iree_host_size_t i = 0; i < semaphore_list->count; ++i) {
../../drivers/metal/shared_event.m:        iree_hal_metal_shared_event_cast(semaphore_list->semaphores[i]);
../../drivers/metal/shared_event.m:    [semaphore->shared_event notifyListener:semaphore->event_listener
../../drivers/metal/shared_event.m:                                    atValue:semaphore_list->payload_values[i]
../../drivers/metal/README.md:[source]: ../../../../../../docs/website/docs/developers/design-docs/metal-hal-driver.md
../../drivers/metal/README.md:[website]: https://iree.dev/developers/design-docs/metal-hal-driver
../../drivers/metal/metal_buffer.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/metal/metal_buffer.m:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/metal/metal_buffer.m:    iree_hal_buffer_initialize(placement, &buffer->base, allocation_size, byte_offset, byte_length,
../../drivers/metal/metal_buffer.m:                               &iree_hal_metal_buffer_vtable, &buffer->base);
../../drivers/metal/metal_buffer.m:    buffer->host_allocator = host_allocator;
../../drivers/metal/metal_buffer.m:    buffer->buffer = [metal_buffer retain];  // +1
../../drivers/metal/metal_buffer.m:    buffer->queue = queue;
../../drivers/metal/metal_buffer.m:    buffer->release_callback = release_callback;
../../drivers/metal/metal_buffer.m:    *out_buffer = &buffer->base;
../../drivers/metal/metal_buffer.m:  iree_allocator_t host_allocator = buffer->host_allocator;
../../drivers/metal/metal_buffer.m:  if (buffer->release_callback.fn) {
../../drivers/metal/metal_buffer.m:    buffer->release_callback.fn(buffer->release_callback.user_data, base_buffer);
../../drivers/metal/metal_buffer.m:  [buffer->buffer release];  // -1
../../drivers/metal/metal_buffer.m:  return buffer->release_callback.fn != NULL;
../../drivers/metal/metal_buffer.m:  return buffer->buffer;
../../drivers/metal/metal_buffer.m:  if (buffer->buffer.storageMode == MTLStorageModeManaged) {
../../drivers/metal/metal_buffer.m:    id<MTLCommandBuffer> command_buffer = [buffer->queue commandBuffer];
../../drivers/metal/metal_buffer.m:    [blitCommandEncoder synchronizeResource:buffer->buffer];
../../drivers/metal/metal_buffer.m:  if (buffer->buffer.storageMode == MTLStorageModeManaged) {
../../drivers/metal/metal_buffer.m:    [buffer->buffer didModifyRange:NSMakeRange(local_byte_offset, local_byte_length)];
../../drivers/metal/metal_buffer.m:  void* host_ptr = buffer->buffer.contents;
../../drivers/metal/metal_buffer.m:      iree_hal_metal_require_autosync_cpu_gpu(base_buffer, buffer->buffer)) {
../../drivers/metal/metal_buffer.m:  mapping->contents = iree_make_byte_span(data_ptr, local_byte_length);
../../drivers/metal/metal_buffer.m:  if (iree_hal_metal_require_autosync_cpu_gpu(base_buffer, buffer->buffer)) {
../../drivers/cuda/nccl_channel.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/nccl_channel.h:  for (iree_host_size_t i = 0; i < IREE_ARRAYSIZE(id->data); ++i) {
../../drivers/cuda/nccl_channel.h:    if (id->data[i] != 0) return false;
../../drivers/cuda/nccl_channel.h:// Performs a non-blocking submission of |batch| to |stream|.
../../drivers/null/CMakeLists.txt:# CMake-only content.                                                          #
../../drivers/cuda/cuda_headers.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/null/channel.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/null/channel.h://===----------------------------------------------------------------------===//
../../drivers/null/channel.h://===----------------------------------------------------------------------===//
../../drivers/cuda/event_semaphore.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/event_semaphore.c:  // than trying to make the entire structure lock-free.
../../drivers/cuda/event_semaphore.c:                                &semaphore->base);
../../drivers/cuda/event_semaphore.c:  semaphore->host_allocator = host_allocator;
../../drivers/cuda/event_semaphore.c:  semaphore->symbols = symbols;
../../drivers/cuda/event_semaphore.c:  semaphore->timepoint_pool = timepoint_pool;
../../drivers/cuda/event_semaphore.c:  semaphore->work_queue = work_queue;
../../drivers/cuda/event_semaphore.c:  iree_slim_mutex_initialize(&semaphore->mutex);
../../drivers/cuda/event_semaphore.c:  semaphore->current_value = initial_value;
../../drivers/cuda/event_semaphore.c:  semaphore->failure_status = iree_ok_status();
../../drivers/cuda/event_semaphore.c:  *out_semaphore = &semaphore->base;
../../drivers/cuda/event_semaphore.c:  iree_allocator_t host_allocator = semaphore->host_allocator;
../../drivers/cuda/event_semaphore.c:  iree_status_ignore(semaphore->failure_status);
../../drivers/cuda/event_semaphore.c:  iree_slim_mutex_deinitialize(&semaphore->mutex);
../../drivers/cuda/event_semaphore.c:  iree_hal_semaphore_deinitialize(&semaphore->base);
../../drivers/cuda/event_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/cuda/event_semaphore.c:  *out_value = semaphore->current_value;
../../drivers/cuda/event_semaphore.c:    status = iree_status_clone(semaphore->failure_status);
../../drivers/cuda/event_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/cuda/event_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/cuda/event_semaphore.c:  if (new_value <= semaphore->current_value) {
../../drivers/cuda/event_semaphore.c:    uint64_t current_value IREE_ATTRIBUTE_UNUSED = semaphore->current_value;
../../drivers/cuda/event_semaphore.c:    iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/cuda/event_semaphore.c:  semaphore->current_value = new_value;
../../drivers/cuda/event_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/cuda/event_semaphore.c:  // Notify timepoints - note that this must happen outside the lock.
../../drivers/cuda/event_semaphore.c:  iree_hal_semaphore_notify(&semaphore->base, new_value, IREE_STATUS_OK);
../../drivers/cuda/event_semaphore.c:      iree_hal_deferred_work_queue_issue(semaphore->work_queue);
../../drivers/cuda/event_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/cuda/event_semaphore.c:  // Try to set our local status - we only preserve the first failure so only
../../drivers/cuda/event_semaphore.c:  if (!iree_status_is_ok(semaphore->failure_status)) {
../../drivers/cuda/event_semaphore.c:    iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/cuda/event_semaphore.c:  semaphore->current_value = IREE_HAL_SEMAPHORE_FAILURE_VALUE;
../../drivers/cuda/event_semaphore.c:  semaphore->failure_status = status;
../../drivers/cuda/event_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/cuda/event_semaphore.c:  // Notify timepoints - note that this must happen outside the lock.
../../drivers/cuda/event_semaphore.c:  iree_hal_semaphore_notify(&semaphore->base, IREE_HAL_SEMAPHORE_FAILURE_VALUE,
../../drivers/cuda/event_semaphore.c:  status = iree_hal_deferred_work_queue_issue(semaphore->work_queue);
../../drivers/cuda/event_semaphore.c:  iree_event_set(&timepoint->timepoint.host_wait);
../../drivers/cuda/event_semaphore.c:              semaphore->timepoint_pool, 1, out_timepoint));
../../drivers/cuda/event_semaphore.c:      &semaphore->base, min_value, timeout,
../../drivers/cuda/event_semaphore.c:      &(*out_timepoint)->base);
../../drivers/cuda/event_semaphore.c:  iree_slim_mutex_lock(&semaphore->base.timepoint_mutex);
../../drivers/cuda/event_semaphore.c:  for (iree_hal_semaphore_timepoint_t* tp = semaphore->base.timepoint_list.head;
../../drivers/cuda/event_semaphore.c:       tp != NULL; tp = tp->next) {
../../drivers/cuda/event_semaphore.c:    if (signal_timepoint->kind == IREE_HAL_CUDA_TIMEPOINT_KIND_DEVICE_SIGNAL &&
../../drivers/cuda/event_semaphore.c:        signal_timepoint->base.minimum_value >= min_value) {
../../drivers/cuda/event_semaphore.c:      *out_event = signal_timepoint->timepoint.device_signal;
../../drivers/cuda/event_semaphore.c:  iree_slim_mutex_unlock(&semaphore->base.timepoint_mutex);
../../drivers/cuda/event_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/cuda/event_semaphore.c:  if (!iree_status_is_ok(semaphore->failure_status)) {
../../drivers/cuda/event_semaphore.c:    iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/cuda/event_semaphore.c:  if (semaphore->current_value >= value) {
../../drivers/cuda/event_semaphore.c:    iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/cuda/event_semaphore.c:    iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/cuda/event_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/cuda/event_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/cuda/event_semaphore.c:  if (semaphore->current_value >= IREE_HAL_SEMAPHORE_FAILURE_VALUE) {
../../drivers/cuda/event_semaphore.c:    iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/cuda/event_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/cuda/event_semaphore.c:      iree_wait_one(&timepoint->timepoint.host_wait, deadline_ns);
../../drivers/cuda/event_semaphore.c:  status = iree_wait_one(&timepoint->timepoint.host_wait, deadline_ns);
../../drivers/cuda/event_semaphore.c:    iree_hal_semaphore_cancel_timepoint(&semaphore->base, &timepoint->base);
../../drivers/cuda/event_semaphore.c:  iree_hal_cuda_timepoint_pool_release(semaphore->timepoint_pool, 1,
../../drivers/cuda/event_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/cuda/event_semaphore.c:  if (semaphore->current_value >= IREE_HAL_SEMAPHORE_FAILURE_VALUE) {
../../drivers/cuda/event_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/cuda/event_semaphore.c:    // Fast-path for a single semaphore.
../../drivers/cuda/event_semaphore.c:      status = iree_wait_set_insert(wait_set, timepoint->timepoint.host_wait);
../../drivers/cuda/event_semaphore.c:    iree_hal_semaphore_t* semaphore = timepoint->base.semaphore;
../../drivers/cuda/event_semaphore.c:      iree_hal_semaphore_cancel_timepoint(semaphore, &timepoint->base);
../../drivers/cuda/event_semaphore.c:    iree_hal_cuda_timepoint_pool_release(timepoint->pool, 1, &timepoint);
../../drivers/cuda/event_semaphore.c:    iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/cuda/event_semaphore.c:    if (semaphore->current_value >= IREE_HAL_SEMAPHORE_FAILURE_VALUE) {
../../drivers/cuda/event_semaphore.c:      iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/cuda/event_semaphore.c:    iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/cuda/event_semaphore.c:  iree_hal_cuda_timepoint_pool_release(timepoint->pool, 1, &timepoint);
../../drivers/cuda/event_semaphore.c:              semaphore->timepoint_pool, 1, &signal_timepoint));
../../drivers/cuda/event_semaphore.c:      &semaphore->base, to_value, iree_infinite_timeout(),
../../drivers/cuda/event_semaphore.c:      &signal_timepoint->base);
../../drivers/cuda/event_semaphore.c:  iree_hal_cuda_event_t* event = signal_timepoint->timepoint.device_signal;
../../drivers/cuda/event_semaphore.c:  iree_slim_mutex_lock(&semaphore->base.timepoint_mutex);
../../drivers/cuda/event_semaphore.c:  for (iree_hal_semaphore_timepoint_t* tp = semaphore->base.timepoint_list.head;
../../drivers/cuda/event_semaphore.c:       tp != NULL; tp = tp->next) {
../../drivers/cuda/event_semaphore.c:    if (wait_timepoint->kind == IREE_HAL_CUDA_TIMEPOINT_KIND_DEVICE_WAIT &&
../../drivers/cuda/event_semaphore.c:        wait_timepoint->timepoint.device_wait == NULL &&
../../drivers/cuda/event_semaphore.c:        wait_timepoint->base.minimum_value <= to_value) {
../../drivers/cuda/event_semaphore.c:      wait_timepoint->timepoint.device_wait = event;
../../drivers/cuda/event_semaphore.c:  iree_slim_mutex_unlock(&semaphore->base.timepoint_mutex);
../../drivers/cuda/event_semaphore.c:  iree_hal_cuda_timepoint_pool_release(timepoint->pool, 1, &timepoint);
../../drivers/cuda/event_semaphore.c:              semaphore->timepoint_pool, 1, &wait_timepoint));
../../drivers/cuda/event_semaphore.c:      &semaphore->base, min_value, iree_infinite_timeout(),
../../drivers/cuda/event_semaphore.c:      &wait_timepoint->base);
../../drivers/cuda/event_semaphore.c:  if (iree_hal_cuda_semaphore_acquire_event_host_wait(&semaphore->base,
../../drivers/cuda/event_semaphore.c:    iree_hal_cuda_event_release(wait_timepoint->timepoint.device_wait);
../../drivers/cuda/event_semaphore.c:    wait_timepoint->timepoint.device_wait = wait_event;
../../drivers/cuda/event_semaphore.c:      iree_hal_cuda_event_handle(wait_timepoint->timepoint.device_wait);
../../drivers/cuda/cuda_status_util.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/cuda_status_util.h:  iree_hal_cuda_result_to_status((syms), ((syms)->expr), __FILE__, __LINE__)
../../drivers/cuda/cuda_status_util.h:  IREE_RETURN_IF_ERROR(iree_hal_cuda_result_to_status((syms), ((syms)->expr), \
../../drivers/cuda/cuda_status_util.h:      iree_hal_cuda_result_to_status((syms), ((syms)->expr), __FILE__,   \
../../drivers/cuda/cuda_status_util.h:  IREE_IGNORE_ERROR(iree_hal_cuda_result_to_status((syms), ((syms)->expr), \
../../drivers/null/executable.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/null/executable.h://===----------------------------------------------------------------------===//
../../drivers/null/executable.h://===----------------------------------------------------------------------===//
../../drivers/null/driver.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/null/driver.h://===----------------------------------------------------------------------===//
../../drivers/null/driver.h://===----------------------------------------------------------------------===//
../../drivers/cuda/stream_command_buffer.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/stream_command_buffer.h:// If |block_pool| is non-NULL then the stream command buffer will retain copies
../../drivers/cuda/stream_command_buffer.h:// Returns true if |command_buffer| is a CUDA stream-based command buffer.
../../drivers/cuda/BUILD.bazel:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/null/command_buffer.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/null/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/null/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/null/command_buffer.c:      &iree_hal_null_command_buffer_vtable, &command_buffer->base);
../../drivers/null/command_buffer.c:  command_buffer->host_allocator = host_allocator;
../../drivers/null/command_buffer.c:    *out_command_buffer = &command_buffer->base;
../../drivers/null/command_buffer.c:    iree_hal_command_buffer_release(&command_buffer->base);
../../drivers/null/command_buffer.c:  iree_allocator_t host_allocator = command_buffer->host_allocator;
../../drivers/null/command_buffer.c:  return iree_hal_resource_is(&command_buffer->resource,
../../drivers/null/command_buffer.c:  // happen here. Recording-only resources are no longer needed after this point
../../drivers/null/command_buffer.c:  // implementations that have no concurrency this can be a no-op. This is
../../drivers/null/command_buffer.c:  // the specified set of barriers. Implementations without fine-grained
../../drivers/null/command_buffer.c:  // madvise-like command that can be used to control prefetching and other
../../drivers/null/command_buffer.c:  // device-visible but may reside on either the host or device.
../../drivers/cuda/cuda_dynamic_symbols.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/cuda_dynamic_symbols.c:      syms->dylib, "cuGetProcAddress", (void**)&syms->cuGetProcAddress));
../../drivers/cuda/cuda_dynamic_symbols.c:        cuGetProcAddress(name, (void**)&syms->cuda_symbol_name,         \
../../drivers/cuda/cuda_dynamic_symbols.c:      IREE_DYNAMIC_LIBRARY_FLAG_NONE, host_allocator, &out_syms->dylib);
../../drivers/cuda/cuda_dynamic_symbols.c:  iree_dynamic_library_release(syms->dylib);
../../drivers/cuda/nccl_dynamic_symbols.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/nccl_dynamic_symbols.h:// Initializes |out_syms| in-place with dynamically loaded NCCL symbols.
../../drivers/cuda/nccl_status_util.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/cuda/nccl_status_util.c:                                        syms->ncclGetErrorString(result));
../../drivers/null/command_buffer.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/null/command_buffer.h://===----------------------------------------------------------------------===//
../../drivers/null/command_buffer.h://===----------------------------------------------------------------------===//
../../drivers/metal/metal_device.m:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/metal/metal_device.m:  // Per-queue staging buffer for parameter uploads.
../../drivers/metal/metal_device.m:  // A dispatch queue and associated event listener for running Objective-C blocks to signal
../../drivers/metal/metal_device.m:  out_params->arena_block_size = 32 * 1024;
../../drivers/metal/metal_device.m:  out_params->queue_uniform_buffer_size = IREE_HAL_METAL_STAGING_BUFFER_DEFAULT_CAPACITY;
../../drivers/metal/metal_device.m:  out_params->command_dispatch_type = IREE_HAL_METAL_COMMAND_DISPATCH_TYPE_CONCURRENT;
../../drivers/metal/metal_device.m:  out_params->command_buffer_resource_reference_mode =
../../drivers/metal/metal_device.m:  out_params->resource_hazard_tracking_mode =
../../drivers/metal/metal_device.m:  return &device->params;
../../drivers/metal/metal_device.m:  iree_hal_resource_initialize(&iree_hal_metal_device_vtable, &device->resource);
../../drivers/metal/metal_device.m:  iree_string_view_append_to_buffer(identifier, &device->identifier,
../../drivers/metal/metal_device.m:  iree_arena_block_pool_initialize(params->arena_block_size, host_allocator, &device->block_pool);
../../drivers/metal/metal_device.m:  device->params = *params;
../../drivers/metal/metal_device.m:  device->host_allocator = host_allocator;
../../drivers/metal/metal_device.m:  device->device = [metal_device retain];                            // +1
../../drivers/metal/metal_device.m:  device->queue = metal_queue;
../../drivers/metal/metal_device.m:  descriptor.retainedReferences = params->command_buffer_resource_reference_mode ==
../../drivers/metal/metal_device.m:  device->command_buffer_descriptor = descriptor;
../../drivers/metal/metal_device.m:  device->command_buffer_resource_reference_mode = params->command_buffer_resource_reference_mode;
../../drivers/metal/metal_device.m:  device->semaphore_notification_queue = dispatch_queue_create("dev.iree.queue.metal", queue_attr);
../../drivers/metal/metal_device.m:  device->event_listener = [[MTLSharedEventListener alloc]
../../drivers/metal/metal_device.m:      initWithDispatchQueue:device->semaphore_notification_queue];  // +1
../../drivers/metal/metal_device.m:  device->capture_manager = NULL;
../../drivers/metal/metal_device.m:                                                         params->resource_hazard_tracking_mode,
../../drivers/metal/metal_device.m:                                                         host_allocator, &device->device_allocator);
../../drivers/metal/metal_device.m:                                                      &device->builtin_executable);
../../drivers/metal/metal_device.m:        metal_device, params->queue_uniform_buffer_size, &device->staging_buffer);
../../drivers/metal/metal_device.m:  [device->event_listener release];  // -1
../../drivers/metal/metal_device.m:  dispatch_release(device->semaphore_notification_queue);
../../drivers/metal/metal_device.m:  iree_hal_metal_builtin_executable_destroy(device->builtin_executable);
../../drivers/metal/metal_device.m:  iree_hal_allocator_release(device->device_allocator);
../../drivers/metal/metal_device.m:  [device->command_buffer_descriptor release];  // -1
../../drivers/metal/metal_device.m:  [device->queue release];                      // -1
../../drivers/metal/metal_device.m:  [device->device release];                     // -1
../../drivers/metal/metal_device.m:  iree_hal_metal_staging_buffer_deinitialize(&device->staging_buffer);
../../drivers/metal/metal_device.m:  iree_arena_block_pool_deinitialize(&device->block_pool);
../../drivers/metal/metal_device.m:  return device->identifier;
../../drivers/metal/metal_device.m:  return device->host_allocator;
../../drivers/metal/metal_device.m:  return device->device_allocator;
../../drivers/metal/metal_device.m:  iree_hal_allocator_release(device->device_allocator);
../../drivers/metal/metal_device.m:  device->device_allocator = new_allocator;
../../drivers/metal/metal_device.m:  iree_arena_block_pool_trim(&device->block_pool);
../../drivers/metal/metal_device.m:  return iree_hal_allocator_trim(device->device_allocator);
../../drivers/metal/metal_device.m:    *out_value = iree_string_view_match_pattern(device->identifier, key) ? 1 : 0;
../../drivers/metal/metal_device.m:    *out_value = iree_string_view_equal(key, iree_make_cstring_view("metal-msl-fb")) ? 1 : 0;
../../drivers/metal/metal_device.m:  // TODO(indirect-cmd): natively support indirect command buffers in Metal via
../../drivers/metal/metal_device.m:        device->device_allocator, mode, command_categories, queue_affinity, binding_capacity,
../../drivers/metal/metal_device.m:        &device->block_pool, device->host_allocator, out_command_buffer);
../../drivers/metal/metal_device.m:      device->command_buffer_resource_reference_mode, device->queue, &device->block_pool,
../../drivers/metal/metal_device.m:      &device->staging_buffer, device->builtin_executable, device->host_allocator,
../../drivers/metal/metal_device.m:  return iree_hal_metal_nop_executable_cache_create(device->device, identifier,
../../drivers/metal/metal_device.m:                                                    device->host_allocator, out_executable_cache);
../../drivers/metal/metal_device.m:  return iree_hal_metal_shared_event_create(device->device, initial_value, device->event_listener,
../../drivers/metal/metal_device.m:                                            device->host_allocator, out_semaphore);
../../drivers/metal/metal_device.m:    // Fast-path for semaphores related to this device.
../../drivers/metal/metal_device.m:  // TODO(benvanik): queue-ordered allocations.
../../drivers/metal/metal_device.m:  // TODO(benvanik): queue-ordered allocations.
../../drivers/metal/metal_device.m:  // Create the transient command buffer. Note that it is one-shot and has no indirect bindings as
../../drivers/metal/metal_device.m:              /*binding_capacity=*/0, device->command_buffer_resource_reference_mode, device->queue,
../../drivers/metal/metal_device.m:              &device->block_pool, &device->staging_buffer, device->builtin_executable,
../../drivers/metal/metal_device.m:              device->host_allocator, &direct_command_buffer));
../../drivers/metal/metal_device.m:  // if any binding does not meet the requirements - having succeeded when recording initially is
../../drivers/metal/metal_device.m:      z0, iree_hal_resource_set_allocate(&device->block_pool, &resource_set));
../../drivers/metal/metal_device.m:  // Put the full semaphore list into a resource set, which retains them--we will need to access
../../drivers/metal/metal_device.m:        id<MTLCommandBuffer> wait_command_buffer = [device->queue
../../drivers/metal/metal_device.m:            commandBufferWithDescriptor:device->command_buffer_descriptor];  // autoreleased
../../drivers/metal/metal_device.m:        // TODO(indirect-cmd): support indirect command buffers and switch here, or only use
../../drivers/metal/metal_device.m:        signal_command_buffer = [device->queue
../../drivers/metal/metal_device.m:            commandBufferWithDescriptor:device->command_buffer_descriptor];  // autoreleased
../../drivers/metal/metal_device.m:        // And then release the device handle. Note that this must happen separately--if we put the
../../drivers/metal/metal_device.m:  if (device->capture_manager) {
../../drivers/metal/metal_device.m:  if (iree_all_bits_set(options->mode, IREE_HAL_DEVICE_PROFILING_MODE_QUEUE_OPERATIONS)) {
../../drivers/metal/metal_device.m:    device->capture_manager = [[MTLCaptureManager sharedCaptureManager] retain];  // +1
../../drivers/metal/metal_device.m:      if (strlen(options->file_path) != 0) {
../../drivers/metal/metal_device.m:        if (!iree_string_view_ends_with(IREE_SV(options->file_path), IREE_SV(".gputrace"))) {
../../drivers/metal/metal_device.m:        if (![device->capture_manager supportsDestination:MTLCaptureDestinationGPUTraceDocument]) {
../../drivers/metal/metal_device.m:                                  "unsupported capture to file (if invoking as command-line "
../../drivers/metal/metal_device.m:        NSString* ns_string = [NSString stringWithCString:options->file_path
../../drivers/metal/metal_device.m:      capture_descriptor.captureObject = device->device;
../../drivers/metal/metal_device.m:      if (![device->capture_manager startCaptureWithDescriptor:capture_descriptor error:&error]) {
../../drivers/metal/metal_device.m:  if (device->capture_manager) {
../../drivers/metal/metal_device.m:    [device->capture_manager stopCapture];
../../drivers/metal/metal_device.m:    [device->capture_manager release];  // -1
../../drivers/metal/metal_device.m:    device->capture_manager = NULL;
../../drivers/null/event.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/null/event.h://===----------------------------------------------------------------------===//
../../drivers/null/event.h://===----------------------------------------------------------------------===//
../../drivers/null/allocator.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/null/allocator.h://===----------------------------------------------------------------------===//
../../drivers/null/allocator.h://===----------------------------------------------------------------------===//
../../drivers/null/executable.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/null/executable.c://===----------------------------------------------------------------------===//
../../drivers/null/executable.c://===----------------------------------------------------------------------===//
../../drivers/null/executable.c:                               &executable->resource);
../../drivers/null/executable.c:  executable->host_allocator = host_allocator;
../../drivers/null/executable.c:  // unsafe. For JIT-style implementations as much work as possible should be
../../drivers/null/executable.c:  // done here so that errors can be propagated back to users - do not defer
../../drivers/null/executable.c:  // preferred format (zero-copy, mmappable, verifiable, near header-only dep
../../drivers/null/executable.c:  iree_allocator_t host_allocator = executable->host_allocator;
../../drivers/null/executable_cache.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/null/executable_cache.h://===----------------------------------------------------------------------===//
../../drivers/null/executable_cache.h://===----------------------------------------------------------------------===//
../../drivers/null/executable_cache.h:// Creates a no-op executable cache that does not cache at all.
../../drivers/null/buffer.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/null/buffer.c://===----------------------------------------------------------------------===//
../../drivers/null/buffer.c://===----------------------------------------------------------------------===//
../../drivers/null/buffer.c:  iree_hal_buffer_initialize(placement, &buffer->base, allocation_size,
../../drivers/null/buffer.c:                             &iree_hal_null_buffer_vtable, &buffer->base);
../../drivers/null/buffer.c:  buffer->host_allocator = host_allocator;
../../drivers/null/buffer.c:  buffer->release_callback = release_callback;
../../drivers/null/buffer.c:  // if there are multiple or use different top-level iree_hal_buffer_t
../../drivers/null/buffer.c:    *out_buffer = &buffer->base;
../../drivers/null/buffer.c:    iree_hal_buffer_release(&buffer->base);
../../drivers/null/buffer.c:  iree_allocator_t host_allocator = buffer->host_allocator;
../../drivers/null/buffer.c:  if (buffer->release_callback.fn) {
../../drivers/null/buffer.c:    buffer->release_callback.fn(buffer->release_callback.user_data,
../../drivers/null/buffer.c:  // TODO(null): perform mapping as described. Note that local-to-buffer range
../../drivers/null/buffer.c:  // memory range of the mapped buffer and implementation-specific information
../../drivers/null/buffer.c:  // at a large cost (alloc + device->host transfer on map and host->device
../../drivers/null/README.md:to do than the trial-and-error approach: if you can implement command buffer
../../drivers/null/README.md:   `experimental/` folder if going in-tree.
../../drivers/null/README.md:via top-level project `CMakeLists.txt` before adding the IREE subdirectory.
../../drivers/null/README.md:    -DIREE_EXTERNAL_MY_DRIVER_HAL_DRIVER_TARGET=my_driver_static_library \
../../drivers/null/README.md:    -DIREE_EXTERNAL_MY_DRIVER_HAL_DRIVER_REGISTER=my_driver_register \
../../drivers/null/README.md:    -DIREE_EXTERNAL_HAL_DRIVERS=my_driver
../../drivers/null/README.md:## In-tree Drivers (`iree/hal/drivers/...`)
../../drivers/null/README.md:IREE is generally conservative about hosting in-tree HAL drivers unless authored
../../drivers/null/README.md:by the core team or an SLA is in-place and maintained. Any new HAL drivers
../../drivers/null/README.md:monorepo and it's perfectly fine to be out-of-tree. If ergonomics issues are
../../drivers/null/registration/driver_module.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/null/registration/driver_module.c:  // TODO(null): use your driver name - this will be the prefix when the user
../../drivers/null/registration/driver_module.c:  // specifies the device (`--device=null://foo`). A single driver can support
../../drivers/null/registration/driver_module.c:  // options via this struct or key-value string parameters.
../../drivers/null/registration/CMakeLists.txt:# CMake-only content.                                                          #
../../drivers/null/registration/driver_module.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/null/semaphore.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/null/semaphore.h://===----------------------------------------------------------------------===//
../../drivers/null/semaphore.h://===----------------------------------------------------------------------===//
../../drivers/null/channel.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/null/channel.c://===----------------------------------------------------------------------===//
../../drivers/null/channel.c://===----------------------------------------------------------------------===//
../../drivers/null/channel.c:                               &channel->resource);
../../drivers/null/channel.c:  channel->host_allocator = host_allocator;
../../drivers/null/channel.c:  iree_allocator_t host_allocator = channel->host_allocator;
../../drivers/null/channel.c:  iree_hal_channel_release(channel->parent_channel);
../../drivers/null/channel.c:        iree_allocator_malloc(channel->host_allocator, sizeof(*split_channel),
../../drivers/null/channel.c:                                 &split_channel->resource);
../../drivers/null/channel.c:    split_channel->host_allocator = channel->host_allocator;
../../drivers/null/channel.c:    split_channel->parent_channel = base_channel;
../../drivers/null/executable_cache.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/null/executable_cache.c://===----------------------------------------------------------------------===//
../../drivers/null/executable_cache.c://===----------------------------------------------------------------------===//
../../drivers/null/executable_cache.c:                               &executable_cache->resource);
../../drivers/null/executable_cache.c:  executable_cache->host_allocator = host_allocator;
../../drivers/null/executable_cache.c:  // TODO(null): this default implementation is a no-op; if the implementation
../../drivers/null/executable_cache.c:  iree_allocator_t host_allocator = executable_cache->host_allocator;
../../drivers/null/executable_cache.c:                                iree_make_cstring_view("{null-executable}"));
../../drivers/null/executable_cache.c:      executable_params, executable_cache->host_allocator, out_executable);
../../drivers/null/registration/BUILD.bazel:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/null/device.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/null/device.h://===----------------------------------------------------------------------===//
../../drivers/null/device.h://===----------------------------------------------------------------------===//
../../drivers/BUILD.bazel:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/BUILD.bazel:        "local-sync",
../../drivers/BUILD.bazel:        "local-task",
../../drivers/BUILD.bazel:    "local-sync",
../../drivers/BUILD.bazel:    "local-task",
../../drivers/BUILD.bazel:               ":local-sync_enabled": ["//runtime/src/iree/hal/drivers/local_sync/registration"],
../../drivers/BUILD.bazel:               ":local-task_enabled": ["//runtime/src/iree/hal/drivers/local_task/registration"],
../../drivers/null/device.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/null/device.c://===----------------------------------------------------------------------===//
../../drivers/null/device.c://===----------------------------------------------------------------------===//
../../drivers/null/device.c://===----------------------------------------------------------------------===//
../../drivers/null/device.c://===----------------------------------------------------------------------===//
../../drivers/null/device.c:  iree_hal_resource_initialize(&iree_hal_null_device_vtable, &device->resource);
../../drivers/null/device.c:      identifier, &device->identifier,
../../drivers/null/device.c:      (char*)device + total_size - identifier.size);
../../drivers/null/device.c:  device->host_allocator = host_allocator;
../../drivers/null/device.c:      iree_hal_null_allocator_create(host_allocator, &device->device_allocator);
../../drivers/null/device.c:  iree_hal_allocator_release(device->device_allocator);
../../drivers/null/device.c:  iree_hal_channel_provider_release(device->channel_provider);
../../drivers/null/device.c:  return device->identifier;
../../drivers/null/device.c:  return device->host_allocator;
../../drivers/null/device.c:  return device->device_allocator;
../../drivers/null/device.c:  iree_hal_allocator_release(device->device_allocator);
../../drivers/null/device.c:  device->device_allocator = new_allocator;
../../drivers/null/device.c:  iree_hal_channel_provider_release(device->channel_provider);
../../drivers/null/device.c:  device->channel_provider = new_provider;
../../drivers/null/device.c:  // dropped here (unused pools/etc). This is usually called in low-memory
../../drivers/null/device.c:  IREE_RETURN_IF_ERROR(iree_hal_allocator_trim(device->device_allocator));
../../drivers/null/device.c:        iree_string_view_match_pattern(device->identifier, key) ? 1 : 0;
../../drivers/null/device.c:  // The device->channel_provider can be used to get default rank/count,
../../drivers/null/device.c:      queue_affinity, binding_capacity, device->host_allocator,
../../drivers/null/device.c:                                        device->host_allocator, out_semaphore);
../../drivers/null/device.c:  // submits command buffers with host-device blocking behavior.
../../drivers/null/device.c:  // submits command buffers with host-device blocking behavior.
../../drivers/null/device.c:  // queue affinity can be used to determine which top-level execution resources
../../drivers/null/device.c:  // TODO(null): do this async - callers may be submitting work to multiple
../../drivers/null/device.c:  // TODO(null): implement multi-wait as either an ALL (AND) or ANY (OR)
../../drivers/null/device.c:  // TODO(null): prefer having a fast-path for if the semaphores are
../../drivers/null/device.c:  // known-signaled in user-mode. This can usually avoid syscalls/ioctls and
../../drivers/null/device.c:      IREE_STATUS_UNIMPLEMENTED, "semaphore multi-wait not implemented");
../../drivers/null/device.c:  // TODO(null): set implementation-defined device or global profiling modes.
../../drivers/null/device.c:  // TODO(null): flush if needed. May be no-op. Any accumulated profiling
../../drivers/null/device.c:  // TODO(null): unset whatever profiling_begin set, if anything. May be no-op.
../../drivers/null/event.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/null/event.c://===----------------------------------------------------------------------===//
../../drivers/null/event.c://===----------------------------------------------------------------------===//
../../drivers/null/event.c:  iree_hal_resource_initialize(&iree_hal_null_event_vtable, &event->resource);
../../drivers/null/event.c:  event->host_allocator = host_allocator;
../../drivers/null/event.c:  // TODO(null): WIP API; this is a no-op today.
../../drivers/null/event.c:  iree_allocator_t host_allocator = event->host_allocator;
../../drivers/null/buffer.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/null/buffer.h://===----------------------------------------------------------------------===//
../../drivers/null/buffer.h://===----------------------------------------------------------------------===//
../../drivers/null/BUILD.bazel:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/local_task/task_event.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/null/driver.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/null/driver.c://===----------------------------------------------------------------------===//
../../drivers/null/driver.c://===----------------------------------------------------------------------===//
../../drivers/null/driver.c:  iree_hal_null_device_options_initialize(&out_options->default_device_options);
../../drivers/null/driver.c://===----------------------------------------------------------------------===//
../../drivers/null/driver.c://===----------------------------------------------------------------------===//
../../drivers/null/driver.c:  iree_hal_resource_initialize(&iree_hal_null_driver_vtable, &driver->resource);
../../drivers/null/driver.c:  driver->host_allocator = host_allocator;
../../drivers/null/driver.c:      identifier, &driver->identifier,
../../drivers/null/driver.c:      (char*)driver + total_size - identifier.size);
../../drivers/null/driver.c:  memcpy(&driver->options, options, sizeof(*options));
../../drivers/null/driver.c:  // this code may want to do that on-demand instead.
../../drivers/null/driver.c:  iree_allocator_t host_allocator = driver->host_allocator;
../../drivers/null/driver.c:  // TODO(null): add useful user-level information to the string builder for the
../../drivers/null/driver.c:  // `--dump_devices` or may be used by hosting applications for diagnostics.
../../drivers/null/driver.c:  // format of the params is implementation-defined. The params strings can be
../../drivers/null/driver.c:      driver->options.default_device_options;
../../drivers/null/driver.c:  // query_available_devices->create_device_by_id to avoid needing to expose
../../drivers/null/driver.c:  return iree_hal_null_device_create(driver->identifier, &options,
../../drivers/null/driver.c:  // format of the params is implementation-defined. The params strings can be
../../drivers/null/driver.c:      driver->options.default_device_options;
../../drivers/null/driver.c:  // implementation-specific and there may be multiple formats; for example,
../../drivers/null/driver.c:  return iree_hal_null_device_create(driver->identifier, &options,
../../drivers/local_task/task_queue_state.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/local_task/task_queue_state.h:// Thread-compatible: only intended to be used by a queue with the submission
../../drivers/local_sync/BUILD.bazel:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/null/semaphore.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/null/semaphore.c://===----------------------------------------------------------------------===//
../../drivers/null/semaphore.c://===----------------------------------------------------------------------===//
../../drivers/null/semaphore.c:                                &semaphore->base);
../../drivers/null/semaphore.c:  semaphore->host_allocator = host_allocator;
../../drivers/null/semaphore.c:    *out_semaphore = &semaphore->base;
../../drivers/null/semaphore.c:    iree_hal_semaphore_release(&semaphore->base);
../../drivers/null/semaphore.c:  iree_allocator_t host_allocator = semaphore->host_allocator;
../../drivers/null/semaphore.c:  iree_hal_semaphore_deinitialize(&semaphore->base);
../../drivers/null/semaphore.c:  // iree_status_clone(semaphore->failure_status)`).
../../drivers/null/semaphore.c:  // (not less-than-or-equal).
../../drivers/null/semaphore.c:  // Data-loss usually indicates an abort()-worthy situation where graceful
../../drivers/null/semaphore.c:  // TODO(null): prefer having a fast-path for if the semaphore is
../../drivers/null/semaphore.c:  // known-signaled in user-mode. This can usually avoid syscalls/ioctls and
../../drivers/local_task/task_queue.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/local_task/task_queue.h:  // The intra-queue synchronization (barriers/events) carries across command
../../drivers/local_sync/sync_semaphore.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/local_sync/sync_semaphore.h://===----------------------------------------------------------------------===//
../../drivers/local_sync/sync_semaphore.h://===----------------------------------------------------------------------===//
../../drivers/local_sync/sync_semaphore.h:  // In-process notification signaled when any semaphore value changes.
../../drivers/local_sync/sync_semaphore.h://===----------------------------------------------------------------------===//
../../drivers/local_sync/sync_semaphore.h://===----------------------------------------------------------------------===//
../../drivers/local_sync/sync_semaphore.h:// synchronous backend is intended for - if you want something efficient in the
../../drivers/local_sync/sync_semaphore.h:// Performs a multi-wait on one or more semaphores.
../../drivers/local_sync/sync_event.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/local_sync/sync_driver.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/local_sync/sync_device.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/local_sync/sync_event.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/local_sync/sync_event.c:    iree_hal_resource_initialize(&iree_hal_sync_event_vtable, &event->resource);
../../drivers/local_sync/sync_event.c:    event->host_allocator = host_allocator;
../../drivers/local_sync/sync_event.c:  iree_allocator_t host_allocator = event->host_allocator;
../../drivers/local_sync/sync_driver.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/local_sync/sync_driver.c:                                loader_count * sizeof(*driver->loaders) +
../../drivers/local_sync/sync_driver.c:                                 &driver->resource);
../../drivers/local_sync/sync_driver.c:    driver->host_allocator = host_allocator;
../../drivers/local_sync/sync_driver.c:    driver->device_allocator = device_allocator;
../../drivers/local_sync/sync_driver.c:        identifier, &driver->identifier,
../../drivers/local_sync/sync_driver.c:        (char*)driver + total_size - identifier.size);
../../drivers/local_sync/sync_driver.c:    memcpy(&driver->default_params, default_params,
../../drivers/local_sync/sync_driver.c:           sizeof(driver->default_params));
../../drivers/local_sync/sync_driver.c:    driver->loader_count = loader_count;
../../drivers/local_sync/sync_driver.c:    for (iree_host_size_t i = 0; i < driver->loader_count; ++i) {
../../drivers/local_sync/sync_driver.c:      driver->loaders[i] = loaders[i];
../../drivers/local_sync/sync_driver.c:      iree_hal_executable_loader_retain(driver->loaders[i]);
../../drivers/local_sync/sync_driver.c:  iree_allocator_t host_allocator = driver->host_allocator;
../../drivers/local_sync/sync_driver.c:  iree_hal_allocator_release(driver->device_allocator);
../../drivers/local_sync/sync_driver.c:  for (iree_host_size_t i = 0; i < driver->loader_count; ++i) {
../../drivers/local_sync/sync_driver.c:    iree_hal_executable_loader_release(driver->loaders[i]);
../../drivers/local_sync/sync_driver.c:      driver->identifier, &driver->default_params, driver->loader_count,
../../drivers/local_sync/sync_driver.c:      driver->loaders, driver->device_allocator, host_allocator, out_device);
../../drivers/local_sync/CMakeLists.txt:# CMake-only content.                                                          #
../../drivers/local_sync/sync_device.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/local_sync/sync_device.c:  // Shared semaphore state used to emulate OS-level primitives. This backend
../../drivers/local_sync/sync_device.c:  // is intended to run on bare-metal systems where we need to perform all
../../drivers/local_sync/sync_device.c:  out_params->arena_block_size = 32 * 1024;
../../drivers/local_sync/sync_device.c:  if (params->arena_block_size < 4096) {
../../drivers/local_sync/sync_device.c:      sizeof(*device) + loader_count * sizeof(*device->loaders);
../../drivers/local_sync/sync_device.c:                                 &device->resource);
../../drivers/local_sync/sync_device.c:    iree_string_view_append_to_buffer(identifier, &device->identifier,
../../drivers/local_sync/sync_device.c:    device->host_allocator = host_allocator;
../../drivers/local_sync/sync_device.c:    device->device_allocator = device_allocator;
../../drivers/local_sync/sync_device.c:    iree_arena_block_pool_initialize(params->arena_block_size, host_allocator,
../../drivers/local_sync/sync_device.c:                                     &device->large_block_pool);
../../drivers/local_sync/sync_device.c:    device->loader_count = loader_count;
../../drivers/local_sync/sync_device.c:    for (iree_host_size_t i = 0; i < device->loader_count; ++i) {
../../drivers/local_sync/sync_device.c:      device->loaders[i] = loaders[i];
../../drivers/local_sync/sync_device.c:      iree_hal_executable_loader_retain(device->loaders[i]);
../../drivers/local_sync/sync_device.c:    iree_hal_sync_semaphore_state_initialize(&device->semaphore_state);
../../drivers/local_sync/sync_device.c:  iree_hal_sync_semaphore_state_deinitialize(&device->semaphore_state);
../../drivers/local_sync/sync_device.c:  for (iree_host_size_t i = 0; i < device->loader_count; ++i) {
../../drivers/local_sync/sync_device.c:    iree_hal_executable_loader_release(device->loaders[i]);
../../drivers/local_sync/sync_device.c:  iree_hal_allocator_release(device->device_allocator);
../../drivers/local_sync/sync_device.c:  iree_hal_channel_provider_release(device->channel_provider);
../../drivers/local_sync/sync_device.c:  iree_arena_block_pool_deinitialize(&device->large_block_pool);
../../drivers/local_sync/sync_device.c:  return device->identifier;
../../drivers/local_sync/sync_device.c:  return device->host_allocator;
../../drivers/local_sync/sync_device.c:  return device->device_allocator;
../../drivers/local_sync/sync_device.c:  iree_hal_allocator_release(device->device_allocator);
../../drivers/local_sync/sync_device.c:  device->device_allocator = new_allocator;
../../drivers/local_sync/sync_device.c:  iree_hal_channel_provider_release(device->channel_provider);
../../drivers/local_sync/sync_device.c:  device->channel_provider = new_provider;
../../drivers/local_sync/sync_device.c:  return iree_hal_allocator_trim(device->device_allocator);
../../drivers/local_sync/sync_device.c:        iree_string_view_match_pattern(device->identifier, key) ? 1 : 0;
../../drivers/local_sync/sync_device.c:            device->loader_count, device->loaders, /*caching_mode=*/0, key)
../../drivers/local_sync/sync_device.c:        queue_affinity, binding_capacity, &device->large_block_pool,
../../drivers/local_sync/sync_device.c:        device->host_allocator, out_command_buffer);
../../drivers/local_sync/sync_device.c:      identifier, /*worker_capacity=*/1, device->loader_count, device->loaders,
../../drivers/local_sync/sync_device.c:  return iree_hal_sync_semaphore_create(&device->semaphore_state, initial_value,
../../drivers/local_sync/sync_device.c:                                        device->host_allocator, out_semaphore);
../../drivers/local_sync/sync_device.c:  // The synchronous submission queue handles all semaphores as if host-side.
../../drivers/local_sync/sync_device.c:  // TODO(benvanik): queue-ordered allocations.
../../drivers/local_sync/sync_device.c:  // TODO(benvanik): queue-ordered allocations.
../../drivers/local_sync/sync_device.c:  // If there were no deferred command buffers no-op this call - they've already
../../drivers/local_sync/sync_device.c:      device->device_allocator,
../../drivers/local_sync/sync_device.c:      /*binding_capacity=*/0, device->host_allocator, storage,
../../drivers/local_sync/sync_device.c:  // do - chances are we already executed everything inline!
../../drivers/local_sync/sync_device.c:      &device->semaphore_state, IREE_HAL_WAIT_MODE_ALL, wait_semaphore_list,
../../drivers/local_sync/sync_device.c:  // Run all deferred command buffers - any we could have run inline we already
../../drivers/local_sync/sync_device.c:      &device->semaphore_state, signal_semaphore_list));
../../drivers/local_sync/sync_device.c:  return iree_hal_sync_semaphore_multi_wait(&device->semaphore_state, wait_mode,
../../drivers/local_sync/sync_device.c:  // https://man7.org/linux/man-pages/man2/perf_event_open.2.html
../../drivers/local_sync/sync_semaphore.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/local_sync/sync_semaphore.c://===----------------------------------------------------------------------===//
../../drivers/local_sync/sync_semaphore.c://===----------------------------------------------------------------------===//
../../drivers/local_sync/sync_semaphore.c:  iree_notification_initialize(&out_shared_state->notification);
../../drivers/local_sync/sync_semaphore.c:  iree_notification_deinitialize(&shared_state->notification);
../../drivers/local_sync/sync_semaphore.c://===----------------------------------------------------------------------===//
../../drivers/local_sync/sync_semaphore.c://===----------------------------------------------------------------------===//
../../drivers/local_sync/sync_semaphore.c:  // than trying to make the entire structure lock-free.
../../drivers/local_sync/sync_semaphore.c:                                  &semaphore->base);
../../drivers/local_sync/sync_semaphore.c:    semaphore->host_allocator = host_allocator;
../../drivers/local_sync/sync_semaphore.c:    semaphore->shared_state = shared_state;
../../drivers/local_sync/sync_semaphore.c:    iree_slim_mutex_initialize(&semaphore->mutex);
../../drivers/local_sync/sync_semaphore.c:    semaphore->current_value = initial_value;
../../drivers/local_sync/sync_semaphore.c:    semaphore->failure_status = iree_ok_status();
../../drivers/local_sync/sync_semaphore.c:    *out_semaphore = &semaphore->base;
../../drivers/local_sync/sync_semaphore.c:  iree_allocator_t host_allocator = semaphore->host_allocator;
../../drivers/local_sync/sync_semaphore.c:  iree_slim_mutex_deinitialize(&semaphore->mutex);
../../drivers/local_sync/sync_semaphore.c:  iree_status_ignore(semaphore->failure_status);
../../drivers/local_sync/sync_semaphore.c:  iree_hal_semaphore_deinitialize(&semaphore->base);
../../drivers/local_sync/sync_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/local_sync/sync_semaphore.c:  *out_value = semaphore->current_value;
../../drivers/local_sync/sync_semaphore.c:    status = iree_status_clone(semaphore->failure_status);
../../drivers/local_sync/sync_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/local_sync/sync_semaphore.c:  if (new_value <= semaphore->current_value) {
../../drivers/local_sync/sync_semaphore.c:    uint64_t current_value IREE_ATTRIBUTE_UNUSED = semaphore->current_value;
../../drivers/local_sync/sync_semaphore.c:  semaphore->current_value = new_value;
../../drivers/local_sync/sync_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/local_sync/sync_semaphore.c:    iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/local_sync/sync_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/local_sync/sync_semaphore.c:  iree_hal_semaphore_notify(&semaphore->base, new_value, IREE_STATUS_OK);
../../drivers/local_sync/sync_semaphore.c:  // TODO(#4680): make notifications per-semaphore; would make multi-wait
../../drivers/local_sync/sync_semaphore.c:  iree_notification_post(&semaphore->shared_state->notification,
../../drivers/local_sync/sync_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/local_sync/sync_semaphore.c:  // Try to set our local status - we only preserve the first failure so only
../../drivers/local_sync/sync_semaphore.c:  if (!iree_status_is_ok(semaphore->failure_status)) {
../../drivers/local_sync/sync_semaphore.c:    iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/local_sync/sync_semaphore.c:  semaphore->current_value = IREE_HAL_SEMAPHORE_FAILURE_VALUE;
../../drivers/local_sync/sync_semaphore.c:  semaphore->failure_status = status;
../../drivers/local_sync/sync_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/local_sync/sync_semaphore.c:  iree_hal_semaphore_notify(&semaphore->base, IREE_HAL_SEMAPHORE_FAILURE_VALUE,
../../drivers/local_sync/sync_semaphore.c:  iree_notification_post(&semaphore->shared_state->notification,
../../drivers/local_sync/sync_semaphore.c:    // Fast-path for a single semaphore.
../../drivers/local_sync/sync_semaphore.c:    iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/local_sync/sync_semaphore.c:      iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/local_sync/sync_semaphore.c:    iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/local_sync/sync_semaphore.c:  iree_notification_post(&shared_state->notification, IREE_ALL_WAITERS);
../../drivers/local_sync/sync_semaphore.c:  iree_hal_sync_semaphore_t* semaphore = state->semaphore;
../../drivers/local_sync/sync_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/local_sync/sync_semaphore.c:  bool is_signaled = semaphore->current_value >= state->value ||
../../drivers/local_sync/sync_semaphore.c:                     !iree_status_is_ok(semaphore->failure_status);
../../drivers/local_sync/sync_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/local_sync/sync_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/local_sync/sync_semaphore.c:  if (!iree_status_is_ok(semaphore->failure_status)) {
../../drivers/local_sync/sync_semaphore.c:    iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/local_sync/sync_semaphore.c:  } else if (semaphore->current_value >= value) {
../../drivers/local_sync/sync_semaphore.c:    iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/local_sync/sync_semaphore.c:    iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/local_sync/sync_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/local_sync/sync_semaphore.c:  iree_hal_sync_semaphore_state_t* shared_state = semaphore->shared_state;
../../drivers/local_sync/sync_semaphore.c:      &shared_state->notification,
../../drivers/local_sync/sync_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/local_sync/sync_semaphore.c:  if (!iree_status_is_ok(semaphore->failure_status)) {
../../drivers/local_sync/sync_semaphore.c:  } else if (semaphore->current_value < value) {
../../drivers/local_sync/sync_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/local_sync/sync_semaphore.c:  for (iree_host_size_t i = 0; i < semaphore_list->count; ++i) {
../../drivers/local_sync/sync_semaphore.c:        iree_hal_sync_semaphore_cast(semaphore_list->semaphores[i]);
../../drivers/local_sync/sync_semaphore.c:    iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/local_sync/sync_semaphore.c:        semaphore->current_value >= semaphore_list->payload_values[i] ||
../../drivers/local_sync/sync_semaphore.c:        !iree_status_is_ok(semaphore->failure_status);
../../drivers/local_sync/sync_semaphore.c:    iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/local_sync/sync_semaphore.c:  for (iree_host_size_t i = 0; i < semaphore_list->count; ++i) {
../../drivers/local_sync/sync_semaphore.c:        iree_hal_sync_semaphore_cast(semaphore_list->semaphores[i]);
../../drivers/local_sync/sync_semaphore.c:    iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/local_sync/sync_semaphore.c:        semaphore->current_value >= semaphore_list->payload_values[i] ||
../../drivers/local_sync/sync_semaphore.c:        !iree_status_is_ok(semaphore->failure_status);
../../drivers/local_sync/sync_semaphore.c:    iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/local_sync/sync_semaphore.c:// - IREE_STATUS_OK: any or all semaphores signaled (based on |wait_mode|).
../../drivers/local_sync/sync_semaphore.c:// - IREE_STATUS_ABORTED: one or more semaphores failed.
../../drivers/local_sync/sync_semaphore.c:// - IREE_STATUS_DEADLINE_EXCEEDED: any or all semaphores unsignaled.
../../drivers/local_sync/sync_semaphore.c:    iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/local_sync/sync_semaphore.c:    const uint64_t current_value = semaphore->current_value;
../../drivers/local_sync/sync_semaphore.c:        iree_status_code(semaphore->failure_status);
../../drivers/local_sync/sync_semaphore.c:    iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/local_sync/sync_semaphore.c:    // Fast-path for a single semaphore.
../../drivers/local_sync/sync_semaphore.c:  // Fast-path for polling; we'll never wait and can just do a quick query.
../../drivers/local_sync/sync_semaphore.c:      &shared_state->notification,
../../drivers/local_sync/sync_semaphore.c:  // We may have been successful - or may have a partial failure.
../../drivers/local_sync/cts/CMakeLists.txt:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/local_sync/cts/CMakeLists.txt:set(NATIVE_EXECUTABLE_FORMAT "\"${EXECUTABLE_FORMAT_PREFIX}-elf-\" IREE_ARCH")
../../drivers/local_sync/cts/CMakeLists.txt:  "--gtest_filter=-${FILTER_TESTS}"
../../drivers/local_sync/cts/CMakeLists.txt:      local-sync
../../drivers/local_sync/cts/CMakeLists.txt:      embedded-elf
../../drivers/local_sync/cts/CMakeLists.txt:      "llvm-cpu"
../../drivers/local_sync/cts/CMakeLists.txt:      driver=local-sync
../../drivers/local_sync/cts/CMakeLists.txt:      "--iree-llvmcpu-target-cpu=generic"
../../drivers/local_sync/cts/CMakeLists.txt:      local-sync
../../drivers/local_sync/cts/CMakeLists.txt:      "\"vmvx-bytecode-fb\""
../../drivers/local_sync/cts/CMakeLists.txt:      driver=local-sync
../../drivers/local_task/task_queue_state.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/local_task/CMakeLists.txt:# CMake-only content.                                                          #
../../drivers/local_sync/registration/driver_module.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/local_sync/registration/driver_module.c:      .driver_name = IREE_SVL("local-sync"),
../../drivers/local_sync/registration/driver_module.c:  if (!iree_string_view_equal(driver_name, IREE_SV("local-sync"))) {
../../drivers/local_sync/registration/BUILD.bazel:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/null/allocator.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/null/allocator.c://===----------------------------------------------------------------------===//
../../drivers/null/allocator.c://===----------------------------------------------------------------------===//
../../drivers/null/allocator.c:// TODO(null): use one ID per address space or pool - each shows as a different
../../drivers/null/allocator.c:                               &allocator->resource);
../../drivers/null/allocator.c:  allocator->host_allocator = host_allocator;
../../drivers/null/allocator.c:  // request-specific so preparing here will help keep the errors more
../../drivers/null/allocator.c:  iree_allocator_free(allocator->host_allocator, allocator);
../../drivers/null/allocator.c:  return allocator->host_allocator;
../../drivers/null/allocator.c:  // should be notified that a trim is requested. This is called in low-memory
../../drivers/null/allocator.c:    memcpy(out_statistics, &allocator->statistics, sizeof(*out_statistics));
../../drivers/null/allocator.c:  params->type &= ~IREE_HAL_MEMORY_TYPE_OPTIMAL;
../../drivers/null/allocator.c:  // application is unlikely to do anything when requesting a 0-byte buffer; but
../../drivers/null/allocator.c:        iree_hal_memory_type_format(params->type, &temp0);
../../drivers/null/allocator.c:        iree_hal_buffer_usage_format(params->usage, &temp1);
../../drivers/null/allocator.c:        &allocator->statistics, compat_params.type, allocation_size));
../../drivers/null/allocator.c:        &allocator->statistics, iree_hal_buffer_memory_type(base_buffer),
../../drivers/null/allocator.c:  iree_device_size_t allocation_size = external_buffer->size;
../../drivers/null/allocator.c:        iree_hal_memory_type_format(params->type, &temp0);
../../drivers/null/allocator.c:        iree_hal_buffer_usage_format(params->usage, &temp1);
../../drivers/null/allocator.c:  // TODO(null): switch on external_buffer->type and import the buffer. See the
../../drivers/local_task/task_driver.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/local_task/task_driver.c:  // - iree_hal_task_driver_t
../../drivers/local_task/task_driver.c:  // - queue_executors[]
../../drivers/local_task/task_driver.c:  // - identifier string
../../drivers/local_task/task_driver.c:      sizeof(*driver) + loader_count * sizeof(*driver->loaders);
../../drivers/local_task/task_driver.c:  struct_size += queue_count * sizeof(driver->queue_executors[0]);
../../drivers/local_task/task_driver.c:                                 &driver->resource);
../../drivers/local_task/task_driver.c:    driver->host_allocator = host_allocator;
../../drivers/local_task/task_driver.c:    driver->device_allocator = device_allocator;
../../drivers/local_task/task_driver.c:    iree_string_view_append_to_buffer(identifier, &driver->identifier,
../../drivers/local_task/task_driver.c:    memcpy(&driver->default_params, default_params,
../../drivers/local_task/task_driver.c:           sizeof(driver->default_params));
../../drivers/local_task/task_driver.c:    driver->queue_count = queue_count;
../../drivers/local_task/task_driver.c:    driver->queue_executors =
../../drivers/local_task/task_driver.c:    for (iree_host_size_t i = 0; i < driver->queue_count; ++i) {
../../drivers/local_task/task_driver.c:      driver->queue_executors[i] = queue_executors[i];
../../drivers/local_task/task_driver.c:      iree_task_executor_retain(driver->queue_executors[i]);
../../drivers/local_task/task_driver.c:    driver->loader_count = loader_count;
../../drivers/local_task/task_driver.c:    for (iree_host_size_t i = 0; i < driver->loader_count; ++i) {
../../drivers/local_task/task_driver.c:      driver->loaders[i] = loaders[i];
../../drivers/local_task/task_driver.c:      iree_hal_executable_loader_retain(driver->loaders[i]);
../../drivers/local_task/task_driver.c:  iree_allocator_t host_allocator = driver->host_allocator;
../../drivers/local_task/task_driver.c:  iree_hal_allocator_release(driver->device_allocator);
../../drivers/local_task/task_driver.c:  for (iree_host_size_t i = 0; i < driver->loader_count; ++i) {
../../drivers/local_task/task_driver.c:    iree_hal_executable_loader_release(driver->loaders[i]);
../../drivers/local_task/task_driver.c:  for (iree_host_size_t i = 0; i < driver->queue_count; ++i) {
../../drivers/local_task/task_driver.c:    iree_task_executor_release(driver->queue_executors[i]);
../../drivers/local_task/task_driver.c:      driver->identifier, &driver->default_params, driver->queue_count,
../../drivers/local_task/task_driver.c:      driver->queue_executors, driver->loader_count, driver->loaders,
../../drivers/local_task/task_driver.c:      driver->device_allocator, host_allocator, out_device);
../../drivers/local_task/task_device.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/local_task/task_device.c:  out_params->arena_block_size = 32 * 1024;
../../drivers/local_task/task_device.c:  out_params->queue_scope_flags = IREE_TASK_SCOPE_FLAG_NONE;
../../drivers/local_task/task_device.c:  if (params->arena_block_size < 4096) {
../../drivers/local_task/task_device.c:// Returns an event pool used for device-wide system event handles.
../../drivers/local_task/task_device.c:  return iree_task_executor_event_pool(device->queues[0].executor);
../../drivers/local_task/task_device.c:                                 queue_count * sizeof(*device->queues) +
../../drivers/local_task/task_device.c:                                 loader_count * sizeof(*device->loaders);
../../drivers/local_task/task_device.c:                                 &device->resource);
../../drivers/local_task/task_device.c:    iree_string_view_append_to_buffer(identifier, &device->identifier,
../../drivers/local_task/task_device.c:    device->host_allocator = host_allocator;
../../drivers/local_task/task_device.c:    device->device_allocator = device_allocator;
../../drivers/local_task/task_device.c:                                     &device->small_block_pool);
../../drivers/local_task/task_device.c:    iree_arena_block_pool_initialize(params->arena_block_size, host_allocator,
../../drivers/local_task/task_device.c:                                     &device->large_block_pool);
../../drivers/local_task/task_device.c:    device->loader_count = loader_count;
../../drivers/local_task/task_device.c:    device->loaders =
../../drivers/local_task/task_device.c:                                         queue_count * sizeof(*device->queues));
../../drivers/local_task/task_device.c:    for (iree_host_size_t i = 0; i < device->loader_count; ++i) {
../../drivers/local_task/task_device.c:      device->loaders[i] = loaders[i];
../../drivers/local_task/task_device.c:      iree_hal_executable_loader_retain(device->loaders[i]);
../../drivers/local_task/task_device.c:    device->queue_count = queue_count;
../../drivers/local_task/task_device.c:    for (iree_host_size_t i = 0; i < device->queue_count; ++i) {
../../drivers/local_task/task_device.c:          device->identifier, queue_affinity, params->queue_scope_flags,
../../drivers/local_task/task_device.c:          queue_executors[i], &device->small_block_pool,
../../drivers/local_task/task_device.c:          &device->large_block_pool, device->device_allocator,
../../drivers/local_task/task_device.c:          &device->queues[i]);
../../drivers/local_task/task_device.c:  for (iree_host_size_t i = 0; i < device->queue_count; ++i) {
../../drivers/local_task/task_device.c:    iree_hal_task_queue_deinitialize(&device->queues[i]);
../../drivers/local_task/task_device.c:  for (iree_host_size_t i = 0; i < device->loader_count; ++i) {
../../drivers/local_task/task_device.c:    iree_hal_executable_loader_release(device->loaders[i]);
../../drivers/local_task/task_device.c:  iree_hal_allocator_release(device->device_allocator);
../../drivers/local_task/task_device.c:  iree_hal_channel_provider_release(device->channel_provider);
../../drivers/local_task/task_device.c:  iree_arena_block_pool_deinitialize(&device->large_block_pool);
../../drivers/local_task/task_device.c:  iree_arena_block_pool_deinitialize(&device->small_block_pool);
../../drivers/local_task/task_device.c:  return device->identifier;
../../drivers/local_task/task_device.c:  return device->host_allocator;
../../drivers/local_task/task_device.c:  return device->device_allocator;
../../drivers/local_task/task_device.c:  iree_hal_allocator_release(device->device_allocator);
../../drivers/local_task/task_device.c:  device->device_allocator = new_allocator;
../../drivers/local_task/task_device.c:  iree_hal_channel_provider_release(device->channel_provider);
../../drivers/local_task/task_device.c:  device->channel_provider = new_provider;
../../drivers/local_task/task_device.c:  for (iree_host_size_t i = 0; i < device->queue_count; ++i) {
../../drivers/local_task/task_device.c:    iree_hal_task_queue_trim(&device->queues[i]);
../../drivers/local_task/task_device.c:  IREE_RETURN_IF_ERROR(iree_hal_allocator_trim(device->device_allocator));
../../drivers/local_task/task_device.c:  iree_arena_block_pool_trim(&device->small_block_pool);
../../drivers/local_task/task_device.c:  iree_arena_block_pool_trim(&device->large_block_pool);
../../drivers/local_task/task_device.c:        iree_string_view_match_pattern(device->identifier, key) ? 1 : 0;
../../drivers/local_task/task_device.c:            device->loader_count, device->loaders, /*caching_mode=*/0, key)
../../drivers/local_task/task_device.c:      *out_value = (int64_t)device->queue_count;
../../drivers/local_task/task_device.c:          (int64_t)iree_task_executor_worker_count(device->queues[0].executor);
../../drivers/local_task/task_device.c:  return queue_affinity % device->queue_count;
../../drivers/local_task/task_device.c:    // TODO(indirect-cmd): natively support reusable task command buffers. For
../../drivers/local_task/task_device.c:        queue_affinity, binding_capacity, &device->large_block_pool,
../../drivers/local_task/task_device.c:        device->host_allocator, out_command_buffer);
../../drivers/local_task/task_device.c:        &device->queues[queue_index].scope, mode, command_categories,
../../drivers/local_task/task_device.c:        queue_affinity, binding_capacity, &device->large_block_pool,
../../drivers/local_task/task_device.c:        device->host_allocator, out_command_buffer);
../../drivers/local_task/task_device.c:  // preallocate worker-specific storage.
../../drivers/local_task/task_device.c:  for (iree_host_size_t i = 0; i < device->queue_count; ++i) {
../../drivers/local_task/task_device.c:        iree_task_executor_worker_count(device->queues[i].executor);
../../drivers/local_task/task_device.c:      identifier, total_worker_count, device->loader_count, device->loaders,
../../drivers/local_task/task_device.c:      device->host_allocator, out_semaphore);
../../drivers/local_task/task_device.c:    // Fast-path for semaphores related to this device.
../../drivers/local_task/task_device.c:  // TODO(benvanik): queue-ordered allocations.
../../drivers/local_task/task_device.c:  // TODO(benvanik): queue-ordered allocations.
../../drivers/local_task/task_device.c:    // Fast-path for barriers (fork/join/sequence).
../../drivers/local_task/task_device.c:    return iree_hal_task_queue_submit_barrier(&device->queues[queue_index],
../../drivers/local_task/task_device.c:  return iree_hal_task_queue_submit_commands(&device->queues[queue_index], 1,
../../drivers/local_task/task_device.c:      &device->large_block_pool);
../../drivers/local_task/task_device.c:  // https://man7.org/linux/man-pages/man2/perf_event_open.2.html
../../drivers/local_task/task_command_buffer.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/local_task/task_semaphore.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/local_task/task_semaphore.h:// Performs a multi-wait on one or more semaphores.
../../drivers/local_task/task_driver.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/local_task/task_driver.h:// Creates a new iree/task/-based local CPU driver that creates devices sharing
../../drivers/local_task/task_device.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/local_task/task_device.h:// Creates a new iree/task/-based local CPU device that uses task executors for
../../drivers/local_sync/registration/CMakeLists.txt:# CMake-only content.                                                          #
../../drivers/local_sync/registration/driver_module.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/local_task/cts/CMakeLists.txt:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/local_task/cts/CMakeLists.txt:set(NATIVE_EXECUTABLE_FORMAT "\"${EXECUTABLE_FORMAT_PREFIX}-elf-\" IREE_ARCH")
../../drivers/local_task/cts/CMakeLists.txt:  "--gtest_filter=-${FILTER_TESTS}"
../../drivers/local_task/cts/CMakeLists.txt:      local-task
../../drivers/local_task/cts/CMakeLists.txt:      embedded-elf
../../drivers/local_task/cts/CMakeLists.txt:      "llvm-cpu"
../../drivers/local_task/cts/CMakeLists.txt:      driver=local-task
../../drivers/local_task/cts/CMakeLists.txt:      "--iree-llvmcpu-target-cpu=generic"
../../drivers/local_task/cts/CMakeLists.txt:      local-task
../../drivers/local_task/cts/CMakeLists.txt:      "\"vmvx-bytecode-fb\""
../../drivers/local_task/cts/CMakeLists.txt:      driver=local-task
../../drivers/local_task/BUILD.bazel:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/local_task/registration/CMakeLists.txt:# CMake-only content.                                                          #
../../drivers/local_task/registration/driver_module.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/local_task/registration/BUILD.bazel:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../buffer_transfer.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../buffer_transfer.h://===----------------------------------------------------------------------===//
../../buffer_transfer.h:// Human-friendly/performance-hostile transfer APIs
../../buffer_transfer.h://===----------------------------------------------------------------------===//
../../buffer_transfer.h:  // A host-allocated void* buffer.
../../buffer_transfer.h:  // A device-allocated buffer (may be of any memory type).
../../buffer_transfer.h:// Supports host->device, device->host, and device->device transfer,
../../buffer_transfer.h://===----------------------------------------------------------------------===//
../../buffer_transfer.h://===----------------------------------------------------------------------===//
../../buffer_transfer.h:// allocate additional host-local buffers and submit copy commands.
../../api.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/local_task/task_semaphore.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/local_task/task_semaphore.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_semaphore.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_semaphore.c:// Instances are owned and retained by the caller that requested them - usually
../../drivers/local_task/task_semaphore.c:  iree_event_set(&timepoint->event);
../../drivers/local_task/task_semaphore.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_semaphore.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_semaphore.c:  // than trying to make the entire structure lock-free.
../../drivers/local_task/task_semaphore.c:                                  &semaphore->base);
../../drivers/local_task/task_semaphore.c:    semaphore->host_allocator = host_allocator;
../../drivers/local_task/task_semaphore.c:    semaphore->event_pool = event_pool;
../../drivers/local_task/task_semaphore.c:    iree_slim_mutex_initialize(&semaphore->mutex);
../../drivers/local_task/task_semaphore.c:    semaphore->current_value = initial_value;
../../drivers/local_task/task_semaphore.c:    semaphore->failure_status = iree_ok_status();
../../drivers/local_task/task_semaphore.c:    *out_semaphore = &semaphore->base;
../../drivers/local_task/task_semaphore.c:  iree_allocator_t host_allocator = semaphore->host_allocator;
../../drivers/local_task/task_semaphore.c:  iree_slim_mutex_deinitialize(&semaphore->mutex);
../../drivers/local_task/task_semaphore.c:  iree_status_ignore(semaphore->failure_status);
../../drivers/local_task/task_semaphore.c:  iree_hal_semaphore_deinitialize(&semaphore->base);
../../drivers/local_task/task_semaphore.c:  return iree_hal_resource_is(&semaphore->resource,
../../drivers/local_task/task_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/local_task/task_semaphore.c:  *out_value = semaphore->current_value;
../../drivers/local_task/task_semaphore.c:    status = iree_status_clone(semaphore->failure_status);
../../drivers/local_task/task_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/local_task/task_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/local_task/task_semaphore.c:  if (new_value <= semaphore->current_value) {
../../drivers/local_task/task_semaphore.c:    uint64_t current_value IREE_ATTRIBUTE_UNUSED = semaphore->current_value;
../../drivers/local_task/task_semaphore.c:    iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/local_task/task_semaphore.c:  semaphore->current_value = new_value;
../../drivers/local_task/task_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/local_task/task_semaphore.c:  // Notify timepoints - note that this must happen outside the lock.
../../drivers/local_task/task_semaphore.c:  iree_hal_semaphore_notify(&semaphore->base, new_value, IREE_STATUS_OK);
../../drivers/local_task/task_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/local_task/task_semaphore.c:  // Try to set our local status - we only preserve the first failure so only
../../drivers/local_task/task_semaphore.c:  if (!iree_status_is_ok(semaphore->failure_status)) {
../../drivers/local_task/task_semaphore.c:    iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/local_task/task_semaphore.c:  semaphore->current_value = IREE_HAL_SEMAPHORE_FAILURE_VALUE;
../../drivers/local_task/task_semaphore.c:  semaphore->failure_status = status;
../../drivers/local_task/task_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/local_task/task_semaphore.c:  // Notify timepoints - note that this must happen outside the lock.
../../drivers/local_task/task_semaphore.c:  iree_hal_semaphore_notify(&semaphore->base, IREE_HAL_SEMAPHORE_FAILURE_VALUE,
../../drivers/local_task/task_semaphore.c:      iree_event_pool_acquire(semaphore->event_pool, 1, &out_timepoint->event));
../../drivers/local_task/task_semaphore.c:  out_timepoint->semaphore = &semaphore->base;
../../drivers/local_task/task_semaphore.c:      &semaphore->base, minimum_value, timeout,
../../drivers/local_task/task_semaphore.c:      &out_timepoint->base);
../../drivers/local_task/task_semaphore.c:// Cleans up a wait task by returning the event used to the pool and - if the
../../drivers/local_task/task_semaphore.c:// task failed - ensuring we scrub it from the timepoint list.
../../drivers/local_task/task_semaphore.c:    iree_hal_semaphore_cancel_timepoint(&cmd->semaphore->base,
../../drivers/local_task/task_semaphore.c:                                        &cmd->timepoint.base);
../../drivers/local_task/task_semaphore.c:  iree_event_pool_release(cmd->semaphore->event_pool, 1, &cmd->timepoint.event);
../../drivers/local_task/task_semaphore.c:  iree_hal_semaphore_release((iree_hal_semaphore_t*)cmd->semaphore);
../../drivers/local_task/task_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/local_task/task_semaphore.c:  if (semaphore->current_value >= minimum_value) {
../../drivers/local_task/task_semaphore.c:  } else if (!iree_status_is_ok(semaphore->failure_status)) {
../../drivers/local_task/task_semaphore.c:    status = iree_status_clone(semaphore->failure_status);
../../drivers/local_task/task_semaphore.c:          semaphore, minimum_value, iree_infinite_timeout(), &cmd->timepoint);
../../drivers/local_task/task_semaphore.c:      iree_task_wait_initialize(issue_task->scope,
../../drivers/local_task/task_semaphore.c:                                iree_event_await(&cmd->timepoint.event),
../../drivers/local_task/task_semaphore.c:                                IREE_TIME_INFINITE_FUTURE, &cmd->task);
../../drivers/local_task/task_semaphore.c:      iree_task_set_cleanup_fn(&cmd->task.header,
../../drivers/local_task/task_semaphore.c:      iree_task_set_completion_task(&cmd->task.header, issue_task);
../../drivers/local_task/task_semaphore.c:      cmd->semaphore = semaphore;
../../drivers/local_task/task_semaphore.c:      iree_task_submission_enqueue(submission, &cmd->task.header);
../../drivers/local_task/task_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/local_task/task_semaphore.c:  iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/local_task/task_semaphore.c:  if (!iree_status_is_ok(semaphore->failure_status)) {
../../drivers/local_task/task_semaphore.c:    iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/local_task/task_semaphore.c:  } else if (semaphore->current_value >= value) {
../../drivers/local_task/task_semaphore.c:    iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/local_task/task_semaphore.c:    iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/local_task/task_semaphore.c:  iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/local_task/task_semaphore.c:    iree_hal_semaphore_cancel_timepoint(&semaphore->base, &timepoint.base);
../../drivers/local_task/task_semaphore.c:  iree_event_pool_release(semaphore->event_pool, 1, &timepoint.event);
../../drivers/local_task/task_semaphore.c:    // Fast-path for a single semaphore.
../../drivers/local_task/task_semaphore.c:      iree_slim_mutex_lock(&semaphore->mutex);
../../drivers/local_task/task_semaphore.c:      if (semaphore->current_value >= semaphore_list.payload_values[i]) {
../../drivers/local_task/task_semaphore.c:          status = iree_wait_set_insert(wait_set, timepoint->event);
../../drivers/local_task/task_semaphore.c:      iree_slim_mutex_unlock(&semaphore->mutex);
../../drivers/local_task/task_semaphore.c:  // TODO(benvanik): if we flip the API to multi-acquire events from the pool
../../drivers/local_task/task_semaphore.c:  // above then we can multi-release here too.
../../drivers/local_task/task_command_buffer.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/local_task/task_command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_command_buffer.c:// iree/task/-based command buffer.
../../drivers/local_task/task_command_buffer.c:// all allocations are served from a shared per-device block pool with no
../../drivers/local_task/task_command_buffer.c:  // TODO(benvanik): move this out of the struct and allocate from the arena -
../../drivers/local_task/task_command_buffer.c:    // recording or have some kind of copy-on-submit behavior that does so if
../../drivers/local_task/task_command_buffer.c:    // `cmdbuf -> semaphore -> cmdbuf`) though we'd still need to be careful
../../drivers/local_task/task_command_buffer.c:                            "only one-shot command buffer usage is supported");
../../drivers/local_task/task_command_buffer.c:        &iree_hal_task_command_buffer_vtable, &command_buffer->base);
../../drivers/local_task/task_command_buffer.c:    command_buffer->host_allocator = host_allocator;
../../drivers/local_task/task_command_buffer.c:    command_buffer->scope = scope;
../../drivers/local_task/task_command_buffer.c:    iree_arena_initialize(block_pool, &command_buffer->arena);
../../drivers/local_task/task_command_buffer.c:    iree_task_list_initialize(&command_buffer->root_tasks);
../../drivers/local_task/task_command_buffer.c:    iree_task_list_initialize(&command_buffer->leaf_tasks);
../../drivers/local_task/task_command_buffer.c:    memset(&command_buffer->state, 0, sizeof(command_buffer->state));
../../drivers/local_task/task_command_buffer.c:                                            &command_buffer->resource_set);
../../drivers/local_task/task_command_buffer.c:    *out_command_buffer = &command_buffer->base;
../../drivers/local_task/task_command_buffer.c:    iree_hal_command_buffer_release(&command_buffer->base);
../../drivers/local_task/task_command_buffer.c:  iree_allocator_t host_allocator = command_buffer->host_allocator;
../../drivers/local_task/task_command_buffer.c:  memset(&command_buffer->state, 0, sizeof(command_buffer->state));
../../drivers/local_task/task_command_buffer.c:  iree_task_list_discard(&command_buffer->root_tasks);
../../drivers/local_task/task_command_buffer.c:  iree_task_list_discard(&command_buffer->leaf_tasks);
../../drivers/local_task/task_command_buffer.c:  iree_arena_deinitialize(&command_buffer->arena);
../../drivers/local_task/task_command_buffer.c:  iree_hal_resource_set_free(command_buffer->resource_set);
../../drivers/local_task/task_command_buffer.c:  return iree_hal_resource_is(&command_buffer->resource,
../../drivers/local_task/task_command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_command_buffer.c:  if (!iree_task_list_is_empty(&command_buffer->root_tasks)) {
../../drivers/local_task/task_command_buffer.c:                            "command buffer cannot be re-recorded");
../../drivers/local_task/task_command_buffer.c:  if (iree_task_list_is_empty(&command_buffer->root_tasks) &&
../../drivers/local_task/task_command_buffer.c:      !iree_task_list_is_empty(&command_buffer->leaf_tasks)) {
../../drivers/local_task/task_command_buffer.c:    iree_task_list_move(&command_buffer->leaf_tasks,
../../drivers/local_task/task_command_buffer.c:                        &command_buffer->root_tasks);
../../drivers/local_task/task_command_buffer.c:  iree_hal_resource_set_freeze(command_buffer->resource_set);
../../drivers/local_task/task_command_buffer.c:  iree_task_barrier_t* open_barrier = command_buffer->state.open_barrier;
../../drivers/local_task/task_command_buffer.c:        iree_task_list_front(&command_buffer->state.open_tasks);
../../drivers/local_task/task_command_buffer.c:        command_buffer->state.open_task_count;
../../drivers/local_task/task_command_buffer.c:      // Special-case: only one open task so we can avoid the additional barrier
../../drivers/local_task/task_command_buffer.c:      iree_task_set_completion_task(&open_barrier->header, task_head);
../../drivers/local_task/task_command_buffer.c:          &command_buffer->arena, dependent_task_count * sizeof(iree_task_t*),
../../drivers/local_task/task_command_buffer.c:        task = task->next_task;
../../drivers/local_task/task_command_buffer.c:  command_buffer->state.open_barrier = NULL;
../../drivers/local_task/task_command_buffer.c:  if (command_buffer->state.open_task_count > 0) {
../../drivers/local_task/task_command_buffer.c:    iree_task_list_move(&command_buffer->state.open_tasks,
../../drivers/local_task/task_command_buffer.c:                        &command_buffer->leaf_tasks);
../../drivers/local_task/task_command_buffer.c:    command_buffer->state.open_task_count = 0;
../../drivers/local_task/task_command_buffer.c:// limits our concurrency: changing to fine-grained barriers (via barrier
../../drivers/local_task/task_command_buffer.c:  IREE_RETURN_IF_ERROR(iree_arena_allocate(&command_buffer->arena,
../../drivers/local_task/task_command_buffer.c:  iree_task_barrier_initialize_empty(command_buffer->scope, barrier);
../../drivers/local_task/task_command_buffer.c:  for (iree_task_t* task = iree_task_list_front(&command_buffer->leaf_tasks);
../../drivers/local_task/task_command_buffer.c:       task != NULL; task = task->next_task) {
../../drivers/local_task/task_command_buffer.c:    iree_task_set_completion_task(task, &barrier->header);
../../drivers/local_task/task_command_buffer.c:  if (iree_task_list_is_empty(&command_buffer->root_tasks) &&
../../drivers/local_task/task_command_buffer.c:      !iree_task_list_is_empty(&command_buffer->leaf_tasks)) {
../../drivers/local_task/task_command_buffer.c:    iree_task_list_move(&command_buffer->leaf_tasks,
../../drivers/local_task/task_command_buffer.c:                        &command_buffer->root_tasks);
../../drivers/local_task/task_command_buffer.c:      iree_task_list_is_empty(&command_buffer->root_tasks)
../../drivers/local_task/task_command_buffer.c:          ? &command_buffer->root_tasks
../../drivers/local_task/task_command_buffer.c:          : &command_buffer->leaf_tasks;
../../drivers/local_task/task_command_buffer.c:  iree_task_list_push_back(target_task_list, &barrier->header);
../../drivers/local_task/task_command_buffer.c:  command_buffer->state.open_barrier = barrier;
../../drivers/local_task/task_command_buffer.c:  command_buffer->state.open_task_count = 0;
../../drivers/local_task/task_command_buffer.c:  if (command_buffer->state.open_barrier == NULL) {
../../drivers/local_task/task_command_buffer.c:    iree_task_list_push_back(&command_buffer->leaf_tasks, task);
../../drivers/local_task/task_command_buffer.c:    iree_task_list_push_back(&command_buffer->state.open_tasks, task);
../../drivers/local_task/task_command_buffer.c:    ++command_buffer->state.open_task_count;
../../drivers/local_task/task_command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_command_buffer.c:  // If the command buffer is empty (valid!) then we are a no-op.
../../drivers/local_task/task_command_buffer.c:  bool has_root_tasks = !iree_task_list_is_empty(&command_buffer->root_tasks);
../../drivers/local_task/task_command_buffer.c:  bool has_leaf_tasks = !iree_task_list_is_empty(&command_buffer->leaf_tasks);
../../drivers/local_task/task_command_buffer.c:    for (iree_task_t* task = command_buffer->leaf_tasks.head; task != NULL;
../../drivers/local_task/task_command_buffer.c:         task = task->next_task) {
../../drivers/local_task/task_command_buffer.c:    for (iree_task_t* task = command_buffer->root_tasks.head; task != NULL;
../../drivers/local_task/task_command_buffer.c:         task = task->next_task) {
../../drivers/local_task/task_command_buffer.c:                                    &command_buffer->root_tasks);
../../drivers/local_task/task_command_buffer.c:  iree_task_list_initialize(&command_buffer->leaf_tasks);
../../drivers/local_task/task_command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_command_buffer.c:  // global barriers each time and forcing a join-fork point.
../../drivers/local_task/task_command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_command_buffer.c:  iree_device_size_t length_per_slice = tile_context->workgroup_size[0];
../../drivers/local_task/task_command_buffer.c:      (iree_device_size_t)tile_context->workgroup_xyz[0] * length_per_slice;
../../drivers/local_task/task_command_buffer.c:  iree_device_size_t remaining_length = cmd->target_ref.length - slice_offset;
../../drivers/local_task/task_command_buffer.c:      cmd->target_ref.buffer, cmd->target_ref.offset + slice_offset,
../../drivers/local_task/task_command_buffer.c:      slice_length, cmd->pattern, cmd->pattern_length);
../../drivers/local_task/task_command_buffer.c:      command_buffer->resource_set, 1, &target_ref.buffer));
../../drivers/local_task/task_command_buffer.c:      iree_arena_allocate(&command_buffer->arena, sizeof(*cmd), (void**)&cmd));
../../drivers/local_task/task_command_buffer.c:      command_buffer->scope,
../../drivers/local_task/task_command_buffer.c:      workgroup_size, workgroup_count, &cmd->task);
../../drivers/local_task/task_command_buffer.c:  cmd->target_ref = target_ref;
../../drivers/local_task/task_command_buffer.c:  memcpy(cmd->pattern, pattern, pattern_length);
../../drivers/local_task/task_command_buffer.c:  cmd->pattern_length = pattern_length;
../../drivers/local_task/task_command_buffer.c:                                                          &cmd->task.header);
../../drivers/local_task/task_command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_command_buffer.c:      iree_hal_buffer_map_write(cmd->target_ref.buffer, cmd->target_ref.offset,
../../drivers/local_task/task_command_buffer.c:                                cmd->source_buffer, cmd->target_ref.length);
../../drivers/local_task/task_command_buffer.c:      command_buffer->resource_set, 1, &target_ref.buffer));
../../drivers/local_task/task_command_buffer.c:  IREE_RETURN_IF_ERROR(iree_arena_allocate(&command_buffer->arena,
../../drivers/local_task/task_command_buffer.c:      command_buffer->scope,
../../drivers/local_task/task_command_buffer.c:      &cmd->task);
../../drivers/local_task/task_command_buffer.c:  cmd->target_ref = target_ref;
../../drivers/local_task/task_command_buffer.c:  memcpy(cmd->source_buffer, (const uint8_t*)source_buffer + source_offset,
../../drivers/local_task/task_command_buffer.c:         cmd->target_ref.length);
../../drivers/local_task/task_command_buffer.c:                                                          &cmd->task.header);
../../drivers/local_task/task_command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_command_buffer.c:  iree_device_size_t length_per_slice = tile_context->workgroup_size[0];
../../drivers/local_task/task_command_buffer.c:      (iree_device_size_t)tile_context->workgroup_xyz[0] * length_per_slice;
../../drivers/local_task/task_command_buffer.c:  iree_device_size_t remaining_length = cmd->target_ref.length - slice_offset;
../../drivers/local_task/task_command_buffer.c:      cmd->source_ref.buffer, cmd->source_ref.offset + slice_offset,
../../drivers/local_task/task_command_buffer.c:      cmd->target_ref.buffer, cmd->target_ref.offset + slice_offset,
../../drivers/local_task/task_command_buffer.c:      command_buffer->resource_set, IREE_ARRAYSIZE(buffers), buffers));
../../drivers/local_task/task_command_buffer.c:      iree_arena_allocate(&command_buffer->arena, sizeof(*cmd), (void**)&cmd));
../../drivers/local_task/task_command_buffer.c:      command_buffer->scope,
../../drivers/local_task/task_command_buffer.c:      workgroup_size, workgroup_count, &cmd->task);
../../drivers/local_task/task_command_buffer.c:  cmd->source_ref = source_ref;
../../drivers/local_task/task_command_buffer.c:  cmd->target_ref = target_ref;
../../drivers/local_task/task_command_buffer.c:                                                          &cmd->task.header);
../../drivers/local_task/task_command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_command_buffer.c:  // The channel can be used as a vtable if we want to inject collective APIs -
../../drivers/local_task/task_command_buffer.c:  // event. At the next execution barrier (or non-collective command) we'd
../../drivers/local_task/task_command_buffer.c:  // flush to a multi-wait on all of the pending events.
../../drivers/local_task/task_command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_command_buffer.c:  // used (known at compile-time).
../../drivers/local_task/task_command_buffer.c:  // - const uint32_t constants[constant_count];
../../drivers/local_task/task_command_buffer.c:  // - void* binding_ptrs[binding_count];
../../drivers/local_task/task_command_buffer.c:  // - const size_t binding_lengths[binding_count];
../../drivers/local_task/task_command_buffer.c:  // pressure as all cores would be hitting the same hot read-only cache line.
../../drivers/local_task/task_command_buffer.c:      .workgroup_size_x = tile_context->workgroup_size[0],
../../drivers/local_task/task_command_buffer.c:      .workgroup_size_y = tile_context->workgroup_size[1],
../../drivers/local_task/task_command_buffer.c:      .workgroup_size_z = tile_context->workgroup_size[2],
../../drivers/local_task/task_command_buffer.c:      .constant_count = cmd->constant_count,
../../drivers/local_task/task_command_buffer.c:      .workgroup_count_x = tile_context->workgroup_count[0],
../../drivers/local_task/task_command_buffer.c:      .workgroup_count_y = tile_context->workgroup_count[1],
../../drivers/local_task/task_command_buffer.c:      .workgroup_count_z = tile_context->workgroup_count[2],
../../drivers/local_task/task_command_buffer.c:          iree_task_affinity_set_count_ones(cmd->task.header.affinity_set),
../../drivers/local_task/task_command_buffer.c:      .binding_count = cmd->binding_count,
../../drivers/local_task/task_command_buffer.c:  cmd_ptr += cmd->constant_count * sizeof(*dispatch_state.constants);
../../drivers/local_task/task_command_buffer.c:  cmd_ptr += cmd->binding_count * sizeof(*dispatch_state.binding_ptrs);
../../drivers/local_task/task_command_buffer.c:  cmd_ptr += cmd->binding_count * sizeof(*dispatch_state.binding_lengths);
../../drivers/local_task/task_command_buffer.c:          .workgroup_id_x = tile_context->workgroup_xyz[0],
../../drivers/local_task/task_command_buffer.c:          .workgroup_id_y = tile_context->workgroup_xyz[1],
../../drivers/local_task/task_command_buffer.c:          .workgroup_id_z = tile_context->workgroup_xyz[2],
../../drivers/local_task/task_command_buffer.c:          .processor_id = tile_context->processor_id,
../../drivers/local_task/task_command_buffer.c:          .local_memory = tile_context->local_memory.data,
../../drivers/local_task/task_command_buffer.c:          .local_memory_size = (size_t)tile_context->local_memory.data_length,
../../drivers/local_task/task_command_buffer.c:      cmd->executable, cmd->ordinal, &dispatch_state, &workgroup_state,
../../drivers/local_task/task_command_buffer.c:      tile_context->worker_id);
../../drivers/local_task/task_command_buffer.c:  if (local_executable->dispatch_attrs) {
../../drivers/local_task/task_command_buffer.c:    dispatch_attrs = local_executable->dispatch_attrs[entry_point];
../../drivers/local_task/task_command_buffer.c:  IREE_RETURN_IF_ERROR(iree_arena_allocate(&command_buffer->arena,
../../drivers/local_task/task_command_buffer.c:  cmd->executable = local_executable;
../../drivers/local_task/task_command_buffer.c:  cmd->ordinal = entry_point;
../../drivers/local_task/task_command_buffer.c:  cmd->constant_count = dispatch_attrs.constant_count;
../../drivers/local_task/task_command_buffer.c:  cmd->binding_count = dispatch_attrs.binding_count;
../../drivers/local_task/task_command_buffer.c:      command_buffer->scope,
../../drivers/local_task/task_command_buffer.c:      config.workgroup_size, config.workgroup_count, &cmd->task);
../../drivers/local_task/task_command_buffer.c:    cmd->task.header.flags |= IREE_TASK_FLAG_DISPATCH_INDIRECT;
../../drivers/local_task/task_command_buffer.c:    cmd->task.workgroup_count.ptr =
../../drivers/local_task/task_command_buffer.c:      command_buffer->resource_set, resource_count, resources));
../../drivers/local_task/task_command_buffer.c:  cmd->task.local_memory_size =
../../drivers/local_task/task_command_buffer.c:                            "constants must be 4-byte aligned");
../../drivers/local_task/task_command_buffer.c:  // no ownership/retaining/etc - it's part of the HAL contract that buffers are
../../drivers/local_task/task_command_buffer.c:      command_buffer->resource_set, bindings.count, bindings.values,
../../drivers/local_task/task_command_buffer.c:                                                          &cmd->task.header);
../../drivers/local_task/task_command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/local_task/registration/driver_module.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/local_task/registration/driver_module.c:          .driver_name = IREE_SVL("local-task"),
../../drivers/local_task/registration/driver_module.c:  if (!iree_string_view_equal(driver_name, IREE_SV("local-task"))) {
../../channel_provider.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../channel_provider.h://===----------------------------------------------------------------------===//
../../channel_provider.h://===----------------------------------------------------------------------===//
../../channel_provider.h://===----------------------------------------------------------------------===//
../../channel_provider.h://===----------------------------------------------------------------------===//
../../drivers/local_task/task_queue.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/local_task/task_queue.c://  +--------------------+    To preserve the sequential issue order an edge is
../../drivers/local_task/task_queue.c://  +--------------------+    it exists) such that all issues run in the order
../../drivers/local_task/task_queue.c://  +--------------------+    submissions may still overlap and are only
../../drivers/local_task/task_queue.c://  +--------------------+
../../drivers/local_task/task_queue.c://    |   +--------------+
../../drivers/local_task/task_queue.c://    +-> | +--------------+  Unsatisfied waits are scheduled as wait tasks and
../../drivers/local_task/task_queue.c://    .   +-|  sema waits  |  block the issuing of commands until all have
../../drivers/local_task/task_queue.c://    .     +--------------+  been satisfied. If the wait is immediately
../../drivers/local_task/task_queue.c://    +--------+-+-+-+-+      elided - only cross-queue or external waits
../../drivers/local_task/task_queue.c://  +--------------------+    Command buffers in the batch are issued in-order
../../drivers/local_task/task_queue.c://  +--------------------+    command buffer (excluding recording state like
../../drivers/local_task/task_queue.c://    |   +--------------+    are determined by the events and barriers recorded
../../drivers/local_task/task_queue.c://    +-> | +--------------+  in each command buffer.
../../drivers/local_task/task_queue.c://    .   +-|   commands   |
../../drivers/local_task/task_queue.c://    .     +--------------+
../../drivers/local_task/task_queue.c://    +--------+-+-+-+-+
../../drivers/local_task/task_queue.c://  +--------------------+    After all commands within the batch complete the
../../drivers/local_task/task_queue.c://  +--------------------+    signaled. Note that this may happen *before* other
../../drivers/local_task/task_queue.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_queue.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_queue.c:// to reference the newly-cloned data.
../../drivers/local_task/task_queue.c:      source_list->count * sizeof(out_target_list->semaphores[0]);
../../drivers/local_task/task_queue.c:      source_list->count * sizeof(out_target_list->payload_values[0]);
../../drivers/local_task/task_queue.c:  out_target_list->count = source_list->count;
../../drivers/local_task/task_queue.c:  out_target_list->semaphores = (iree_hal_semaphore_t**)buffer;
../../drivers/local_task/task_queue.c:  out_target_list->payload_values = (uint64_t*)(buffer + semaphores_size);
../../drivers/local_task/task_queue.c:  for (iree_host_size_t i = 0; i < source_list->count; ++i) {
../../drivers/local_task/task_queue.c:    iree_hal_semaphore_t* semaphore = source_list->semaphores[i];
../../drivers/local_task/task_queue.c:    out_target_list->semaphores[i] = semaphore;
../../drivers/local_task/task_queue.c:    out_target_list->payload_values[i] = source_list->payload_values[i];
../../drivers/local_task/task_queue.c:  for (iree_host_size_t i = 0; i < list->count; ++i) {
../../drivers/local_task/task_queue.c:    iree_hal_semaphore_release(list->semaphores[i]);
../../drivers/local_task/task_queue.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_queue.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_queue.c:// This optimizes for same-queue semaphore chaining by ensuring that semaphores
../../drivers/local_task/task_queue.c:// happened prior to the sequence command being executed. Cross-queue semaphores
../../drivers/local_task/task_queue.c:  // Arena used for the submission - additional tasks can be allocated from
../../drivers/local_task/task_queue.c:  for (iree_host_size_t i = 0; i < cmd->wait_semaphores.count; ++i) {
../../drivers/local_task/task_queue.c:        cmd->wait_semaphores.semaphores[i],
../../drivers/local_task/task_queue.c:        cmd->wait_semaphores.payload_values[i],
../../drivers/local_task/task_queue.c:        cmd->task.header.completion_task, cmd->arena, pending_submission);
../../drivers/local_task/task_queue.c:  iree_hal_semaphore_list_release(&cmd->wait_semaphores);
../../drivers/local_task/task_queue.c:      &cmd->task);
../../drivers/local_task/task_queue.c:  iree_task_set_cleanup_fn(&cmd->task.header,
../../drivers/local_task/task_queue.c:  cmd->arena = arena;
../../drivers/local_task/task_queue.c:  // Clone the wait semaphores from the batch - we retain them and their
../../drivers/local_task/task_queue.c:                                                     &cmd->wait_semaphores));
../../drivers/local_task/task_queue.c:  *out_issue_task = &cmd->task.header;
../../drivers/local_task/task_queue.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_queue.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_queue.c:  // Arena used for the submission - additional tasks can be allocated from
../../drivers/local_task/task_queue.c:          cmd->queue->device_allocator, &cmd->queue->scope,
../../drivers/local_task/task_queue.c:          cmd->queue->affinity, /*binding_capacity=*/0,
../../drivers/local_task/task_queue.c:          cmd->queue->large_block_pool,
../../drivers/local_task/task_queue.c:          iree_hal_allocator_host_allocator(cmd->queue->device_allocator),
../../drivers/local_task/task_queue.c:      iree_hal_resource_set_insert(cmd->resource_set, 1, &task_command_buffer);
../../drivers/local_task/task_queue.c:                                             &cmd->queue->state,
../../drivers/local_task/task_queue.c:                                             cmd->task.header.completion_task,
../../drivers/local_task/task_queue.c:                                             cmd->arena, pending_submission));
../../drivers/local_task/task_queue.c:  // NOTE: it's ok for there to be no command buffers - in that case the
../../drivers/local_task/task_queue.c:  if (cmd->command_buffer != NULL) {
../../drivers/local_task/task_queue.c:    if (iree_hal_task_command_buffer_isa(cmd->command_buffer)) {
../../drivers/local_task/task_queue.c:      if (cmd->binding_table.count > 0) {
../../drivers/local_task/task_queue.c:            cmd->command_buffer, &cmd->queue->state,
../../drivers/local_task/task_queue.c:            cmd->task.header.completion_task, cmd->arena, pending_submission);
../../drivers/local_task/task_queue.c:    } else if (iree_hal_deferred_command_buffer_isa(cmd->command_buffer)) {
../../drivers/local_task/task_queue.c:          cmd, cmd->command_buffer, cmd->binding_table, pending_submission);
../../drivers/local_task/task_queue.c:      batch->binding_table.count * sizeof(*batch->binding_table.bindings);
../../drivers/local_task/task_queue.c:      &cmd->task);
../../drivers/local_task/task_queue.c:  iree_task_set_completion_task(&cmd->task.header, retire_task);
../../drivers/local_task/task_queue.c:  cmd->arena = arena;
../../drivers/local_task/task_queue.c:  cmd->queue = queue;
../../drivers/local_task/task_queue.c:  cmd->resource_set = resource_set;
../../drivers/local_task/task_queue.c:  cmd->command_buffer = batch->command_buffer;
../../drivers/local_task/task_queue.c:  cmd->binding_table = iree_hal_buffer_binding_table_empty();
../../drivers/local_task/task_queue.c:  // any non-empty binding tables provided during submission.
../../drivers/local_task/task_queue.c:    const iree_host_size_t element_count = batch->binding_table.count;
../../drivers/local_task/task_queue.c:    cmd->binding_table.count = element_count;
../../drivers/local_task/task_queue.c:    cmd->binding_table.bindings = binding_element_ptr;
../../drivers/local_task/task_queue.c:    memcpy((void*)cmd->binding_table.bindings, batch->binding_table.bindings,
../../drivers/local_task/task_queue.c:        cmd->resource_set, element_count, cmd->binding_table.bindings,
../../drivers/local_task/task_queue.c:    *out_issue_task = &cmd->task.header;
../../drivers/local_task/task_queue.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_queue.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_queue.c:  // submission. All queue-related commands are allocated from this, **including
../../drivers/local_task/task_queue.c:  // resource-level completion.
../../drivers/local_task/task_queue.c:  iree_hal_resource_set_free(cmd->resource_set);
../../drivers/local_task/task_queue.c:  cmd->resource_set = NULL;
../../drivers/local_task/task_queue.c:  for (iree_host_size_t i = 0; i < cmd->signal_semaphores.count; ++i) {
../../drivers/local_task/task_queue.c:        iree_hal_semaphore_signal(cmd->signal_semaphores.semaphores[i],
../../drivers/local_task/task_queue.c:                                  cmd->signal_semaphores.payload_values[i]);
../../drivers/local_task/task_queue.c:  if (!cmd->resource_set) {
../../drivers/local_task/task_queue.c:    iree_hal_resource_set_free(cmd->resource_set);
../../drivers/local_task/task_queue.c:    cmd->resource_set = NULL;
../../drivers/local_task/task_queue.c:    for (iree_host_size_t i = 0; i < cmd->signal_semaphores.count; ++i) {
../../drivers/local_task/task_queue.c:      iree_hal_semaphore_fail(cmd->signal_semaphores.semaphores[i],
../../drivers/local_task/task_queue.c:  iree_hal_semaphore_list_release(&cmd->signal_semaphores);
../../drivers/local_task/task_queue.c:  iree_arena_allocator_t arena = cmd->arena;
../../drivers/local_task/task_queue.c:// The command will own an arena that can be used for other submission-related
../../drivers/local_task/task_queue.c:      &cmd->task);
../../drivers/local_task/task_queue.c:  iree_task_set_cleanup_fn(&cmd->task.header,
../../drivers/local_task/task_queue.c:  cmd->signal_semaphores = iree_hal_semaphore_list_empty();
../../drivers/local_task/task_queue.c:  cmd->resource_set = NULL;
../../drivers/local_task/task_queue.c:  // Clone the signal semaphores from the batch - we retain them and their
../../drivers/local_task/task_queue.c:                                           &cmd->signal_semaphores);
../../drivers/local_task/task_queue.c:    status = iree_hal_resource_set_allocate(block_pool, &cmd->resource_set);
../../drivers/local_task/task_queue.c:    memcpy(&cmd->arena, &arena, sizeof(cmd->arena));
../../drivers/local_task/task_queue.c:      iree_hal_resource_set_free(cmd->resource_set);
../../drivers/local_task/task_queue.c:      iree_hal_semaphore_list_release(&cmd->signal_semaphores);
../../drivers/local_task/task_queue.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_queue.c://===----------------------------------------------------------------------===//
../../drivers/local_task/task_queue.c:  out_queue->affinity = affinity;
../../drivers/local_task/task_queue.c:  out_queue->executor = executor;
../../drivers/local_task/task_queue.c:  iree_task_executor_retain(out_queue->executor);
../../drivers/local_task/task_queue.c:  out_queue->small_block_pool = small_block_pool;
../../drivers/local_task/task_queue.c:  out_queue->large_block_pool = large_block_pool;
../../drivers/local_task/task_queue.c:  out_queue->device_allocator = device_allocator;
../../drivers/local_task/task_queue.c:  iree_hal_allocator_retain(out_queue->device_allocator);
../../drivers/local_task/task_queue.c:  iree_task_scope_initialize(identifier, scope_flags, &out_queue->scope);
../../drivers/local_task/task_queue.c:  iree_hal_task_queue_state_initialize(&out_queue->state);
../../drivers/local_task/task_queue.c:      iree_task_scope_wait_idle(&queue->scope, IREE_TIME_INFINITE_FUTURE));
../../drivers/local_task/task_queue.c:  iree_hal_task_queue_state_deinitialize(&queue->state);
../../drivers/local_task/task_queue.c:  iree_task_scope_deinitialize(&queue->scope);
../../drivers/local_task/task_queue.c:  iree_hal_allocator_release(queue->device_allocator);
../../drivers/local_task/task_queue.c:  iree_task_executor_release(queue->executor);
../../drivers/local_task/task_queue.c:  iree_task_executor_trim(queue->executor);
../../drivers/local_task/task_queue.c:      &queue->scope, &signal_semaphores, queue->small_block_pool, &retire_cmd));
../../drivers/local_task/task_queue.c:    status = iree_hal_resource_set_insert(retire_cmd->resource_set,
../../drivers/local_task/task_queue.c:    status = iree_task_executor_acquire_fence(queue->executor, &queue->scope,
../../drivers/local_task/task_queue.c:    iree_task_set_completion_task(&retire_cmd->task.header, &fence->header);
../../drivers/local_task/task_queue.c:  // in-flight - if the queue is empty then we can directly schedule the waits.
../../drivers/local_task/task_queue.c:        &queue->scope, &wait_semaphores, &retire_cmd->arena, &wait_task);
../../drivers/local_task/task_queue.c:    status = issue(user_data, &queue->scope, queue, &retire_cmd->task.header,
../../drivers/local_task/task_queue.c:                   &retire_cmd->arena, retire_cmd->resource_set, &issue_cmd);
../../drivers/local_task/task_queue.c:  // Last chance for failure - from here on we are submitting.
../../drivers/local_task/task_queue.c:    iree_arena_deinitialize(&retire_cmd->arena);
../../drivers/local_task/task_queue.c:  iree_task_t* head_task = issue_cmd ? issue_cmd : &retire_cmd->task.header;
../../drivers/local_task/task_queue.c:  iree_task_executor_submit(queue->executor, &submission);
../../drivers/local_task/task_queue.c:    iree_task_executor_flush(queue->executor);
../../drivers/local_task/task_queue.c:        queue, batch->wait_semaphores, batch->signal_semaphores, 1,
../../drivers/local_task/task_queue.c:        (iree_hal_resource_t* const*)&batch->command_buffer,
../../drivers/local_task/task_queue.c:    iree_task_executor_flush(queue->executor);
../../drivers/local_task/task_queue.c:  iree_task_set_completion_task(&cmd->header, retire_task);
../../drivers/local_task/task_queue.c:  *out_issue_task = &cmd->header;
../../drivers/local_task/task_queue.c:  iree_status_t status = iree_task_scope_wait_idle(&queue->scope, deadline_ns);
../../drivers/amdgpu/executable_cache.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/executable_cache.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/executable_cache.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/executable_cache.h:// Creates a no-op executable cache that does not cache at all.
../../drivers/amdgpu/executable_cache.h:// perform any on-device JITing/optimization. If in the future there's something
../../drivers/amdgpu/executable_cache.h:// more PTX/HSAIL-like we'd want to manage that here.
../../drivers/amdgpu/executable_cache.h:// |libhsa| and |topology| are captured by-reference and must remain valid for
../../drivers/amdgpu/logical_device.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/logical_device.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/logical_device.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/logical_device.h:  // HSA system instantiated from the user-provided topology.
../../drivers/amdgpu/logical_device.h:  // Sticky logical device-global error flag.
../../drivers/amdgpu/physical_device.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/physical_device.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/physical_device.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/physical_device.c:  out_options->device_block_pools.small.block_size =
../../drivers/amdgpu/physical_device.c:  out_options->device_block_pools.large.min_blocks_per_allocation =
../../drivers/amdgpu/physical_device.c:  out_options->device_block_pools.small.initial_capacity =
../../drivers/amdgpu/physical_device.c:  out_options->device_block_pools.large.block_size =
../../drivers/amdgpu/physical_device.c:  out_options->device_block_pools.large.min_blocks_per_allocation =
../../drivers/amdgpu/physical_device.c:  out_options->device_block_pools.large.initial_capacity =
../../drivers/amdgpu/physical_device.c:  out_options->host_block_pool_size =
../../drivers/amdgpu/physical_device.c:  out_options->queue_count =
../../drivers/amdgpu/physical_device.c:  iree_hal_amdgpu_queue_options_initialize(&out_options->queue_options);
../../drivers/amdgpu/physical_device.c:  if (options->device_block_pools.small.block_size <
../../drivers/amdgpu/physical_device.c:          options->device_block_pools.small.block_size)) {
../../drivers/amdgpu/physical_device.c:        "power-of-two greater than %d and got %" PRIhsz,
../../drivers/amdgpu/physical_device.c:        options->device_block_pools.small.block_size);
../../drivers/amdgpu/physical_device.c:  if (options->device_block_pools.large.block_size <
../../drivers/amdgpu/physical_device.c:          options->device_block_pools.large.block_size)) {
../../drivers/amdgpu/physical_device.c:        "power-of-two greater than %d and got %" PRIhsz,
../../drivers/amdgpu/physical_device.c:        options->device_block_pools.large.block_size);
../../drivers/amdgpu/physical_device.c:  // Verify each queue - if used - is valid.
../../drivers/amdgpu/physical_device.c:  if (options->queue_count > 0 && options->queue_count <= 64) {
../../drivers/amdgpu/physical_device.c:                            "a physical device may only have 1-64 HAL queues");
../../drivers/amdgpu/physical_device.c:      iree_hal_amdgpu_queue_options_verify(&options->queue_options, libhsa,
../../drivers/amdgpu/physical_device.c:      options->queue_count * options->queue_options.execution_queue_count;
../../drivers/amdgpu/physical_device.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/physical_device.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/physical_device.c:  switch (options->placement) {
../../drivers/amdgpu/physical_device.c:// Initializes |out_queue| in-place based on |options|.
../../drivers/amdgpu/physical_device.c:          options->queue_count * sizeof(iree_hal_amdgpu_virtual_queue_t*),
../../drivers/amdgpu/physical_device.c:      iree_hal_amdgpu_queue_calculate_size(&options->queue_options);
../../drivers/amdgpu/physical_device.c:  return iree_host_align(base_size + options->queue_count * queue_size,
../../drivers/amdgpu/physical_device.c:  iree_hal_amdgpu_libhsa_t* libhsa = &system->libhsa;
../../drivers/amdgpu/physical_device.c:  hsa_agent_t host_agent = system->topology.cpu_agents[host_ordinal];
../../drivers/amdgpu/physical_device.c:  hsa_agent_t device_agent = system->topology.gpu_agents[device_ordinal];
../../drivers/amdgpu/physical_device.c:  out_physical_device->device_agent = device_agent;
../../drivers/amdgpu/physical_device.c:  out_physical_device->device_ordinal = device_ordinal;
../../drivers/amdgpu/physical_device.c:  out_physical_device->queue_count = options->queue_count;
../../drivers/amdgpu/physical_device.c:      iree_hal_amdgpu_queue_calculate_size(&options->queue_options);
../../drivers/amdgpu/physical_device.c:          options->queue_count * sizeof(out_physical_device->queues[0]),
../../drivers/amdgpu/physical_device.c:  for (iree_host_size_t i = 0; i < options->queue_count; ++i) {
../../drivers/amdgpu/physical_device.c:    out_physical_device->queues[i] =
../../drivers/amdgpu/physical_device.c:  // Initialize the per-device block pool.
../../drivers/amdgpu/physical_device.c:  iree_arena_block_pool_initialize(options->host_block_pool_size,
../../drivers/amdgpu/physical_device.c:                                   &out_physical_device->fine_host_block_pool);
../../drivers/amdgpu/physical_device.c:  if (options->host_block_pool_initial_capacity) {
../../drivers/amdgpu/physical_device.c:                &out_physical_device->fine_host_block_pool,
../../drivers/amdgpu/physical_device.c:                options->host_block_pool_initial_capacity));
../../drivers/amdgpu/physical_device.c:  // Create block pools and allocators used to back device-side resources.
../../drivers/amdgpu/physical_device.c:        libhsa, options->device_block_pools.small, device_agent,
../../drivers/amdgpu/physical_device.c:        &out_physical_device->coarse_block_pools.small);
../../drivers/amdgpu/physical_device.c:        libhsa, options->device_block_pools.large, device_agent,
../../drivers/amdgpu/physical_device.c:        &out_physical_device->coarse_block_pools.large);
../../drivers/amdgpu/physical_device.c:        libhsa, options->device_block_pools.small, device_agent,
../../drivers/amdgpu/physical_device.c:        &out_physical_device->fine_block_pools.small);
../../drivers/amdgpu/physical_device.c:        libhsa, options->device_block_pools.large, device_agent,
../../drivers/amdgpu/physical_device.c:        &out_physical_device->fine_block_pools.large);
../../drivers/amdgpu/physical_device.c:        &out_physical_device->coarse_block_pools.small,
../../drivers/amdgpu/physical_device.c:        &out_physical_device->coarse_block_allocators.small);
../../drivers/amdgpu/physical_device.c:        &out_physical_device->coarse_block_pools.large,
../../drivers/amdgpu/physical_device.c:        &out_physical_device->coarse_block_allocators.large);
../../drivers/amdgpu/physical_device.c:        &out_physical_device->fine_block_pools.small,
../../drivers/amdgpu/physical_device.c:        &out_physical_device->fine_block_allocators.small);
../../drivers/amdgpu/physical_device.c:        &out_physical_device->fine_block_pools.large,
../../drivers/amdgpu/physical_device.c:        &out_physical_device->fine_block_allocators.large);
../../drivers/amdgpu/physical_device.c:  // could change that if we become host-bound. In general we should not be
../../drivers/amdgpu/physical_device.c:  // using the host during our latency-critical operations but it's possible if
../../drivers/amdgpu/physical_device.c:        libhsa, host_ordinal, host_agent, host_memory_pools->fine_region,
../../drivers/amdgpu/physical_device.c:        &out_physical_device->host_service);
../../drivers/amdgpu/physical_device.c:  // Initialize each queue and its device-side scheduler.
../../drivers/amdgpu/physical_device.c:       iree_status_is_ok(status) && i < options->queue_count; ++i) {
../../drivers/amdgpu/physical_device.c:        system, options->queue_options, device_agent, device_ordinal,
../../drivers/amdgpu/physical_device.c:        &out_physical_device->host_service,
../../drivers/amdgpu/physical_device.c:        &out_physical_device->fine_host_block_pool,
../../drivers/amdgpu/physical_device.c:        &out_physical_device->fine_block_allocators, buffer_pool,
../../drivers/amdgpu/physical_device.c:        out_physical_device->queues[i]);
../../drivers/amdgpu/physical_device.c:  // Deinitialize all queues and their device-side schedulers before releasing
../../drivers/amdgpu/physical_device.c:  for (iree_host_size_t i = 0; i < physical_device->queue_count; ++i) {
../../drivers/amdgpu/physical_device.c:    iree_hal_amdgpu_virtual_queue_t* queue = physical_device->queues[i];
../../drivers/amdgpu/physical_device.c:      queue->vtable->deinitialize(queue);
../../drivers/amdgpu/physical_device.c:  iree_hal_amdgpu_host_service_deinitialize(&physical_device->host_service);
../../drivers/amdgpu/physical_device.c:  iree_arena_block_pool_deinitialize(&physical_device->fine_host_block_pool);
../../drivers/amdgpu/physical_device.c:  // Note that other per-device data structures may be using blocks until they
../../drivers/amdgpu/physical_device.c:      &physical_device->coarse_block_allocators.small);
../../drivers/amdgpu/physical_device.c:      &physical_device->coarse_block_allocators.large);
../../drivers/amdgpu/physical_device.c:      &physical_device->fine_block_allocators.small);
../../drivers/amdgpu/physical_device.c:      &physical_device->fine_block_allocators.large);
../../drivers/amdgpu/physical_device.c:      &physical_device->coarse_block_pools.small);
../../drivers/amdgpu/physical_device.c:      &physical_device->coarse_block_pools.large);
../../drivers/amdgpu/physical_device.c:      &physical_device->fine_block_pools.small);
../../drivers/amdgpu/physical_device.c:      &physical_device->fine_block_pools.large);
../../drivers/amdgpu/physical_device.c:  for (iree_host_size_t i = 0; i < physical_device->queue_count; ++i) {
../../drivers/amdgpu/physical_device.c:    iree_hal_amdgpu_virtual_queue_t* queue = physical_device->queues[i];
../../drivers/amdgpu/physical_device.c:    queue->vtable->trim(queue);
../../drivers/amdgpu/physical_device.c:  iree_hal_amdgpu_block_pool_trim(&physical_device->coarse_block_pools.small);
../../drivers/amdgpu/physical_device.c:  iree_hal_amdgpu_block_pool_trim(&physical_device->coarse_block_pools.large);
../../drivers/amdgpu/physical_device.c:  iree_hal_amdgpu_block_pool_trim(&physical_device->fine_block_pools.small);
../../drivers/amdgpu/physical_device.c:  iree_hal_amdgpu_block_pool_trim(&physical_device->fine_block_pools.large);
../../drivers/amdgpu/physical_device.c:  iree_arena_block_pool_trim(&physical_device->fine_host_block_pool);
../../drivers/amdgpu/host_service_test.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/host_service_test.cc:// Returns the first fine-grained global region of the |host_agent|.
../../drivers/amdgpu/host_service_test.cc:      +[](hsa_region_t region, void* user_data) -> hsa_status_t {
../../drivers/amdgpu/host_service_test.cc:        if (pool_list->count + 1 >= IREE_ARRAYSIZE(pool_list->values)) {
../../drivers/amdgpu/host_service_test.cc:        pool_list->values[pool_list->count++] = region;
../../drivers/amdgpu/host_service_test.cc:      IREE_LIBHSA(service->libhsa), service->queue, 1u);
../../drivers/amdgpu/host_service_test.cc:  while (packet_id - iree_hsa_queue_load_read_index_scacquire(
../../drivers/amdgpu/host_service_test.cc:                         IREE_LIBHSA(service->libhsa), service->queue) >=
../../drivers/amdgpu/host_service_test.cc:         service->queue->size) {
../../drivers/amdgpu/host_service_test.cc:  const uint64_t queue_mask = service->queue->size - 1;  // power of two
../../drivers/amdgpu/host_service_test.cc:      (hsa_barrier_or_packet_t*)((uint8_t*)service->queue->base_address +
../../drivers/amdgpu/host_service_test.cc:  packet->reserved1 = 0;
../../drivers/amdgpu/host_service_test.cc:  memcpy(&packet->dep_signal[0], &dep_signals[0], sizeof(packet->dep_signal));
../../drivers/amdgpu/host_service_test.cc:  packet->reserved2 = 0;
../../drivers/amdgpu/host_service_test.cc:  packet->completion_signal = completion_signal;
../../drivers/amdgpu/host_service_test.cc:  iree_hsa_signal_store_relaxed(IREE_LIBHSA(service->libhsa), service->doorbell,
../../drivers/amdgpu/host_service_test.cc:      IREE_LIBHSA(service->libhsa), service->queue, 1u);
../../drivers/amdgpu/host_service_test.cc:  while (packet_id - iree_hsa_queue_load_read_index_scacquire(
../../drivers/amdgpu/host_service_test.cc:                         IREE_LIBHSA(service->libhsa), service->queue) >=
../../drivers/amdgpu/host_service_test.cc:         service->queue->size) {
../../drivers/amdgpu/host_service_test.cc:  const uint64_t queue_mask = service->queue->size - 1;  // power of two
../../drivers/amdgpu/host_service_test.cc:      (hsa_amd_barrier_value_packet_t*)((uint8_t*)service->queue->base_address +
../../drivers/amdgpu/host_service_test.cc:  packet->reserved0 = 0;
../../drivers/amdgpu/host_service_test.cc:  packet->signal = dep_signal;
../../drivers/amdgpu/host_service_test.cc:  packet->value = condition_value;
../../drivers/amdgpu/host_service_test.cc:  packet->mask = condition_mask;
../../drivers/amdgpu/host_service_test.cc:  packet->cond = condition;
../../drivers/amdgpu/host_service_test.cc:  packet->reserved1 = 0;
../../drivers/amdgpu/host_service_test.cc:  packet->reserved2 = 0;
../../drivers/amdgpu/host_service_test.cc:  packet->reserved3 = 0;
../../drivers/amdgpu/host_service_test.cc:  packet->completion_signal = completion_signal;
../../drivers/amdgpu/host_service_test.cc:  iree_hsa_signal_store_relaxed(IREE_LIBHSA(service->libhsa), service->doorbell,
../../drivers/amdgpu/host_service_test.cc:      IREE_LIBHSA(service->libhsa), service->queue, 1u);
../../drivers/amdgpu/host_service_test.cc:  while (packet_id - iree_hsa_queue_load_read_index_scacquire(
../../drivers/amdgpu/host_service_test.cc:                         IREE_LIBHSA(service->libhsa), service->queue) >=
../../drivers/amdgpu/host_service_test.cc:         service->queue->size) {
../../drivers/amdgpu/host_service_test.cc:  const uint64_t queue_mask = service->queue->size - 1;  // power of two
../../drivers/amdgpu/host_service_test.cc:      (hsa_agent_dispatch_packet_t*)((uint8_t*)service->queue->base_address +
../../drivers/amdgpu/host_service_test.cc:  agent_packet->reserved0 = 0;
../../drivers/amdgpu/host_service_test.cc:  agent_packet->return_address = (void*)return_address;
../../drivers/amdgpu/host_service_test.cc:  agent_packet->arg[0] = arg0;
../../drivers/amdgpu/host_service_test.cc:  agent_packet->arg[1] = arg1;
../../drivers/amdgpu/host_service_test.cc:  agent_packet->arg[2] = arg2;
../../drivers/amdgpu/host_service_test.cc:  agent_packet->arg[3] = arg3;
../../drivers/amdgpu/host_service_test.cc:  agent_packet->reserved2 = 0;
../../drivers/amdgpu/host_service_test.cc:  agent_packet->completion_signal = completion_signal;
../../drivers/amdgpu/host_service_test.cc:  iree_hsa_signal_store_relaxed(IREE_LIBHSA(service->libhsa), service->doorbell,
../../drivers/amdgpu/host_service_test.cc:  // NOTE: it's not required that the service ever signal completion - it is
../../drivers/amdgpu/host_service_test.cc:      iree_allocator_t host_allocator = test_resource->host_allocator;
../../drivers/amdgpu/host_service_test.cc:      iree_atomic_fetch_sub(test_resource->live_count, 1u,
../../drivers/amdgpu/host_service_test.cc:                               &test_resource->resource);
../../drivers/amdgpu/host_service_test.cc:  test_resource->host_allocator = host_allocator;
../../drivers/amdgpu/host_service_test.cc:  test_resource->live_count = live_count;
../../drivers/amdgpu/host_service_test.cc:  iree_atomic_fetch_add(test_resource->live_count, 1u,
../../drivers/amdgpu/host_service_test.cc:// there is a command using it. Today all are unidirectional post-only.
../../drivers/amdgpu/device/semaphore.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/device/semaphore.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/semaphore.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/semaphore.h:// host - and most may be. A outer wrapper iree_hal_semaphore_t owns the memory
../../drivers/amdgpu/device/semaphore.h:// and manages its lifetime and can pool this device-side block for reuse.
../../drivers/amdgpu/device/semaphore.h:// Thread-safe. May be accessed from both host and device concurrently.
../../drivers/amdgpu/device/semaphore.h:// TODO(benvanik): make doubly-linked? insertion scan from the tail may be best
../../drivers/amdgpu/device/semaphore.h:// as usually we enqueue operations in order (1->2->3).
../../drivers/amdgpu/device/semaphore.h:  // HSA signal in device-visible memory.
../../drivers/amdgpu/device/semaphore.h:  // This may be a ROCR DefaultSignal (busy-wait) or InterruptSignal (event)
../../drivers/amdgpu/device/semaphore.h:  // TODO(benvanik): implement device-side semaphore data for both host and
../../drivers/amdgpu/device/semaphore.h:  return sizeof(*list) + count * sizeof(list->entries[0]);
../../drivers/vulkan/api.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/api.cc://===----------------------------------------------------------------------===//
../../drivers/vulkan/api.cc://===----------------------------------------------------------------------===//
../../drivers/vulkan/api.cc:        // Only resolve vkGetInstanceProcAddr, rely on syms->LoadFromInstance()
../../drivers/vulkan/api.cc:        // and/or syms->LoadFromDevice() for further loading.
../../drivers/vulkan/api.cc:    handle->AddReference();
../../drivers/vulkan/api.cc:    handle->ReleaseReference();
../../drivers/vulkan/nop_executable_cache.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/nop_executable_cache.h:// Creates a no-op executable cache that does not cache at all.
../../drivers/vulkan/api.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/api.h://===----------------------------------------------------------------------===//
../../drivers/vulkan/api.h://===----------------------------------------------------------------------===//
../../drivers/vulkan/api.h:// helpers in the top-level compiler configuration.
../../drivers/vulkan/api.h:#endif  // 64-bit pointer check
../../drivers/vulkan/api.h://===----------------------------------------------------------------------===//
../../drivers/vulkan/api.h://===----------------------------------------------------------------------===//
../../drivers/vulkan/api.h:  // hardware-specific performance counters.
../../drivers/vulkan/api.h:  // NOTE: tracing has a non-trivial overhead and will skew the timing of
../../drivers/vulkan/api.h:  // identify slow dispatches and refine from there; be wary of whole-program
../../drivers/vulkan/api.h:  // checks to GPU memory accesses to make all accesses be in-bounds. This is
../../drivers/vulkan/api.h:  // to allow for queue-ordered virtual memory management.
../../drivers/vulkan/api.h:  // appropriately compiled SPIR-V executables require them.
../../drivers/vulkan/api.h://===----------------------------------------------------------------------===//
../../drivers/vulkan/api.h://===----------------------------------------------------------------------===//
../../drivers/vulkan/api.h://===----------------------------------------------------------------------===//
../../drivers/vulkan/api.h://===----------------------------------------------------------------------===//
../../drivers/vulkan/api.h:  // See: https://gpuopen.com/learn/concurrent-execution-asynchronous-queues/
../../drivers/vulkan/api.h:// |instance_syms| must have at least the instance-specific functions resolved
../../drivers/vulkan/api.h:// for latency-sensitive processing.
../../drivers/vulkan/api.h://===----------------------------------------------------------------------===//
../../drivers/vulkan/api.h://===----------------------------------------------------------------------===//
../../drivers/vulkan/api.h:  // TODO(benvanik): remove this single setting - it would be nice instead to
../../drivers/vulkan/api.h:  // to have auto-discovered options based on capabilities. Right now this
../../drivers/vulkan/api.h:  // forces all devices - even if from different vendors - to have the same
../../drivers/vulkan/api.h:// the instance-specific |iree_hal_vulkan_query_extensibility_set| queries.
../../drivers/vulkan/api.h://===----------------------------------------------------------------------===//
../../drivers/vulkan/api.h://===----------------------------------------------------------------------===//
../../drivers/vulkan/api.h:// TODO(benvanik): make this safer (dyn_cast-like, lookup allocated buffer).
../../drivers/vulkan/api.h://===----------------------------------------------------------------------===//
../../drivers/vulkan/api.h://===----------------------------------------------------------------------===//
../../drivers/vulkan/base_buffer.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/base_buffer.h:// clang-format off: must be included before all other headers.
../../drivers/vulkan/base_buffer.h:// clang-format on
../../drivers/vulkan/base_buffer.h://===----------------------------------------------------------------------===//
../../drivers/vulkan/base_buffer.h://===----------------------------------------------------------------------===//
../../drivers/vulkan/base_buffer.h:// the same index - for example, on a CPU or integrated GPU all of them may
../../drivers/vulkan/base_buffer.h:// - Dispatch
../../drivers/vulkan/base_buffer.h://   High-bandwidth device-local memory where we want to ensure that all
../../drivers/vulkan/base_buffer.h:// - Bulk transfer
../../drivers/vulkan/base_buffer.h://   Low-bandwidth often host-local or host-visible memory for
../../drivers/vulkan/base_buffer.h:// - Staging transfer
../../drivers/vulkan/base_buffer.h://   High-bandwidth device-local memory that is also host-visible for
../../drivers/vulkan/base_buffer.h://   low-latency staging. These are generally small buffers used by dispatches
../../drivers/vulkan/base_buffer.h:    // Preferred memory type for device-local dispatch operations.
../../drivers/vulkan/base_buffer.h:    // Preferred memory type for bulk uploads (host->device).
../../drivers/vulkan/base_buffer.h:    // Preferred memory type for bulk downloads (device->host).
../../drivers/vulkan/base_buffer.h:    // Preferred memory type for staging uploads (host->device).
../../drivers/vulkan/base_buffer.h:    // Preferred memory type for staging downloads (device->host).
../../drivers/vulkan/base_buffer.h://===----------------------------------------------------------------------===//
../../drivers/vulkan/base_buffer.h://===----------------------------------------------------------------------===//
../../drivers/vulkan/base_buffer.h:                      ->handle
../../drivers/local_task/task_event.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/local_task/task_event.c:    iree_hal_resource_initialize(&iree_hal_task_event_vtable, &event->resource);
../../drivers/local_task/task_event.c:    event->host_allocator = host_allocator;
../../drivers/local_task/task_event.c:  iree_allocator_t host_allocator = event->host_allocator;
../../drivers/vulkan/CMakeLists.txt:# CMake-only content.                                                          #
../../drivers/amdgpu/semaphore.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/semaphore.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/semaphore.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/semaphore.c:  // futex and is relatively light-weight but the host can only busy-wait on it.
../../drivers/amdgpu/semaphore.c:  // An interrupt signal involves the OS but allows for platform-level waits.
../../drivers/amdgpu/semaphore.c:  // TODO(benvanik): add a semaphore flag for device-only? It's hard to know
../../drivers/amdgpu/semaphore.c:  // that in all cases but in the compiler we could do it for our locally-scoped
../../drivers/amdgpu/semaphore.c:  // If we wanted device-only we'd set the HSA_AMD_SIGNAL_AMD_GPU_ONLY flag.
../../drivers/amdgpu/semaphore.c:              /*consumers=*/NULL, signal_flags, &out_semaphore->signal));
../../drivers/amdgpu/semaphore.c:                               &out_semaphore->resource);
../../drivers/amdgpu/semaphore.c:  iree_atomic_ref_count_dec(&out_semaphore->resource.ref_count);
../../drivers/amdgpu/semaphore.c:  out_semaphore->libhsa = libhsa;
../../drivers/amdgpu/semaphore.c:  out_semaphore->options = options;
../../drivers/amdgpu/semaphore.c:  out_semaphore->flags = flags;
../../drivers/amdgpu/semaphore.c:  out_semaphore->device_semaphore = device_semaphore;
../../drivers/amdgpu/semaphore.c:  out_semaphore->release_callback = release_callback;
../../drivers/amdgpu/semaphore.c:  // NOTE: today we assume the semaphore device memory is host-accessible. In
../../drivers/amdgpu/semaphore.c:  // the future we may make device-only semaphores and would need to do a
../../drivers/amdgpu/semaphore.c:  // host-to-device transfer to update the device semaphore values.
../../drivers/amdgpu/semaphore.c:  device_semaphore->signal = (iree_amd_signal_t*)out_semaphore->signal.handle;
../../drivers/amdgpu/semaphore.c:  device_semaphore->host_semaphore = (uint64_t)out_semaphore;
../../drivers/amdgpu/semaphore.c:  const iree_hal_amdgpu_libhsa_t* libhsa = semaphore->libhsa;
../../drivers/amdgpu/semaphore.c:      iree_hsa_signal_destroy(IREE_LIBHSA(libhsa), semaphore->signal));
../../drivers/amdgpu/semaphore.c:      IREE_LIBHSA(semaphore->libhsa), semaphore->signal, 0);
../../drivers/amdgpu/semaphore.c:  if (semaphore->release_callback.fn) {
../../drivers/amdgpu/semaphore.c:    semaphore->release_callback.fn(semaphore->release_callback.user_data,
../../drivers/amdgpu/semaphore.c:  // Reset the HSA signal value to the user-provided initial value.
../../drivers/amdgpu/semaphore.c:  // https://github.com/ROCm/ROCR-Runtime/issues/316
../../drivers/amdgpu/semaphore.c:  iree_hsa_signal_silent_store_screlease(IREE_LIBHSA(semaphore->libhsa),
../../drivers/amdgpu/semaphore.c:                                         semaphore->signal, initial_value);
../../drivers/amdgpu/semaphore.c:      IREE_LIBHSA(semaphore->libhsa), semaphore->signal);
../../drivers/amdgpu/semaphore.c:      IREE_LIBHSA(semaphore->libhsa), semaphore->signal);
../../drivers/amdgpu/semaphore.c:        IREE_LIBHSA(semaphore->libhsa), semaphore->signal, current_value,
../../drivers/amdgpu/semaphore.c:  // TODO(benvanik): update device-side semaphore entry and wake any schedulers
../../drivers/amdgpu/semaphore.c:      IREE_LIBHSA(semaphore->libhsa), semaphore->signal);
../../drivers/amdgpu/semaphore.c:        IREE_LIBHSA(semaphore->libhsa), semaphore->signal, current_value,
../../drivers/amdgpu/semaphore.c:  return iree_hal_amdgpu_wait_semaphores(semaphore->libhsa, semaphore->options,
../../drivers/amdgpu/semaphore.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/semaphore.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/semaphore.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/semaphore.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/semaphore.c:    *out_handle = semaphore->device_semaphore;
../../drivers/amdgpu/semaphore.c:    *out_signal = semaphore->signal;
../../drivers/amdgpu/semaphore.c:        IREE_LIBHSA(semaphore->libhsa), semaphore->signal);
../../drivers/amdgpu/semaphore.c:  // In wait-any mode the first satisfied condition will return OK.
../../drivers/amdgpu/semaphore.c:  // In wait-all mode the first unsatisfied condition will return
../../drivers/amdgpu/semaphore.c:        // Only one semaphore needs to be reached in wait-any mode.
../../drivers/amdgpu/semaphore.c:        // All semaphores need ot be reached in wait-all mode.
../../drivers/amdgpu/semaphore.c:  // In wait-any mode if none were satisfied then return DEADLINE_EXCEEDED.
../../drivers/amdgpu/semaphore.c:  // In wait-all mode if none were unsatisfied then return OK.
../../drivers/amdgpu/semaphore.c:// with device-side waits.
../../drivers/amdgpu/semaphore.c:  if (semaphore_list.count == 0) return iree_ok_status();  // no-op
../../drivers/amdgpu/semaphore.c:  // Fast-path for immediate timeouts using this API to poll.
../../drivers/amdgpu/semaphore.c:  // Fast-path for single semaphore waits.
../../drivers/amdgpu/semaphore.c:  // ROCR's multi-wait is inefficient and we really want to avoid it if
../../drivers/amdgpu/semaphore.c:  // Build array-of-structs for the individual wait operations.
../../drivers/vulkan/tracing.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/tracing.h:// clang-format off: must be included before all other headers.
../../drivers/vulkan/tracing.h:// clang-format on
../../drivers/vulkan/tracing.h:// Per-queue Vulkan tracing context.
../../drivers/vulkan/tracing.h:// No-op if IREE tracing is not enabled.
../../drivers/vulkan/tracing.h://   IREE_VULKAN_TRACE_ZONE_BEGIN(device->tracing_context, command_buffer);
../../drivers/vulkan/tracing.h://   IREE_VULKAN_TRACE_ZONE_END(queue->tracing_context, command_buffer);
../../drivers/vulkan/tracing.h://   iree_hal_vulkan_tracing_context_collect(queue->tracing_context,
../../drivers/vulkan/tracing.h:// NOTE: timestamps have non-trivial side-effecting behavior on the device:
../../drivers/vulkan/tracing.h://   vkCmdCopyQueryPoolResults is really what we should be using to do this -
../../drivers/vulkan/tracing.h://   that inserts a device-side transfer to a buffer (conceptually) that is
../../drivers/vulkan/tracing.h://   in-stream with all submissions to a queue. This changes things to a push
../../drivers/vulkan/tracing.h:// Thread-compatible: external synchronization is required if using from
../../drivers/vulkan/tracing.h:// Collects in-flight timestamp queries from the queue and feeds them to tracy.
../../drivers/vulkan/descriptor_set_arena.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/descriptor_set_arena.h:  // returns a group that - when dropped - will release the descriptor sets
../../drivers/vulkan/descriptor_set_arena.h:  const DynamicSymbols& syms() const { return *logical_device_->syms(); }
../../drivers/vulkan/builtin/compile_shaders.sh:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/builtin/compile_shaders.sh:set -e
../../drivers/vulkan/builtin/compile_shaders.sh:set -x
../../drivers/vulkan/builtin/compile_shaders.sh:  -Os -fshader-stage=compute -mfmt=bin \
../../drivers/vulkan/builtin/compile_shaders.sh:  -o ${BUILTIN_DIR}/fill_unaligned.spv
../../file.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../file.h://===----------------------------------------------------------------------===//
../../file.h://===----------------------------------------------------------------------===//
../../file.h://===----------------------------------------------------------------------===//
../../file.h://===----------------------------------------------------------------------===//
../../file.h:// may have hardware-optimized transfer paths.
../../file.h://    https://docs.nvidia.com/gpudirect-storage/api-reference-guide/index.html
../../file.h://    https://learn.microsoft.com/en-us/gaming/gdk/_content/gc/system/overviews/directstorage/directstorage-overview
../../file.h:// Some implementations may allow additional non-native contents to be wrapped
../../file.h:// in file handles to provide implementation-controlled transfer even if not
../../file.h:// hardware-accelerated. See iree_hal_file_import for more information.
../../file.h:// Imports an externally-owned |external_file| handle for use on |device|.
../../file.h:// callers must ensure the access is accurate (don't allow writes to read-only
../../file.h:// Returns an optional device-accessible storage buffer representing the file.
../../file.h:// Available if the implementation is able to perform import/address-space
../../file.h:// mapping/etc such that device-side transfers can directly access the resources
../../file.h://===----------------------------------------------------------------------===//
../../file.h://===----------------------------------------------------------------------===//
../../drivers/vulkan/command_queue.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/command_queue.h:// https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSubmitInfo.html
../../drivers/vulkan/command_queue.h:// https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkTimelineSemaphoreSubmitInfo.html
../../drivers/vulkan/command_queue.h:    syms()->vkQueueWaitIdle(queue_);
../../drivers/vulkan/command_queue.h:    return logical_device_->syms();
../../drivers/vulkan/builtin/BUILD.bazel:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/builtin/fill_unaligned.glsl:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/builtin/fill_unaligned.glsl:  uint fill_aligned_start_bytes = fill_offset_bytes - fill_aligned_offset;
../../drivers/vulkan/builtin/fill_unaligned.glsl:    uint length_end = end_byte - end_rounded_down;
../../drivers/vulkan/sparse_buffer.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/sparse_buffer.cc:    if (i < physical_block_count - 1) {
../../drivers/vulkan/sparse_buffer.cc:          requirements.size - physical_block_size * (physical_block_count - 1);
../../drivers/vulkan/sparse_buffer.cc:        logical_device->syms()->vkAllocateMemory(
../../drivers/vulkan/sparse_buffer.cc:            *logical_device, &allocate_info, logical_device->allocator(),
../../drivers/vulkan/sparse_buffer.cc:  // Temporary fence for enforcing host-synchronous execution.
../../drivers/vulkan/sparse_buffer.cc:      z0, VK_RESULT_TO_STATUS(logical_device->syms()->vkCreateFence(
../../drivers/vulkan/sparse_buffer.cc:                                  logical_device->allocator(), &fence),
../../drivers/vulkan/sparse_buffer.cc:      logical_device->syms()->vkQueueBindSparse(queue, 1, &bind_info, fence),
../../drivers/vulkan/sparse_buffer.cc:        logical_device->syms()->vkWaitForFences(
../../drivers/vulkan/sparse_buffer.cc:  logical_device->syms()->vkDestroyFence(*logical_device, fence,
../../drivers/vulkan/sparse_buffer.cc:                                         logical_device->allocator());
../../drivers/vulkan/sparse_buffer.cc:  // of two or aligned to anything in particular - sparse buffers do require
../../drivers/vulkan/sparse_buffer.cc:  // ceil-div for the number of blocks as the last block may be partial.
../../drivers/vulkan/sparse_buffer.cc:      sizeof(buffer->physical_blocks[0]) * physical_block_count;
../../drivers/vulkan/sparse_buffer.cc:      placement, &buffer->base.base, allocation_size, byte_offset, byte_length,
../../drivers/vulkan/sparse_buffer.cc:      &iree_hal_vulkan_sparse_buffer_vtable, &buffer->base.base);
../../drivers/vulkan/sparse_buffer.cc:  buffer->base.host_allocator = host_allocator;
../../drivers/vulkan/sparse_buffer.cc:  buffer->base.handle = handle;
../../drivers/vulkan/sparse_buffer.cc:  buffer->logical_device = logical_device;
../../drivers/vulkan/sparse_buffer.cc:  buffer->physical_block_count = physical_block_count;
../../drivers/vulkan/sparse_buffer.cc:      physical_block_size, physical_block_count, buffer->physical_blocks);
../../drivers/vulkan/sparse_buffer.cc:    *out_buffer = &buffer->base.base;
../../drivers/vulkan/sparse_buffer.cc:  iree::hal::vulkan::VkDeviceHandle* logical_device = buffer->logical_device;
../../drivers/vulkan/sparse_buffer.cc:  iree_allocator_t host_allocator = buffer->base.host_allocator;
../../drivers/vulkan/sparse_buffer.cc:  if (buffer->base.handle != VK_NULL_HANDLE) {
../../drivers/vulkan/sparse_buffer.cc:    logical_device->syms()->vkDestroyBuffer(
../../drivers/vulkan/sparse_buffer.cc:        *logical_device, buffer->base.handle, logical_device->allocator());
../../drivers/vulkan/sparse_buffer.cc:  for (iree_host_size_t i = 0; i < buffer->physical_block_count; ++i) {
../../drivers/vulkan/sparse_buffer.cc:    if (buffer->physical_blocks[i] != VK_NULL_HANDLE) {
../../drivers/vulkan/sparse_buffer.cc:      logical_device->syms()->vkFreeMemory(*logical_device,
../../drivers/vulkan/sparse_buffer.cc:                                           buffer->physical_blocks[i],
../../drivers/vulkan/sparse_buffer.cc:                                           logical_device->allocator());
../../drivers/amdgpu/system_test.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/system_test.cc:  // pointers match (non-NULL).
../../drivers/amdgpu/system_test.cc:  EXPECT_EQ(system->libhsa.hsa_agent_get_info, libhsa.hsa_agent_get_info);
../../drivers/amdgpu/system_test.cc:  ASSERT_EQ(system->topology.cpu_agent_count, topology.cpu_agent_count);
../../drivers/amdgpu/system_test.cc:    EXPECT_EQ(system->topology.cpu_agents[i].handle,
../../drivers/amdgpu/system_test.cc:  ASSERT_EQ(system->topology.gpu_agent_count, topology.gpu_agent_count);
../../drivers/amdgpu/system_test.cc:    EXPECT_EQ(system->topology.gpu_agents[i].handle,
../../drivers/amdgpu/system_test.cc:  EXPECT_NE(system->info.timestamp_frequency, 0);
../../drivers/amdgpu/system_test.cc:  EXPECT_EQ(system->device_library.libhsa, &system->libhsa);
../../drivers/amdgpu/system_test.cc:    EXPECT_NE(system->host_memory_pools[i].fine_region.handle, 0);
../../drivers/amdgpu/system_test.cc:    EXPECT_NE(system->host_memory_pools[i].fine_pool.handle, 0);
../../drivers/vulkan/native_buffer.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/native_buffer.h:// clang-format off: must be included before all other headers.
../../drivers/vulkan/native_buffer.h:// clang-format on
../../drivers/vulkan/vulkan_driver.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/builtin/CMakeLists.txt:# CMake-only content.                                                          #
../../drivers/vulkan/dynamic_symbols.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/dynamic_symbols.h:// clang-format off: must be included before all other headers.
../../drivers/vulkan/dynamic_symbols.h:// clang-format on
../../drivers/vulkan/dynamic_symbols.h:// loads functions we are interested in (a compute-specific subset) and avoids
../../drivers/vulkan/dynamic_symbols.h:// https://github.com/KhronosGroup/Vulkan-Hpp#extensions--per-device-function-pointers
../../drivers/vulkan/dynamic_symbols.h://  syms->vkCreateInstance(..., &instance);
../../drivers/vulkan/dynamic_symbols.h://  IREE_RETURN_IF_ERROR(syms->LoadFromInstance(instance));
../../drivers/vulkan/vulkan_headers.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/vulkan_headers.h:// are no accidental calls to the linker-loaded implicit functions we just
../../drivers/vulkan/vulkan_headers.h:// Other non-core code can choose not to disable the prototypes if they want.
../../drivers/vulkan/vulkan_headers.h:// https://djang86.blogspot.com/2019/01/what-is-vknoprototypes.html
../../drivers/vulkan/extensibility_util.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/extensibility_util.cc:  memset(out_enabled_layers->values, 0,
../../drivers/vulkan/extensibility_util.cc:         (required_layers->count + optional_layers->count) *
../../drivers/vulkan/extensibility_util.cc:             sizeof(out_enabled_layers->values[0]));
../../drivers/vulkan/extensibility_util.cc:  for (iree_host_size_t i = 0; i < required_layers->count; ++i) {
../../drivers/vulkan/extensibility_util.cc:    const char* layer_name = required_layers->values[i];
../../drivers/vulkan/extensibility_util.cc:    out_enabled_layers->values[out_enabled_layers->count++] = layer_name;
../../drivers/vulkan/extensibility_util.cc:  for (iree_host_size_t i = 0; i < optional_layers->count; ++i) {
../../drivers/vulkan/extensibility_util.cc:    const char* layer_name = optional_layers->values[i];
../../drivers/vulkan/extensibility_util.cc:      out_enabled_layers->values[out_enabled_layers->count++] = layer_name;
../../drivers/vulkan/extensibility_util.cc:      syms->vkEnumerateInstanceLayerProperties(&layer_property_count, NULL),
../../drivers/vulkan/extensibility_util.cc:      (VkLayerProperties*)arena->AllocateBytes(layer_property_count *
../../drivers/vulkan/extensibility_util.cc:  VK_RETURN_IF_ERROR(syms->vkEnumerateInstanceLayerProperties(
../../drivers/vulkan/extensibility_util.cc:  out_enabled_layers->count = 0;
../../drivers/vulkan/extensibility_util.cc:  out_enabled_layers->values = (const char**)arena->AllocateBytes(
../../drivers/vulkan/extensibility_util.cc:      (required_layers->count + optional_layers->count) *
../../drivers/vulkan/extensibility_util.cc:      sizeof(out_enabled_layers->values[0]));
../../drivers/vulkan/extensibility_util.cc:  memset(out_enabled_extensions->values, 0,
../../drivers/vulkan/extensibility_util.cc:         (required_extensions->count + optional_extensions->count) *
../../drivers/vulkan/extensibility_util.cc:             sizeof(out_enabled_extensions->values[0]));
../../drivers/vulkan/extensibility_util.cc:  for (iree_host_size_t i = 0; i < required_extensions->count; ++i) {
../../drivers/vulkan/extensibility_util.cc:    const char* extension_name = required_extensions->values[i];
../../drivers/vulkan/extensibility_util.cc:    out_enabled_extensions->values[out_enabled_extensions->count++] =
../../drivers/vulkan/extensibility_util.cc:  for (iree_host_size_t i = 0; i < optional_extensions->count; ++i) {
../../drivers/vulkan/extensibility_util.cc:    const char* extension_name = optional_extensions->values[i];
../../drivers/vulkan/extensibility_util.cc:      out_enabled_extensions->values[out_enabled_extensions->count++] =
../../drivers/vulkan/extensibility_util.cc:  VK_RETURN_IF_ERROR(syms->vkEnumerateInstanceExtensionProperties(
../../drivers/vulkan/extensibility_util.cc:      (VkExtensionProperties*)arena->AllocateBytes(
../../drivers/vulkan/extensibility_util.cc:  VK_RETURN_IF_ERROR(syms->vkEnumerateInstanceExtensionProperties(
../../drivers/vulkan/extensibility_util.cc:  out_enabled_extensions->count = 0;
../../drivers/vulkan/extensibility_util.cc:  out_enabled_extensions->values = (const char**)arena->AllocateBytes(
../../drivers/vulkan/extensibility_util.cc:      (required_extensions->count + optional_extensions->count) *
../../drivers/vulkan/extensibility_util.cc:      sizeof(out_enabled_extensions->values[0]));
../../drivers/vulkan/extensibility_util.cc:      syms->vkEnumerateDeviceExtensionProperties(
../../drivers/vulkan/extensibility_util.cc:      (VkExtensionProperties*)arena->AllocateBytes(
../../drivers/vulkan/extensibility_util.cc:  VK_RETURN_IF_ERROR(syms->vkEnumerateDeviceExtensionProperties(
../../drivers/vulkan/extensibility_util.cc:  out_enabled_extensions->count = 0;
../../drivers/vulkan/extensibility_util.cc:  out_enabled_extensions->values = (const char**)arena->AllocateBytes(
../../drivers/vulkan/extensibility_util.cc:      (required_extensions->count + optional_extensions->count) *
../../drivers/vulkan/extensibility_util.cc:      sizeof(out_enabled_extensions->values[0]));
../../drivers/vulkan/extensibility_util.cc:  for (iree_host_size_t i = 0; i < enabled_extensions->count; ++i) {
../../drivers/vulkan/extensibility_util.cc:    const char* extension_name = enabled_extensions->values[i];
../../drivers/vulkan/extensibility_util.cc:  for (iree_host_size_t i = 0; i < enabled_extensions->count; ++i) {
../../drivers/vulkan/extensibility_util.cc:    const char* extension_name = enabled_extensions->values[i];
../../drivers/vulkan/extensibility_util.cc:  if (device_syms->vkCmdPushDescriptorSetKHR) {
../../drivers/vulkan/extensibility_util.cc:  if (device_syms->vkSignalSemaphore || device_syms->vkSignalSemaphoreKHR) {
../../drivers/vulkan/extensibility_util.cc:  if (device_syms->vkResetQueryPoolEXT) {
../../drivers/vulkan/extensibility_util.cc:  if (device_syms->vkGetCalibratedTimestampsEXT) {
../../drivers/vulkan/extensibility_util.cc:  if (device_syms->vkGetMemoryHostPointerPropertiesEXT) {
../../drivers/vulkan/extensibility_util.cc:  if (device_syms->vkGetBufferDeviceAddress ||
../../drivers/vulkan/extensibility_util.cc:      device_syms->vkGetBufferDeviceAddressKHR) {
../../drivers/vulkan/descriptor_pool_cache.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/descriptor_pool_cache.h:// We only support a single descriptor type for now as we only generate SPIR-V
../../drivers/vulkan/descriptor_pool_cache.h:  const DynamicSymbols& syms() const { return *logical_device_->syms(); }
../../drivers/vulkan/descriptor_pool_cache.h:  // immediately and must no longer be in use by any in-flight command.
../../drivers/vulkan/nop_executable_cache.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/nop_executable_cache.cc:  iree_status_t status = iree_allocator_malloc(logical_device->host_allocator(),
../../drivers/vulkan/nop_executable_cache.cc:                                 &executable_cache->resource);
../../drivers/vulkan/nop_executable_cache.cc:    executable_cache->logical_device = logical_device;
../../drivers/vulkan/nop_executable_cache.cc:      executable_cache->logical_device->host_allocator();
../../drivers/vulkan/nop_executable_cache.cc:                             iree_make_cstring_view("vulkan-spirv-fb"))) {
../../drivers/vulkan/nop_executable_cache.cc:                 iree_make_cstring_view("vulkan-spirv-fb-ptr"))) {
../../drivers/vulkan/nop_executable_cache.cc:        executable_cache->logical_device->enabled_features(),
../../drivers/vulkan/nop_executable_cache.cc:          base_executable_cache, executable_params->caching_mode,
../../drivers/vulkan/nop_executable_cache.cc:          executable_params->executable_format)) {
../../drivers/vulkan/nop_executable_cache.cc:                            (int)executable_params->executable_format.size,
../../drivers/vulkan/nop_executable_cache.cc:                            executable_params->executable_format.data);
../../drivers/vulkan/nop_executable_cache.cc:      executable_cache->logical_device,
../../drivers/vulkan/native_executable.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/native_executable.cc://===----------------------------------------------------------------------===//
../../drivers/vulkan/native_executable.cc://===----------------------------------------------------------------------===//
../../drivers/vulkan/native_executable.cc:             device_properties->limits
../../drivers/vulkan/native_executable.cc:        device_properties->limits.max_per_stage_descriptor_uniform_buffers,
../../drivers/vulkan/native_executable.cc:             device_properties->limits
../../drivers/vulkan/native_executable.cc:        device_properties->limits.max_per_stage_descriptor_storage_buffers,
../../drivers/vulkan/native_executable.cc:    if (push_constant_range->stage_flags != VK_SHADER_STAGE_COMPUTE_BIT &&
../../drivers/vulkan/native_executable.cc:        push_constant_range->stage_flags != VK_SHADER_STAGE_ALL) {
../../drivers/vulkan/native_executable.cc:    // Ensure the push constant range is in-bounds. This is additional early
../../drivers/vulkan/native_executable.cc:        push_constant_range->offset + push_constant_range->size;
../../drivers/vulkan/native_executable.cc:    if (range_end > device_properties->limits.max_push_constants_size) {
../../drivers/vulkan/native_executable.cc:          i, push_constant_range->offset, push_constant_range->size,
../../drivers/vulkan/native_executable.cc:          device_properties->limits.max_push_constants_size);
../../drivers/vulkan/native_executable.cc:  // Run flatcc generated verification. This ensures all pointers are in-bounds
../../drivers/vulkan/native_executable.cc://===----------------------------------------------------------------------===//
../../drivers/vulkan/native_executable.cc://===----------------------------------------------------------------------===//
../../drivers/vulkan/native_executable.cc:  iree_allocator_free(logical_device->host_allocator(), descriptor_set_layouts);
../../drivers/vulkan/native_executable.cc:        logical_device->host_allocator(),
../../drivers/vulkan/native_executable.cc:      binding->binding =
../../drivers/vulkan/native_executable.cc:      binding->descriptorType = static_cast<VkDescriptorType>(
../../drivers/vulkan/native_executable.cc:      binding->descriptorCount =
../../drivers/vulkan/native_executable.cc:      binding->stageFlags = static_cast<VkShaderStageFlags>(
../../drivers/vulkan/native_executable.cc:      binding->pImmutableSamplers = NULL;
../../drivers/vulkan/native_executable.cc:  iree_allocator_free(logical_device->host_allocator(), bindings);
../../drivers/vulkan/native_executable.cc:              logical_device->host_allocator(),
../../drivers/vulkan/native_executable.cc://===----------------------------------------------------------------------===//
../../drivers/vulkan/native_executable.cc://===----------------------------------------------------------------------===//
../../drivers/vulkan/native_executable.cc:  iree_allocator_free(logical_device->host_allocator(), pipeline_layouts);
../../drivers/vulkan/native_executable.cc:      iree_allocator_malloc(logical_device->host_allocator(),
../../drivers/vulkan/native_executable.cc://===----------------------------------------------------------------------===//
../../drivers/vulkan/native_executable.cc://===----------------------------------------------------------------------===//
../../drivers/vulkan/native_executable.cc:      logical_device->syms()->vkDestroyShaderModule(
../../drivers/vulkan/native_executable.cc:          *logical_device, shader_modules[i], logical_device->allocator());
../../drivers/vulkan/native_executable.cc:  iree_allocator_free(logical_device->host_allocator(), shader_modules);
../../drivers/vulkan/native_executable.cc:      VK_RESULT_TO_STATUS(logical_device->syms()->vkCreateShaderModule(
../../drivers/vulkan/native_executable.cc:                              logical_device->allocator(), &shader_module),
../../drivers/vulkan/native_executable.cc:      z0, iree_allocator_malloc(logical_device->host_allocator(),
../../drivers/vulkan/native_executable.cc://===----------------------------------------------------------------------===//
../../drivers/vulkan/native_executable.cc://===----------------------------------------------------------------------===//
../../drivers/vulkan/native_executable.cc:  if (!iree_all_bits_set(executable_params->caching_mode,
../../drivers/vulkan/native_executable.cc:  stage_create_info->sType =
../../drivers/vulkan/native_executable.cc:  stage_create_info->pNext = NULL;
../../drivers/vulkan/native_executable.cc:  stage_create_info->flags = 0;
../../drivers/vulkan/native_executable.cc:  stage_create_info->stage = VK_SHADER_STAGE_COMPUTE_BIT;
../../drivers/vulkan/native_executable.cc:  stage_create_info->module = shader_module;
../../drivers/vulkan/native_executable.cc:  stage_create_info->pName = entry_point;
../../drivers/vulkan/native_executable.cc:  stage_create_info->pSpecializationInfo = specialization_info;
../../drivers/vulkan/native_executable.cc:      stage_create_info->pNext = &subgroup_size_info;
../../drivers/vulkan/native_executable.cc:      logical_device->syms()->vkCreateComputePipelines(
../../drivers/vulkan/native_executable.cc:          logical_device->allocator(), &out_pipeline->handle),
../../drivers/vulkan/native_executable.cc:  out_pipeline->layout = pipeline_layout;
../../drivers/vulkan/native_executable.cc:  iree_hal_vulkan_pipeline_layout_retain(out_pipeline->layout);
../../drivers/vulkan/native_executable.cc:            logical_device->syms()->vkSetDebugUtilsObjectNameEXT) {
../../drivers/vulkan/native_executable.cc:      name_info.objectHandle = (uint64_t)out_pipeline->handle;
../../drivers/vulkan/native_executable.cc:  if (pipeline->handle != VK_NULL_HANDLE) {
../../drivers/vulkan/native_executable.cc:    logical_device->syms()->vkDestroyPipeline(*logical_device, pipeline->handle,
../../drivers/vulkan/native_executable.cc:                                              logical_device->allocator());
../../drivers/vulkan/native_executable.cc:  iree_hal_vulkan_pipeline_layout_release(pipeline->layout);
../../drivers/vulkan/native_executable.cc:// the caller-allocated |pipelines| array. Upon failure the caller is
../../drivers/vulkan/native_executable.cc:// NOTE: this function is designed as a top-level flatbuffer->VkPipeline[] entry
../../drivers/vulkan/native_executable.cc:// point for future multi-threaded pipeline creation. Today we do everything
../../drivers/vulkan/native_executable.cc:  // the total number of pipelines (~5-10 for 1000 pipelines) so we split this
../../drivers/vulkan/native_executable.cc:  if (iree_status_is_ok(status) && executable_params->constant_count) {
../../drivers/vulkan/native_executable.cc:    status = iree_allocator_malloc(logical_device->host_allocator(),
../../drivers/vulkan/native_executable.cc:                                   executable_params->constant_count *
../../drivers/vulkan/native_executable.cc:    specialization_info.mapEntryCount = executable_params->constant_count;
../../drivers/vulkan/native_executable.cc:        executable_params->constant_count * sizeof(uint32_t);
../../drivers/vulkan/native_executable.cc:    specialization_info.pData = executable_params->constants;
../../drivers/vulkan/native_executable.cc:    for (iree_host_size_t i = 0; i < executable_params->constant_count; ++i) {
../../drivers/vulkan/native_executable.cc:  // Create pipelines in-place in the output storage using the temporary
../../drivers/vulkan/native_executable.cc:  iree_allocator_free(logical_device->host_allocator(),
../../drivers/vulkan/native_executable.cc://===----------------------------------------------------------------------===//
../../drivers/vulkan/native_executable.cc://===----------------------------------------------------------------------===//
../../drivers/vulkan/native_executable.cc:  iree_allocator_t host_allocator = logical_device->host_allocator();
../../drivers/vulkan/native_executable.cc:              &logical_device->supported_properties(),
../../drivers/vulkan/native_executable.cc:              executable_params->executable_data));
../../drivers/vulkan/native_executable.cc:          executable_params->executable_data.data);
../../drivers/vulkan/native_executable.cc:      sizeof(*executable) + pipeline_count * sizeof(executable->pipelines[0]) +
../../drivers/vulkan/native_executable.cc:                               &executable->resource);
../../drivers/vulkan/native_executable.cc:  executable->logical_device = logical_device;
../../drivers/vulkan/native_executable.cc:  executable->pipeline_count = pipeline_count;
../../drivers/vulkan/native_executable.cc:  memset(executable->pipelines, 0,
../../drivers/vulkan/native_executable.cc:         pipeline_count * sizeof(executable->pipelines[0]));
../../drivers/vulkan/native_executable.cc:      pipelines_vec, executable->pipelines);
../../drivers/vulkan/native_executable.cc:          ((uint8_t*)executable->pipelines +
../../drivers/vulkan/native_executable.cc:           pipeline_count * sizeof(executable->pipelines[0]));
../../drivers/vulkan/native_executable.cc:        iree_hal_vulkan_pipeline_t* pipeline = &executable->pipelines[i];
../../drivers/vulkan/native_executable.cc:        pipeline->source_location.file_name = export_info->source_filename;
../../drivers/vulkan/native_executable.cc:        pipeline->source_location.line = export_info->source_line;
../../drivers/vulkan/native_executable.cc:        pipeline->source_location.func_name = export_info->function_name;
../../drivers/vulkan/native_executable.cc:      executable->logical_device->host_allocator();
../../drivers/vulkan/native_executable.cc:  for (iree_host_size_t i = 0; i < executable->pipeline_count; ++i) {
../../drivers/vulkan/native_executable.cc:    iree_hal_vulkan_destroy_pipeline(executable->logical_device,
../../drivers/vulkan/native_executable.cc:                                     &executable->pipelines[i]);
../../drivers/vulkan/native_executable.cc:  if (entry_ordinal >= executable->pipeline_count) {
../../drivers/vulkan/native_executable.cc:  *out_pipeline = &executable->pipelines[entry_ordinal];
../../drivers/vulkan/dynamic_symbols.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/dynamic_symbols.cc:// Read-only table of function pointer information designed to be in .rdata.
../../drivers/vulkan/dynamic_symbols.cc:    "vulkan-1.dll",
../../drivers/vulkan/dynamic_symbols.cc:  syms->vkGetInstanceProcAddr = reinterpret_cast<PFN_vkGetInstanceProcAddr>(
../../drivers/vulkan/dynamic_symbols.cc:  // Since Android 8 Oreo, Android re-architected the OS framework with project
../../drivers/vulkan/dynamic_symbols.cc:  // as. a. full-blown. Android. app.
../../drivers/vulkan/dynamic_symbols.cc:  if (!syms->vkGetInstanceProcAddr) {
../../drivers/vulkan/dynamic_symbols.cc:    syms->vkGetInstanceProcAddr =
../../drivers/vulkan/dynamic_symbols.cc:  if (!syms->vkGetInstanceProcAddr) {
../../drivers/vulkan/dynamic_symbols.cc:        syms->vkGetInstanceProcAddr(VK_NULL_HANDLE, function_ptr.function_name);
../../drivers/vulkan/dynamic_symbols.cc:  syms->FixupExtensionFunctions();
../../drivers/vulkan/dynamic_symbols.cc:  syms->loader_library_ = loader_library;
../../drivers/vulkan/dynamic_symbols.cc:  syms->FixupExtensionFunctions();
../../drivers/vulkan/dynamic_symbols.cc:  this->vkGetDeviceProcAddr = reinterpret_cast<PFN_vkGetDeviceProcAddr>(
../../drivers/vulkan/dynamic_symbols.cc:      this->vkGetInstanceProcAddr(instance, "vkGetDeviceProcAddr"));
../../drivers/vulkan/dynamic_symbols.cc:  if (!this->vkGetDeviceProcAddr) {
../../drivers/vulkan/dynamic_symbols.cc:          this->vkGetDeviceProcAddr(device, function_ptr.function_name);
../../drivers/vulkan/dynamic_symbols.cc:          this->vkGetInstanceProcAddr(instance, function_ptr.function_name);
../../drivers/vulkan/dynamic_symbols.cc:  this->vkGetSemaphoreCounterValue = this->vkGetSemaphoreCounterValue
../../drivers/vulkan/dynamic_symbols.cc:                                         ? this->vkGetSemaphoreCounterValue
../../drivers/vulkan/dynamic_symbols.cc:                                         : this->vkGetSemaphoreCounterValueKHR;
../../drivers/vulkan/dynamic_symbols.cc:  this->vkWaitSemaphores = this->vkWaitSemaphores ? this->vkWaitSemaphores
../../drivers/vulkan/dynamic_symbols.cc:                                                  : this->vkWaitSemaphoresKHR;
../../drivers/vulkan/dynamic_symbols.cc:  this->vkSignalSemaphore = this->vkSignalSemaphore
../../drivers/vulkan/dynamic_symbols.cc:                                ? this->vkSignalSemaphore
../../drivers/vulkan/dynamic_symbols.cc:                                : this->vkSignalSemaphoreKHR;
../../drivers/vulkan/status_util.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/status_util.c:      // implementation-specific reasons.
../../drivers/vulkan/status_util.c:      // implementation-specific reasons, indicating that pending and future
../../drivers/vulkan/status_util.c:      // It is not possible to reset the logical device to a non-lost state,
../../drivers/vulkan/status_util.c:      // from that physical device, it must be in the non-lost state.
../../drivers/vulkan/status_util.c:      // Commands that do not allow run-time errors must still operate correctly
../../drivers/vulkan/status_util.c:      // considered in-use by the device, a return value of
../../drivers/vulkan/status_util.c:      // otherwise incompatible for implementation-specific reasons.
../../drivers/vulkan/status_util.c:      // image. (This validation is necessarily implementation-dependent and
../../drivers/vulkan/status_util.c:      // not have exlusive full-screen access. This may occur due to
../../drivers/vulkan/status_util.c:      // implementation-dependent reasons, outside of the applications control.
../../drivers/vulkan/util/arena_test.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/util/arena_test.cc:  EXPECT_EQ(5, my_type_ptr->value);  // Default ctor must be called.
../../drivers/vulkan/util/arena_test.cc:  EXPECT_EQ(10, my_type_ptr->value);  // Ctor should have been called.
../../drivers/amdgpu/device/host_client.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/device/host_client.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/host_client.c:// Device-side Enqueuing
../../drivers/amdgpu/device/host_client.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/host_client.c:      &client->service_queue, 1u, iree_amdgpu_memory_order_relaxed);
../../drivers/amdgpu/device/host_client.c:  while (packet_id -
../../drivers/amdgpu/device/host_client.c:             iree_hsa_queue_load_read_index(&client->service_queue,
../../drivers/amdgpu/device/host_client.c:         client->service_queue.size) {
../../drivers/amdgpu/device/host_client.c:  const uint64_t queue_mask = client->service_queue.size - 1;  // power of two
../../drivers/amdgpu/device/host_client.c:      client->service_queue.base_address + (packet_id & queue_mask) * 64;
../../drivers/amdgpu/device/host_client.c:  agent_packet->reserved0 = 0;
../../drivers/amdgpu/device/host_client.c:  agent_packet->return_address = (void*)return_address;
../../drivers/amdgpu/device/host_client.c:  agent_packet->arg[0] = arg0;
../../drivers/amdgpu/device/host_client.c:  agent_packet->arg[1] = arg1;
../../drivers/amdgpu/device/host_client.c:  agent_packet->arg[2] = arg2;
../../drivers/amdgpu/device/host_client.c:  agent_packet->arg[3] = arg3;
../../drivers/amdgpu/device/host_client.c:  agent_packet->reserved2 = 0;
../../drivers/amdgpu/device/host_client.c:  agent_packet->completion_signal = completion_signal;
../../drivers/amdgpu/device/host_client.c:  // executed back-to-back. If a particular post type supports concurrent or
../../drivers/amdgpu/device/host_client.c:  // out-of-order execution then it _may_ do so unless the bit is set.
../../drivers/amdgpu/device/host_client.c:  // touched on other agents (such as when executing multi-device work as part
../../drivers/amdgpu/device/host_client.c:  // https://sourcegraph.com/github.com/ROCm/rocMLIR/-/blob/external/llvm-project/amd/device-libs/ockl/src/hsaqs.cl?L69
../../drivers/amdgpu/device/host_client.c:  iree_hsa_signal_store(client->service_queue.doorbell_signal, packet_id,
../../drivers/amdgpu/device/host_client.c:  IREE_AMDGPU_TRACE_BUFFER_SCOPE(host->trace_buffer);
../../drivers/amdgpu/device/host_client.c:  IREE_AMDGPU_TRACE_BUFFER_SCOPE(host->trace_buffer);
../../drivers/vulkan/status_util.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/status_util.h:// clang-format off: must be included before all other headers.
../../drivers/vulkan/status_util.h:// clang-format on
../../drivers/vulkan/status_util.h:// - VK_SUCCESS        -> OkStatus()
../../drivers/vulkan/status_util.h:// - VK_NOT_READY      -> OkStatus()
../../drivers/vulkan/status_util.h:// - VK_TIMEOUT        -> OkStatus()
../../drivers/vulkan/status_util.h:// - VK_EVENT_SET      -> OkStatus()
../../drivers/vulkan/status_util.h:// - VK_EVENT_RESET    -> OkStatus()
../../drivers/vulkan/status_util.h:// - VK_INCOMPLETE     -> OkStatus()
../../drivers/vulkan/status_util.h:// - VK_SUBOPTIMAL_KHR -> OkStatus()
../../drivers/vulkan/status_util.h:// - VK_ERROR_OUT_OF_HOST_MEMORY          -> ResourceExhaustedError("VK...")
../../drivers/vulkan/status_util.h:// - VK_ERROR_OUT_OF_DEVICE_MEMORY        -> ResourceExhaustedError("VK...")
../../drivers/vulkan/status_util.h:// - VK_ERROR_INITIALIZATION_FAILED       -> InternalError("VK...")
../../drivers/vulkan/status_util.h:// - VK_ERROR_DEVICE_LOST                 -> InternalError("VK...")
../../drivers/vulkan/status_util.h:// - VK_ERROR_MEMORY_MAP_FAILED           -> InternalError("VK...")
../../drivers/vulkan/status_util.h:// - VK_ERROR_LAYER_NOT_PRESENT           -> NotFoundError("VK...")
../../drivers/vulkan/status_util.h:// - VK_ERROR_EXTENSION_NOT_PRESENT       -> NotFoundError("VK...")
../../drivers/vulkan/status_util.h:// - VK_ERROR_FEATURE_NOT_PRESENT         -> NotFoundError("VK...")
../../drivers/vulkan/status_util.h:// - VK_ERROR_INCOMPATIBLE_DRIVER         -> FailedPreconditionError("VK...")
../../drivers/vulkan/status_util.h:// - VK_ERROR_TOO_MANY_OBJECTS            -> ResourceExhaustedError("VK...")
../../drivers/vulkan/status_util.h:// - VK_ERROR_FORMAT_NOT_SUPPORTED        -> UnimplementedError("VK...")
../../drivers/vulkan/status_util.h:// - VK_ERROR_FRAGMENTED_POOL             -> ResourceExhaustedError("VK...")
../../drivers/vulkan/status_util.h:// - VK_ERROR_OUT_OF_POOL_MEMORY          -> ResourceExhaustedError("VK...")
../../drivers/vulkan/status_util.h:// - VK_ERROR_INVALID_EXTERNAL_HANDLE     -> InvalidArgumentError("VK...")
../../drivers/vulkan/status_util.h:// - VK_ERROR_SURFACE_LOST_KHR            -> InternalError("VK...")
../../drivers/vulkan/status_util.h:// - VK_ERROR_NATIVE_WINDOW_IN_USE_KHR    -> InternalError("VK...")
../../drivers/vulkan/status_util.h:// - VK_ERROR_OUT_OF_DATE_KHR             -> InternalError("VK...")
../../drivers/vulkan/status_util.h:// - VK_ERROR_INCOMPATIBLE_DISPLAY_KHR    -> InternalError("VK...")
../../drivers/vulkan/status_util.h:// - VK_ERROR_VALIDATION_FAILED_EXT       -> InternalError("VK...")
../../drivers/vulkan/status_util.h:// - VK_ERROR_INVALID_SHADER_NV           -> InternalError("VK...")
../../drivers/vulkan/status_util.h:// - VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT  -> InternalError
../../drivers/vulkan/status_util.h:// - VK_ERROR_FRAGMENTATION_EXT           -> ResourceExhaustedError("VK...")
../../drivers/vulkan/status_util.h:// - VK_ERROR_NOT_PERMITTED_EXT           -> PermissionDeniedError("VK...")
../../drivers/vulkan/status_util.h:// - VK_ERROR_INVALID_DEVICE_ADDRESS_EXT  -> OutOfRangeError("VK...")
../../drivers/vulkan/status_util.h:// - VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT -> InternalError("VK...")
../../drivers/vulkan/dynamic_symbols_test.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/dynamic_symbols_test.cc:  app_info.pApplicationName = "IREE-ML-TEST";
../../drivers/vulkan/dynamic_symbols_test.cc:  ASSERT_EQ(VK_SUCCESS, syms->vkCreateInstance(
../../drivers/vulkan/dynamic_symbols_test.cc:  IREE_ASSERT_OK(syms->LoadFromInstance(instance));
../../drivers/vulkan/dynamic_symbols_test.cc:  syms->vkDestroyInstance(instance, /*pAllocator=*/nullptr);
../../drivers/vulkan/util/BUILD.bazel:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/vulkan_device.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/util/arena.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/util/arena.h:// parsing, per-batch write-once/read-once data buffers, etc.
../../drivers/vulkan/util/arena.h:  // Zero-byte allocations will return nullptr.
../../drivers/vulkan/util/arena.h:  // 1024-sizeof(BlockHeader) usable bytes.
../../drivers/vulkan/util/arena.h:  // Singly-linked list of allocated blocks in reverse allocation order (so
../../drivers/vulkan/util/intrusive_list_unique_ptr_test.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/util/intrusive_list_unique_ptr_test.cc:  ~AllocatedType() { --alloc_count; }
../../drivers/vulkan/util/intrusive_list.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/util/intrusive_list.h:// This type is thread-unsafe.
../../drivers/vulkan/util/intrusive_list.h:// Storage for the doubly-linked list.
../../drivers/vulkan/util/intrusive_list.h:  self_type& operator--();
../../drivers/vulkan/util/intrusive_list.h:  self_type operator--(int);
../../drivers/vulkan/util/intrusive_list.h:  // each of them. The built-in OnDeallocate will not be used.
../../drivers/vulkan/util/intrusive_list.h:// -- implementation --
../../drivers/vulkan/util/intrusive_list.h:    return reinterpret_cast<T*>(reinterpret_cast<uintptr_t>(link) - kOffset);
../../drivers/vulkan/util/intrusive_list.h:    current_ = kForward ? current_->next : current_->prev;
../../drivers/vulkan/util/intrusive_list.h:IntrusiveListIterator<T, kOffset, kForward>::operator--() {
../../drivers/vulkan/util/intrusive_list.h:    current_ = kForward ? current_->prev : current_->next;
../../drivers/vulkan/util/intrusive_list.h:IntrusiveListIterator<T, kOffset, kForward>::operator--(int) {
../../drivers/vulkan/util/intrusive_list.h:  operator--();
../../drivers/vulkan/util/intrusive_list.h:    auto* next = link->next;
../../drivers/vulkan/util/intrusive_list.h:    link->prev = link->next = nullptr;
../../drivers/vulkan/util/intrusive_list.h:    if (!link->prev) {
../../drivers/vulkan/util/intrusive_list.h:    if (!link->next) {
../../drivers/vulkan/util/intrusive_list.h:    IREE_ASSERT_EQ(link->prev, previous);
../../drivers/vulkan/util/intrusive_list.h:    link = link->next;
../../drivers/vulkan/util/intrusive_list.h:    link = link->next;
../../drivers/vulkan/util/intrusive_list.h:    tail_->next = other_list->head_;
../../drivers/vulkan/util/intrusive_list.h:  if (other_list->head_) {
../../drivers/vulkan/util/intrusive_list.h:    other_list->head_->prev = tail_;
../../drivers/vulkan/util/intrusive_list.h:    head_ = other_list->head_;
../../drivers/vulkan/util/intrusive_list.h:  tail_ = other_list->tail_;
../../drivers/vulkan/util/intrusive_list.h:  other_list->head_ = nullptr;
../../drivers/vulkan/util/intrusive_list.h:  other_list->tail_ = nullptr;
../../drivers/vulkan/util/intrusive_list.h:  count_ += other_list->count_;
../../drivers/vulkan/util/intrusive_list.h:  other_list->count_ = 0;
../../drivers/vulkan/util/intrusive_list.h:    auto* next = link->next;
../../drivers/vulkan/util/intrusive_list.h:    link->prev = link->next = nullptr;
../../drivers/vulkan/util/intrusive_list.h:  return impl::LinkToT<T, kOffset>(link->next);
../../drivers/vulkan/util/intrusive_list.h:  return impl::LinkToT<T, kOffset>(link->prev);
../../drivers/vulkan/util/intrusive_list.h:  IREE_ASSERT(!link->next);
../../drivers/vulkan/util/intrusive_list.h:  IREE_ASSERT(!link->prev);
../../drivers/vulkan/util/intrusive_list.h:  link->next = head_;
../../drivers/vulkan/util/intrusive_list.h:  link->prev = nullptr;
../../drivers/vulkan/util/intrusive_list.h:  if (link->next) {
../../drivers/vulkan/util/intrusive_list.h:    link->next->prev = link;
../../drivers/vulkan/util/intrusive_list.h:    head_ = head_->next;
../../drivers/vulkan/util/intrusive_list.h:    link->next = link->prev = nullptr;
../../drivers/vulkan/util/intrusive_list.h:      head_->prev = nullptr;
../../drivers/vulkan/util/intrusive_list.h:    --count_;
../../drivers/vulkan/util/intrusive_list.h:  IREE_ASSERT(!link->next);
../../drivers/vulkan/util/intrusive_list.h:  IREE_ASSERT(!link->prev);
../../drivers/vulkan/util/intrusive_list.h:  link->prev = tail_;
../../drivers/vulkan/util/intrusive_list.h:  link->next = nullptr;
../../drivers/vulkan/util/intrusive_list.h:  if (link->prev) {
../../drivers/vulkan/util/intrusive_list.h:    link->prev->next = link;
../../drivers/vulkan/util/intrusive_list.h:    tail_ = tail_->prev;
../../drivers/vulkan/util/intrusive_list.h:    link->next = link->prev = nullptr;
../../drivers/vulkan/util/intrusive_list.h:      tail_->next = nullptr;
../../drivers/vulkan/util/intrusive_list.h:    --count_;
../../drivers/vulkan/util/intrusive_list.h:  IREE_ASSERT(!link->next);
../../drivers/vulkan/util/intrusive_list.h:  IREE_ASSERT(!link->prev);
../../drivers/vulkan/util/intrusive_list.h:    link->next = position_link;
../../drivers/vulkan/util/intrusive_list.h:    link->prev = position_link->prev;
../../drivers/vulkan/util/intrusive_list.h:    position_link->prev->next = link;
../../drivers/vulkan/util/intrusive_list.h:    position_link->prev = link;
../../drivers/vulkan/util/intrusive_list.h:  if (link->prev) {
../../drivers/vulkan/util/intrusive_list.h:    link->prev->next = link->next;
../../drivers/vulkan/util/intrusive_list.h:    head_ = link->next;
../../drivers/vulkan/util/intrusive_list.h:  if (link->next) {
../../drivers/vulkan/util/intrusive_list.h:    link->next->prev = link->prev;
../../drivers/vulkan/util/intrusive_list.h:    tail_ = link->prev;
../../drivers/vulkan/util/intrusive_list.h:  auto* next = link->next;
../../drivers/vulkan/util/intrusive_list.h:  link->next = link->prev = nullptr;
../../drivers/vulkan/util/intrusive_list.h:  --count_;
../../drivers/vulkan/util/intrusive_list.h:  new_link->next = old_link->next;
../../drivers/vulkan/util/intrusive_list.h:  new_link->prev = old_link->prev;
../../drivers/vulkan/util/intrusive_list.h:  if (new_link->prev) {
../../drivers/vulkan/util/intrusive_list.h:    new_link->prev->next = new_link;
../../drivers/vulkan/util/intrusive_list.h:  if (new_link->next) {
../../drivers/vulkan/util/intrusive_list.h:    new_link->next->prev = new_link;
../../drivers/vulkan/util/intrusive_list.h:  old_link->next = old_link->prev = nullptr;
../../drivers/vulkan/util/intrusive_list.h:    // Empty list no-op.
../../drivers/vulkan/util/intrusive_list.h:        q = q->next;
../../drivers/vulkan/util/intrusive_list.h:          q = q->next;
../../drivers/vulkan/util/intrusive_list.h:          --q_size;
../../drivers/vulkan/util/intrusive_list.h:          p = p->next;
../../drivers/vulkan/util/intrusive_list.h:          --p_size;
../../drivers/vulkan/util/intrusive_list.h:          p = p->next;
../../drivers/vulkan/util/intrusive_list.h:          --p_size;
../../drivers/vulkan/util/intrusive_list.h:          q = q->next;
../../drivers/vulkan/util/intrusive_list.h:          --q_size;
../../drivers/vulkan/util/intrusive_list.h:          tail->next = e;
../../drivers/vulkan/util/intrusive_list.h:        e->prev = tail;
../../drivers/vulkan/util/intrusive_list.h:    tail->next = nullptr;
../../drivers/vulkan/util/ref_ptr_test.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/util/ref_ptr_test.cc:  EXPECT_EQ(1, a_ptr->counter_);
../../drivers/vulkan/util/ref_ptr_test.cc:  EXPECT_EQ(1, a->counter_);
../../drivers/vulkan/util/ref_ptr_test.cc:  EXPECT_EQ(1, b->counter_);
../../drivers/vulkan/util/ref_ptr_test.cc:  EXPECT_EQ(2, c->counter_);
../../drivers/vulkan/util/ref_ptr_test.cc:  EXPECT_EQ(1, mt->counter_);
../../drivers/vulkan/util/ref_ptr_test.cc:  EXPECT_EQ(1, mt->counter_);
../../drivers/vulkan/util/ref_ptr_test.cc:  EXPECT_EQ(1, n2->counter_);
../../drivers/vulkan/util/ref_ptr_test.cc:  EXPECT_EQ(1, mt->counter_);
../../drivers/vulkan/util/ref_ptr_test.cc:  EXPECT_EQ(2, mt->counter_);
../../drivers/vulkan/util/ref_ptr_test.cc:  EXPECT_EQ(1, n2->counter_);
../../drivers/vulkan/util/ref_ptr_test.cc:  EXPECT_EQ(2, a_copy->counter_);
../../drivers/vulkan/util/ref_ptr_test.cc:  EXPECT_EQ(1, a_copy->counter_);
../../drivers/vulkan/util/ref_ptr_test.cc:  EXPECT_EQ(1, a_copy->counter_);
../../drivers/vulkan/util/ref_ptr_test.cc:  EXPECT_EQ(2, a_copy->counter_);
../../drivers/vulkan/util/ref_ptr_test.cc:  // No-op on empty ptrs.
../../drivers/vulkan/util/ref_ptr_test.cc:  EXPECT_EQ(1, a_ptr->counter_);
../../drivers/vulkan/util/ref_ptr_test.cc:  // Re-wrap in a ref_ptr.
../../drivers/vulkan/util/ref_ptr_test.cc:  EXPECT_EQ(1, a->counter_);
../../drivers/vulkan/util/ref_ptr_test.cc:  // No-op on empty ptrs.
../../drivers/vulkan/util/ref_ptr_test.cc:  EXPECT_EQ(5, a->x);
../../drivers/vulkan/util/ref_ptr_test.cc:  a->x = 100;
../../drivers/vulkan/util/ref_ptr_test.cc:  EXPECT_EQ(100, a->x);
../../drivers/vulkan/util/ref_ptr_test.cc:  EXPECT_EQ(1, a->counter_);
../../drivers/vulkan/util/ref_ptr_test.cc:  EXPECT_EQ(2, a->counter_);
../../drivers/vulkan/util/ref_ptr_test.cc:  EXPECT_EQ(1, a->counter_);
../../drivers/vulkan/util/ref_ptr_test.cc:  EXPECT_EQ(1, base->counter_);
../../drivers/vulkan/util/ref_ptr_test.cc:    ~StackAllocationType() { --alloc_count; }
../../drivers/vulkan/util/ref_ptr_test.cc:    ~DefaultDeleterType() { --alloc_count; }
../../drivers/vulkan/util/ref_ptr_test.cc:      --alloc_count;
../../drivers/vulkan/util/ref_ptr_test.cc:  virtual ~VirtualDtorTypeA() { --alloc_count_a; }
../../drivers/vulkan/util/ref_ptr_test.cc:  ~VirtualDtorTypeB() override { --alloc_count_b; }
../../drivers/vulkan/util/ref_ptr.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/util/ref_ptr.h:// no additional code. It also allows us to round-trip object pointers
../../drivers/vulkan/util/ref_ptr.h:// through regular pointers, which is critical when having to round-trip
../../drivers/vulkan/util/ref_ptr.h:// When round-tripping the pointer through external APIs, use release():
../../drivers/vulkan/util/ref_ptr.h:// ref_ptr manages the target objects in a thread-safe way, though you'll want
../../drivers/vulkan/util/ref_ptr.h:  // To re-wrap in a ref_ptr use either ref_ptr<T>(value) or assign().
../../drivers/vulkan/util/ref_ptr.h:  // operator* and operator-> will assert() if there is no current object.
../../drivers/vulkan/util/ref_ptr.h:  constexpr T* operator->() const noexcept { return px_; }
../../drivers/vulkan/util/ref_ptr.h:// when round-tripping objects through marshaling boundaries (v8/Java) or
../../drivers/vulkan/util/ref_ptr.h:// http://www.drdobbs.com/cpp/a-base-class-for-intrusively-reference-c/229218807
../../drivers/vulkan/util/ref_ptr.h://     // Optional; can be used to return to pool/etc - must be public:
../../drivers/vulkan/util/ref_ptr.h:    static auto Test(C* p) -> decltype(C::Delete(nullptr), std::true_type());
../../drivers/vulkan/util/ref_ptr.h:      int previous_count = ref_obj->counter_.fetch_sub(1);
../../drivers/vulkan/util/ref_ptr.h:      fprintf(stdout, "ro-- %s %p now %d%s", typeid(V).name(), p,
../../drivers/vulkan/util/ref_ptr.h:              previous_count - 1, previous_count == 1 ? " DEAD (CUSTOM)" : "");
../../drivers/vulkan/util/ref_ptr.h:      int previous_count = ref_obj->counter_.fetch_sub(1);
../../drivers/vulkan/util/ref_ptr.h:      fprintf(stdout, "ro-- %s %p now %d%s", typeid(V).name(), p,
../../drivers/vulkan/util/ref_ptr.h:              previous_count - 1, previous_count == 1 ? " DEAD" : "");
../../drivers/vulkan/util/ref_ptr.h:    ++ref_obj->counter_;
../../drivers/vulkan/util/ref_ptr.h:            ref_obj->counter_.load());
../../drivers/vulkan/util/ref_ptr.h:  // iree_vm_ref_t glue that allows RefObject-derived types to be round-tripped
../../drivers/vulkan/util/ref_ptr.h:  // For simple POD types or non-virtual classes we expect this to return 0.
../../drivers/amdgpu/device/CMakeLists.txt:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/device/CMakeLists.txt:#===------------------------------------------------------------------------===#
../../drivers/amdgpu/device/CMakeLists.txt:#===------------------------------------------------------------------------===#
../../drivers/amdgpu/device/CMakeLists.txt:#===------------------------------------------------------------------------===#
../../drivers/amdgpu/device/CMakeLists.txt:#===------------------------------------------------------------------------===#
../../drivers/amdgpu/device/CMakeLists.txt:#===------------------------------------------------------------------------===#
../../drivers/amdgpu/device/CMakeLists.txt:# Architecture-specific Binaries
../../drivers/amdgpu/device/CMakeLists.txt:#===------------------------------------------------------------------------===#
../../drivers/amdgpu/device/CMakeLists.txt:      amdgcn-amd-amdhsa--${_ARCH}
../../drivers/amdgpu/device/CMakeLists.txt:      amdgcn-amd-amdhsa
../../drivers/amdgpu/device/CMakeLists.txt:  list(APPEND _ARCH_BINARIES "amdgcn-amd-amdhsa--${_ARCH}.so")
../../drivers/amdgpu/device/CMakeLists.txt:#===------------------------------------------------------------------------===#
../../drivers/amdgpu/device/CMakeLists.txt:#===------------------------------------------------------------------------===#
../../drivers/amdgpu/device/tracing.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/device/tracing.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/tracing.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/tracing.h:// used when specifically tracing device-side execution.
../../drivers/amdgpu/device/tracing.h:// used when specifically tracing device-side execution.
../../drivers/amdgpu/device/tracing.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/tracing.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/tracing.h:// A process-unique ID assigned to an agent that executes execution zones.
../../drivers/amdgpu/device/tracing.h:// timing information for the event. Being 16-bit we have a limited number of
../../drivers/amdgpu/device/tracing.h:// A pointer that lives within the read-only data segment of the device library
../../drivers/amdgpu/device/tracing.h:// range. When translating the host will pass-through any such pointers without
../../drivers/amdgpu/device/tracing.h:// modifying them to allow for host pointers to be round-tripped from the host.
../../drivers/amdgpu/device/tracing.h://  const uint8_t* host_ptr = (const uint8_t*)(device_ptr - code_base +
../../drivers/amdgpu/device/tracing.h:// A NUL-terminated string literal stored in the code object data segment.
../../drivers/amdgpu/device/tracing.h:  // TODO(benvanik): try to see if we can get the memory pool name in 7 bytes -
../../drivers/amdgpu/device/tracing.h:  // TODO(benvanik): try to see if we can get the literal in 7 bytes - if so
../../drivers/amdgpu/device/tracing.h:  // TODO(benvanik): try to see if we can get the plot name in 7 bytes - if so
../../drivers/amdgpu/device/tracing.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/tracing.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/tracing.h:// Must be a power-of-two.
../../drivers/amdgpu/device/tracing.h:// A ringbuffer of device-only query signals that can be acquired/released in
../../drivers/amdgpu/device/tracing.h:// the host - there's no backing mailbox/doorbell for raising interrupts and
../../drivers/amdgpu/device/tracing.h:// memory from the perspective of the device - only the host cares if they are
../../drivers/amdgpu/device/tracing.h:// Thread-compatible; only the thread owning the trace buffer will acquire and
../../drivers/amdgpu/device/tracing.h:                                                       ringbuffer->signals) -
../../drivers/amdgpu/device/tracing.h:// Returns a device-only HSA signal handle for the query signal at the given
../../drivers/amdgpu/device/tracing.h:  return (iree_hsa_signal_t){(uint64_t)&ringbuffer->signals[query_id]};
../../drivers/amdgpu/device/tracing.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/tracing.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/tracing.h:// Single-producer/single-consumer ringbuffer with mapping tricks.
../../drivers/amdgpu/device/tracing.h:// if (write_reserve_offset + requested_size - read_commit_offset >= capacity) {
../../drivers/amdgpu/device/tracing.h:// https://github.com/google/wuffs/blob/main/script/mmap-ring-buffer.c
../../drivers/amdgpu/device/tracing.h://   physical: <ringbuffer size> --+------+------+
../../drivers/amdgpu/device/tracing.h://                                        +-- base_ptr
../../drivers/amdgpu/device/tracing.h:// riskiest and with a Tracy-imposed uint16_t signal query ringbuffer we have to
../../drivers/amdgpu/device/tracing.h:// Thread-compatible; single-producer/single-consumer. The scheduler that owns
../../drivers/amdgpu/device/tracing.h:// as the pointer used during an allocation event) or as special read-only data
../../drivers/amdgpu/device/tracing.h:  // (ringbuffer_base-ringbuffer_capacity, ringbuffer_base+ringbuffer_capacity).
../../drivers/amdgpu/device/tracing.h:  // Process-unique executor ID used for tracing command execution.
../../drivers/amdgpu/device/tracing.h:  // Absolute offset - must be masked with ringbuffer_mask.
../../drivers/amdgpu/device/tracing.h:  // Absolute offset - must be masked with ringbuffer_mask.
../../drivers/amdgpu/device/tracing.h:  // Absolute offset - must be masked with ringbuffer_mask.
../../drivers/amdgpu/device/tracing.h:  // Ringbuffer of device-only signals that can be used to get timestamps from
../../drivers/amdgpu/device/tracing.h:  ((trace_buffer)->ringbuffer_capacity - 1)
../../drivers/amdgpu/device/tracing.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/tracing.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/tracing.h:// Begins a new zone with the given compile-time |name_literal|.
../../drivers/amdgpu/device/tracing.h:// Begins a new zone with the given compile-time |name_literal| and color.
../../drivers/amdgpu/device/tracing.h:// times. The provided NUL-terminated C string will be referenced directly.
../../drivers/amdgpu/device/tracing.h:// The provided NUL-terminated C string or string view will be copied into the
../../drivers/amdgpu/device/tracing.h:// The message text must be a compile-time string literal.
../../drivers/amdgpu/device/tracing.h:// The message text must be a compile-time string literal.
../../drivers/amdgpu/device/tracing.h:// Logs a dynamically-allocated message at the given logging level to the trace.
../../drivers/amdgpu/device/tracing.h:// Logs a dynamically-allocated message with the given color to the trace.
../../drivers/amdgpu/device/tracing.h:// Logs a message formatted with an extremely basic sprintf-like function.
../../drivers/amdgpu/device/tracing.h://   %s (NUL-terminated string)
../../drivers/amdgpu/device/tracing.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/tracing.h:// Device-side API
../../drivers/amdgpu/device/tracing.h://===----------------------------------------------------------------------===//
../../drivers/vulkan/debug_reporter.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/debug_reporter.cc:// far outside of the call - it is called in-context from arbitrary threads with
../../drivers/vulkan/debug_reporter.cc:// Vulkan objects, issuing most Vulkan commands, etc are off-limits.
../../drivers/vulkan/debug_reporter.cc:  if (message_verbosity < reporter->min_verbosity) {
../../drivers/vulkan/debug_reporter.cc:    fprintf(stderr, "[VULKAN] %c %s\n", severity_char, callback_data->pMessage);
../../drivers/vulkan/debug_reporter.cc:// Populates |create_info| with an instance-agnostic callback.
../../drivers/vulkan/debug_reporter.cc:  out_create_info->sType =
../../drivers/vulkan/debug_reporter.cc:  out_create_info->pNext = nullptr;
../../drivers/vulkan/debug_reporter.cc:  out_create_info->flags = 0;
../../drivers/vulkan/debug_reporter.cc:  out_create_info->messageSeverity =
../../drivers/vulkan/debug_reporter.cc:  out_create_info->messageType =
../../drivers/vulkan/debug_reporter.cc:  out_create_info->pfnUserCallback =
../../drivers/vulkan/debug_reporter.cc:  out_create_info->pUserData = nullptr;
../../drivers/vulkan/debug_reporter.cc:  reporter->host_allocator = host_allocator;
../../drivers/vulkan/debug_reporter.cc:  reporter->instance = instance;
../../drivers/vulkan/debug_reporter.cc:  reporter->syms = syms;
../../drivers/vulkan/debug_reporter.cc:  reporter->min_verbosity = min_verbosity;
../../drivers/vulkan/debug_reporter.cc:  reporter->allocation_callbacks = allocation_callbacks;
../../drivers/vulkan/debug_reporter.cc:      syms->vkCreateDebugUtilsMessengerEXT(
../../drivers/vulkan/debug_reporter.cc:          instance, &create_info, allocation_callbacks, &reporter->messenger),
../../drivers/vulkan/debug_reporter.cc:  iree_allocator_t host_allocator = reporter->host_allocator;
../../drivers/vulkan/debug_reporter.cc:  if (reporter->messenger != VK_NULL_HANDLE) {
../../drivers/vulkan/debug_reporter.cc:    reporter->syms->vkDestroyDebugUtilsMessengerEXT(
../../drivers/vulkan/debug_reporter.cc:        reporter->instance, reporter->messenger,
../../drivers/vulkan/debug_reporter.cc:        reporter->allocation_callbacks);
../../drivers/vulkan/util/arena.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/util/arena.cc:  return ((value + alignment - 1) / alignment) * alignment;
../../drivers/vulkan/util/arena.cc:    auto next_block = block_header->next_block;
../../drivers/vulkan/util/arena.cc:    auto next_block = block_header->next_block;
../../drivers/vulkan/util/arena.cc:    auto next_block = block_header->next_block;
../../drivers/vulkan/util/arena.cc:    block_header->bytes_allocated = 0;
../../drivers/vulkan/util/arena.cc:    block_header->next_block = unused_block_list_head_;
../../drivers/vulkan/util/arena.cc:    // Guarantee zero-length allocations return nullptr.
../../drivers/vulkan/util/arena.cc:      block_list_head_->bytes_allocated + aligned_length > block_size_) {
../../drivers/vulkan/util/arena.cc:      unused_block_list_head_ = block_header->next_block;
../../drivers/vulkan/util/arena.cc:      block_header->next_block = block_list_head_;
../../drivers/vulkan/util/arena.cc:      block_header->bytes_allocated = 0;
../../drivers/vulkan/util/arena.cc:      block_header->next_block = block_list_head_;
../../drivers/vulkan/util/arena.cc:      block_header->bytes_allocated = 0;
../../drivers/vulkan/util/arena.cc:                  sizeof(BlockHeader) + target_block->bytes_allocated;
../../drivers/vulkan/util/arena.cc:  target_block->bytes_allocated += aligned_length;
../../drivers/vulkan/native_semaphore.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/native_semaphore.h:// Performs a multi-wait on one or more semaphores.
../../drivers/vulkan/native_semaphore.h:// By default this is an all-wait but |wait_flags| may contain
../../drivers/vulkan/native_semaphore.h:// VK_SEMAPHORE_WAIT_ANY_BIT to change to an any-wait.
../../drivers/amdgpu/device/blit.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/device/blit.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/blit.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/blit.c:  if (context->trace_buffer) {
../../drivers/amdgpu/device/blit.c:            &context->trace_buffer->query_ringbuffer);
../../drivers/amdgpu/device/blit.c:            context->trace_buffer, zone_type, 0, execution_query_id);
../../drivers/amdgpu/device/blit.c:      &context->queue, 1u, iree_amdgpu_memory_order_relaxed);
../../drivers/amdgpu/device/blit.c:  while (packet_id - iree_hsa_queue_load_read_index(
../../drivers/amdgpu/device/blit.c:                         &context->queue, iree_amdgpu_memory_order_acquire) >=
../../drivers/amdgpu/device/blit.c:         context->queue.size) {
../../drivers/amdgpu/device/blit.c:  packet->completion_signal = completion_signal;
../../drivers/amdgpu/device/blit.c:  if (context->trace_buffer) {
../../drivers/amdgpu/device/blit.c:  const uint32_t header_setup = header | (uint32_t)(packet->setup << 16);
../../drivers/amdgpu/device/blit.c:  iree_hsa_signal_store(context->queue.doorbell_signal, packet_id,
../../drivers/amdgpu/device/blit.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/blit.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/blit.c:  return id_y * iree_amdgcn_dispatch_ptr()->grid_size[0] + id_x;
../../drivers/amdgpu/device/blit.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/blit.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/blit.c:// Fills a block of up to IREE_HAL_AMDGPU_FILL_BLOCK_COUNT 16-byte elements with
../../drivers/amdgpu/device/blit.c:// a fixed pattern. Requires an alignment of 16-bytes on both the |target_ptr|
../../drivers/amdgpu/device/blit.c:                      element_length - element_offset) /
../../drivers/amdgpu/device/blit.c:// an 8-byte value.
../../drivers/amdgpu/device/blit.c:  IREE_AMDGPU_TRACE_BUFFER_SCOPE(context->trace_buffer);
../../drivers/amdgpu/device/blit.c:        &context->kernels->iree_hal_amdgpu_device_buffer_fill_block_x16;
../../drivers/amdgpu/device/blit.c:        kernel_args = &context->kernels->iree_hal_amdgpu_device_buffer_fill_x1;
../../drivers/amdgpu/device/blit.c:        kernel_args = &context->kernels->iree_hal_amdgpu_device_buffer_fill_x2;
../../drivers/amdgpu/device/blit.c:        kernel_args = &context->kernels->iree_hal_amdgpu_device_buffer_fill_x4;
../../drivers/amdgpu/device/blit.c:        kernel_args = &context->kernels->iree_hal_amdgpu_device_buffer_fill_x8;
../../drivers/amdgpu/device/blit.c:  kernargs->target_ptr = target_ptr;
../../drivers/amdgpu/device/blit.c:  kernargs->element_length = element_count;
../../drivers/amdgpu/device/blit.c:  kernargs->pattern = pattern;
../../drivers/amdgpu/device/blit.c:  const uint64_t queue_mask = context->queue.size - 1;  // power of two
../../drivers/amdgpu/device/blit.c:      context->queue.base_address + (packet_id & queue_mask) * 64;
../../drivers/amdgpu/device/blit.c:  dispatch_packet->setup = kernel_args->setup;
../../drivers/amdgpu/device/blit.c:  dispatch_packet->workgroup_size[0] = kernel_args->workgroup_size[0];
../../drivers/amdgpu/device/blit.c:  dispatch_packet->workgroup_size[1] = kernel_args->workgroup_size[1];
../../drivers/amdgpu/device/blit.c:  dispatch_packet->workgroup_size[2] = kernel_args->workgroup_size[2];
../../drivers/amdgpu/device/blit.c:  dispatch_packet->reserved0 = 0;
../../drivers/amdgpu/device/blit.c:  dispatch_packet->grid_size[0] = grid_size_x;
../../drivers/amdgpu/device/blit.c:  dispatch_packet->grid_size[1] = grid_size_y;
../../drivers/amdgpu/device/blit.c:  dispatch_packet->grid_size[2] = 1;
../../drivers/amdgpu/device/blit.c:  dispatch_packet->private_segment_size = kernel_args->private_segment_size;
../../drivers/amdgpu/device/blit.c:  dispatch_packet->group_segment_size = kernel_args->group_segment_size;
../../drivers/amdgpu/device/blit.c:  dispatch_packet->kernel_object = kernel_args->kernel_object;
../../drivers/amdgpu/device/blit.c:  dispatch_packet->kernarg_address = kernarg_ptr;
../../drivers/amdgpu/device/blit.c:  dispatch_packet->reserved2 = 0;
../../drivers/amdgpu/device/blit.c:  IREE_AMDGPU_TRACE_BUFFER_SCOPE(context->trace_buffer);
../../drivers/amdgpu/device/blit.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/blit.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/blit.c:// Copies a block of up to IREE_HAL_AMDGPU_COPY_BLOCK_COUNT 16-byte elements
../../drivers/amdgpu/device/blit.c:// from |source_ptr| to |target_ptr|. Requires an alignment of 16-bytes on all
../../drivers/amdgpu/device/blit.c:                                               element_length - element_offset);
../../drivers/amdgpu/device/blit.c:  IREE_AMDGPU_TRACE_BUFFER_SCOPE(context->trace_buffer);
../../drivers/amdgpu/device/blit.c:        &context->kernels->iree_hal_amdgpu_device_buffer_copy_block_x16;
../../drivers/amdgpu/device/blit.c:    kernel_args = &context->kernels->iree_hal_amdgpu_device_buffer_copy_x1;
../../drivers/amdgpu/device/blit.c:  kernargs->source_ptr = source_ptr;
../../drivers/amdgpu/device/blit.c:  kernargs->target_ptr = target_ptr;
../../drivers/amdgpu/device/blit.c:  kernargs->element_length = element_count;
../../drivers/amdgpu/device/blit.c:  const uint64_t queue_mask = context->queue.size - 1;  // power of two
../../drivers/amdgpu/device/blit.c:      context->queue.base_address + (packet_id & queue_mask) * 64;
../../drivers/amdgpu/device/blit.c:  dispatch_packet->setup = kernel_args->setup;
../../drivers/amdgpu/device/blit.c:  dispatch_packet->workgroup_size[0] = kernel_args->workgroup_size[0];
../../drivers/amdgpu/device/blit.c:  dispatch_packet->workgroup_size[1] = kernel_args->workgroup_size[1];
../../drivers/amdgpu/device/blit.c:  dispatch_packet->workgroup_size[2] = kernel_args->workgroup_size[2];
../../drivers/amdgpu/device/blit.c:  dispatch_packet->reserved0 = 0;
../../drivers/amdgpu/device/blit.c:  dispatch_packet->grid_size[0] = grid_size_x;
../../drivers/amdgpu/device/blit.c:  dispatch_packet->grid_size[1] = grid_size_y;
../../drivers/amdgpu/device/blit.c:  dispatch_packet->grid_size[2] = 1;
../../drivers/amdgpu/device/blit.c:  dispatch_packet->private_segment_size = kernel_args->private_segment_size;
../../drivers/amdgpu/device/blit.c:  dispatch_packet->group_segment_size = kernel_args->group_segment_size;
../../drivers/amdgpu/device/blit.c:  dispatch_packet->kernel_object = kernel_args->kernel_object;
../../drivers/amdgpu/device/blit.c:  dispatch_packet->kernarg_address = kernarg_ptr;
../../drivers/amdgpu/device/blit.c:  dispatch_packet->reserved2 = 0;
../../drivers/amdgpu/device/blit.c:  IREE_AMDGPU_TRACE_BUFFER_SCOPE(context->trace_buffer);
../../drivers/vulkan/util/CMakeLists.txt:# CMake-only content.                                                          #
../../drivers/vulkan/util/intrusive_list_test.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/util/intrusive_list_test.cc:    values.push_back(item->value);
../../drivers/vulkan/util/intrusive_list_test.cc:    values.push_back(item->value);
../../drivers/vulkan/util/intrusive_list_test.cc:  EXPECT_EQ(4, (*it)->value);
../../drivers/vulkan/util/intrusive_list_test.cc:bool Comparison(Item* a, Item* b) { return a->value < b->value; }
../../drivers/vulkan/util/intrusive_list_test.cc:    regular.push_back((*it)->value);
../../drivers/vulkan/util/intrusive_list_test.cc:    reverse.push_back((*rit)->value);
../../drivers/vulkan/util/intrusive_list_test.cc:  // Multi-item clear.
../../drivers/vulkan/util/intrusive_list_test.cc:  // No-op first.
../../drivers/vulkan/util/intrusive_list_test.cc:  items.sort([](Item* a, Item* b) { return a->value < b->value; });
../../drivers/vulkan/util/intrusive_list_test.cc:  items.sort([](Item* a, Item* b) { return a->value < b->value; });
../../drivers/vulkan/util/intrusive_list_test.cc:  items.sort([](Item* a, Item* b) { return a->value < b->value; });
../../drivers/vulkan/util/intrusive_list_test.cc:  items.sort([](Item* a, Item* b) { return a->value < b->value; });
../../drivers/vulkan/util/intrusive_list_test.cc:  items.sort([](Item* a, Item* b) { return a->value < b->value; });
../../drivers/vulkan/util/intrusive_list_test.cc:  items.sort([](Item* a, Item* b) { return a->value <= b->value; });
../../drivers/vulkan/extensibility_util.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/extensibility_util.h:// A list of NUL-terminated strings (so they can be passed directly to Vulkan).
../../drivers/vulkan/extensibility_util.h:  // https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/chap44.html#VK_EXT_debug_utils
../../drivers/vulkan/extensibility_util.h:  // Floating-point compute related feature bitfield:
../../drivers/vulkan/extensibility_util.h:  // * 0b01: 8-bit
../../drivers/vulkan/extensibility_util.h:  // * 0b10: 16-bit
../../drivers/vulkan/extensibility_util.h:  // ("dotprod.<input-type>.<output-type>")
../../drivers/vulkan/extensibility_util.h:  // ("coopmatrix.<input-element-type>.<output-element-type>.<m>x<n>x<k>")
../../drivers/amdgpu/physical_device.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/physical_device.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/physical_device.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/physical_device.h:// Power-of-two size for the per-device small block pool in bytes.
../../drivers/amdgpu/physical_device.h:// Reduces allocation overhead at the cost of under-utilizing memory.
../../drivers/amdgpu/physical_device.h:// Initial capacity in blocks of the per-device small block pool. Block pools
../../drivers/amdgpu/physical_device.h:// will grow as needed but accounting is cleaner if we pre-initialize them to a
../../drivers/amdgpu/physical_device.h:// Power-of-two size for the per-device large block pool in bytes.
../../drivers/amdgpu/physical_device.h:// Reduces allocation overhead at the cost of under-utilizing memory.
../../drivers/amdgpu/physical_device.h:// Initial capacity in blocks of the per-device large block pool. Block pools
../../drivers/amdgpu/physical_device.h:// will grow as needed but accounting is cleaner if we pre-initialize them to a
../../drivers/amdgpu/physical_device.h:// Power-of-two size for the per-device host block pool in bytes.
../../drivers/amdgpu/physical_device.h:// Since primarily used for transient submission-specific allocations it need
../../drivers/amdgpu/physical_device.h:  // Used for both coarse-grained and fine-grained memory types.
../../drivers/amdgpu/physical_device.h:  // Size of the per-device small host block pool.
../../drivers/amdgpu/physical_device.h:  // This is primarily used for per-submission resource sets and other transient
../../drivers/amdgpu/physical_device.h:  // bucketed types (e.g. host-side or device-side queues) to allow for tuning
../../drivers/amdgpu/physical_device.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/physical_device.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/physical_device.h:  // Fine-grained block pools for device memory blocks of various sizes.
../../drivers/amdgpu/physical_device.h:  // Fine-grained block pool-based allocators for small transient allocations.
../../drivers/amdgpu/physical_device.h:  // Coarse-grained block pools for device memory blocks of various sizes.
../../drivers/amdgpu/physical_device.h:  // Coarse-grained block pool-based allocators for small transient allocations.
../../drivers/amdgpu/physical_device.h:  // Host-side small allocation block pool.
../../drivers/amdgpu/physical_device.h:  // Host-side service worker for supporting device library requests.
../../drivers/amdgpu/physical_device.h:  // HAL queues with associated device-side schedulers.
../../drivers/amdgpu/physical_device.h:// Deinitializes a physical device and deallocates all device-specific
../../drivers/vulkan/pipeline_layout.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/pipeline_layout.cc://===----------------------------------------------------------------------===//
../../drivers/vulkan/pipeline_layout.cc://===----------------------------------------------------------------------===//
../../drivers/vulkan/pipeline_layout.cc:      z0, iree_allocator_malloc(logical_device->host_allocator(),
../../drivers/vulkan/pipeline_layout.cc:  iree_atomic_ref_count_init(&descriptor_set_layout->ref_count);
../../drivers/vulkan/pipeline_layout.cc:  descriptor_set_layout->logical_device = logical_device;
../../drivers/vulkan/pipeline_layout.cc:  descriptor_set_layout->handle = VK_NULL_HANDLE;
../../drivers/vulkan/pipeline_layout.cc:    if (logical_device->enabled_extensions().push_descriptors) {
../../drivers/vulkan/pipeline_layout.cc:      logical_device->syms()->vkCreateDescriptorSetLayout(
../../drivers/vulkan/pipeline_layout.cc:          *logical_device, &create_info, logical_device->allocator(),
../../drivers/vulkan/pipeline_layout.cc:          &descriptor_set_layout->handle),
../../drivers/vulkan/pipeline_layout.cc:  VkDeviceHandle* logical_device = descriptor_set_layout->logical_device;
../../drivers/vulkan/pipeline_layout.cc:  iree_allocator_t host_allocator = logical_device->host_allocator();
../../drivers/vulkan/pipeline_layout.cc:  if (descriptor_set_layout->handle != VK_NULL_HANDLE) {
../../drivers/vulkan/pipeline_layout.cc:    logical_device->syms()->vkDestroyDescriptorSetLayout(
../../drivers/vulkan/pipeline_layout.cc:        *logical_device, descriptor_set_layout->handle,
../../drivers/vulkan/pipeline_layout.cc:        logical_device->allocator());
../../drivers/vulkan/pipeline_layout.cc:    iree_atomic_ref_count_inc(&descriptor_set_layout->ref_count);
../../drivers/vulkan/pipeline_layout.cc:      iree_atomic_ref_count_dec(&descriptor_set_layout->ref_count) == 1) {
../../drivers/vulkan/pipeline_layout.cc:  return descriptor_set_layout->handle;
../../drivers/vulkan/pipeline_layout.cc://===----------------------------------------------------------------------===//
../../drivers/vulkan/pipeline_layout.cc://===----------------------------------------------------------------------===//
../../drivers/vulkan/pipeline_layout.cc:      set_layout_count * sizeof(*pipeline_layout->set_layouts);
../../drivers/vulkan/pipeline_layout.cc:      z0, iree_allocator_malloc(logical_device->host_allocator(), total_size,
../../drivers/vulkan/pipeline_layout.cc:  iree_atomic_ref_count_init(&pipeline_layout->ref_count);
../../drivers/vulkan/pipeline_layout.cc:  pipeline_layout->logical_device = logical_device;
../../drivers/vulkan/pipeline_layout.cc:  pipeline_layout->handle = VK_NULL_HANDLE;
../../drivers/vulkan/pipeline_layout.cc:  pipeline_layout->set_layout_count = set_layout_count;
../../drivers/vulkan/pipeline_layout.cc:    pipeline_layout->set_layouts[i] = set_layouts[i];
../../drivers/vulkan/pipeline_layout.cc:    set_layout_handles[i] = set_layouts[i]->handle;
../../drivers/vulkan/pipeline_layout.cc:      logical_device->syms()->vkCreatePipelineLayout(
../../drivers/vulkan/pipeline_layout.cc:          *logical_device, &create_info, logical_device->allocator(),
../../drivers/vulkan/pipeline_layout.cc:          &pipeline_layout->handle),
../../drivers/vulkan/pipeline_layout.cc:  VkDeviceHandle* logical_device = pipeline_layout->logical_device;
../../drivers/vulkan/pipeline_layout.cc:  iree_allocator_t host_allocator = logical_device->host_allocator();
../../drivers/vulkan/pipeline_layout.cc:  if (pipeline_layout->handle != VK_NULL_HANDLE) {
../../drivers/vulkan/pipeline_layout.cc:    logical_device->syms()->vkDestroyPipelineLayout(
../../drivers/vulkan/pipeline_layout.cc:        *logical_device, pipeline_layout->handle, logical_device->allocator());
../../drivers/vulkan/pipeline_layout.cc:  for (iree_host_size_t i = 0; i < pipeline_layout->set_layout_count; ++i) {
../../drivers/vulkan/pipeline_layout.cc:        pipeline_layout->set_layouts[i]);
../../drivers/vulkan/pipeline_layout.cc:    iree_atomic_ref_count_inc(&pipeline_layout->ref_count);
../../drivers/vulkan/pipeline_layout.cc:      iree_atomic_ref_count_dec(&pipeline_layout->ref_count) == 1) {
../../drivers/vulkan/pipeline_layout.cc:  return pipeline_layout->handle;
../../drivers/vulkan/pipeline_layout.cc:  return pipeline_layout->set_layout_count;
../../drivers/vulkan/pipeline_layout.cc:  if (IREE_UNLIKELY(set_index >= pipeline_layout->set_layout_count)) {
../../drivers/vulkan/pipeline_layout.cc:  return pipeline_layout->set_layouts[set_index];
../../drivers/vulkan/registration/CMakeLists.txt:# CMake-only content.                                                          #
../../drivers/vulkan/registration/driver_module.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/registration/driver_module.h:// clang-format off: must be included before all other headers.
../../drivers/vulkan/registration/driver_module.h:// clang-format on
../../drivers/amdgpu/device/command_buffer.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/device/command_buffer.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.h:// Device-side Command Buffer
../../drivers/amdgpu/device/command_buffer.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.h:// Command buffers are represented by a host-side wrapper that implements the
../../drivers/amdgpu/device/command_buffer.h:// IREE HAL API and a device-side data structure holding the recorded contents.
../../drivers/amdgpu/device/command_buffer.h:// operation. Though the device-side recorded command buffer closely follows the
../../drivers/amdgpu/device/command_buffer.h:// AQL packet construction to issue-time; future iterations could blend the two
../../drivers/amdgpu/device/command_buffer.h:// +----------------------------------+
../../drivers/amdgpu/device/command_buffer.h:// +-----------------------v----------+
../../drivers/amdgpu/device/command_buffer.h://                         |   +-----------------------------------------+
../../drivers/amdgpu/device/command_buffer.h://                (device) +---> iree_hal_amdgpu_device_command_buffer_t |
../../drivers/amdgpu/device/command_buffer.h://                             +------------------v----------------------+
../../drivers/amdgpu/device/command_buffer.h://      +------------+------------+------------+--+------+--+------------+
../../drivers/amdgpu/device/command_buffer.h:// +----v----+  +----v----+  +----v----+  +----v----+  +----v----+  +----v----+
../../drivers/amdgpu/device/command_buffer.h:// +----v----+  +---------+  +---------+  +---------+  +---------+  +---------+
../../drivers/amdgpu/device/command_buffer.h://      |    +------------------------------+
../../drivers/amdgpu/device/command_buffer.h://      +----> command entry[]              | fixed-length struct array
../../drivers/amdgpu/device/command_buffer.h://      |    +------------------------------+
../../drivers/amdgpu/device/command_buffer.h://      +----> embedded command data...     | variable length packed buffer
../../drivers/amdgpu/device/command_buffer.h://           +------------------------------+
../../drivers/amdgpu/device/command_buffer.h:// Each block contains one or more commands encoded in fixed-length entries.
../../drivers/amdgpu/device/command_buffer.h:// variable-length data the commands require in read-only memory such as update
../../drivers/amdgpu/device/command_buffer.h:// Execution-invariant information is stored in the command and any
../../drivers/amdgpu/device/command_buffer.h:// execution-dependent information is stored as either deltas/relative values or
../../drivers/amdgpu/device/command_buffer.h:// that any optional AQL packet not used must still be set to a valid no-op
../../drivers/amdgpu/device/command_buffer.h://   5. Enqueue top-level queue scheduler upon completion
../../drivers/amdgpu/device/command_buffer.h://=----------------------------------------------------------------------------=
../../drivers/amdgpu/device/command_buffer.h:// issued. This also allows the thread-compatible tracing logic to operate in
../../drivers/amdgpu/device/command_buffer.h:// single-threaded mode with the scheduler queue being the only one producing
../../drivers/amdgpu/device/command_buffer.h://              +=========+  +-------------+                      +--------+
../../drivers/amdgpu/device/command_buffer.h:// scheduler q: | execute |->| issue block |...                ...| retire |
../../drivers/amdgpu/device/command_buffer.h://              +=========+  +|-|-|-|-|-|-|+                      +--------+
../../drivers/amdgpu/device/command_buffer.h://                             +-----+-----+-----+-----+-----+--|--+
../../drivers/amdgpu/device/command_buffer.h://                             +-----+-----+-----+-----+-----+-----+
../../drivers/amdgpu/device/command_buffer.h:// CUDA stream-like APIs are not the target here (as they aren't good) and we
../../drivers/amdgpu/device/command_buffer.h:// align more with the graph-based approaches of modern CUDA (though that too
../../drivers/amdgpu/device/command_buffer.h:// has issues). Latency on tiny command buffers (1-8 commands) is really the
../../drivers/amdgpu/device/command_buffer.h:// in the future with more special-casing or scheduler-level carve-outs. Hooray.
../../drivers/amdgpu/device/command_buffer.h://=----------------------------------------------------------------------------=
../../drivers/amdgpu/device/command_buffer.h:// same queue. Events used within the command buffer have a signal-before-wait
../../drivers/amdgpu/device/command_buffer.h:// others may be substituted with per-invocation state (indirectly referenced
../../drivers/amdgpu/device/command_buffer.h:// not what it declares to be in AQL-land. Static indirect dispatch is always
../../drivers/amdgpu/device/command_buffer.h://=----------------------------------------------------------------------------=
../../drivers/amdgpu/device/command_buffer.h://  +------------+
../../drivers/amdgpu/device/command_buffer.h://  +------------+
../../drivers/amdgpu/device/command_buffer.h://  | dispatch A |  --> AQL dispatch w/ barrier = true (await all prior)
../../drivers/amdgpu/device/command_buffer.h://  +------------+
../../drivers/amdgpu/device/command_buffer.h://  +------------+
../../drivers/amdgpu/device/command_buffer.h://  | dispatch B |  --> AQL dispatch w/ barrier = true (await dispatch A)
../../drivers/amdgpu/device/command_buffer.h://  +------------+
../../drivers/amdgpu/device/command_buffer.h:// the next barrier. To support single-pass recording we do some tricks with
../../drivers/amdgpu/device/command_buffer.h://  +------------+
../../drivers/amdgpu/device/command_buffer.h://  | dispatch A |  --> dispatch w/ barrier = true (await all prior)
../../drivers/amdgpu/device/command_buffer.h://  +------------+
../../drivers/amdgpu/device/command_buffer.h://  | dispatch B |  --> dispatch w/ barrier = false (execute concurrently)
../../drivers/amdgpu/device/command_buffer.h://  +------------+
../../drivers/amdgpu/device/command_buffer.h://  +------------+
../../drivers/amdgpu/device/command_buffer.h://  | dispatch A |  --> acquire (as needed), release AGENT
../../drivers/amdgpu/device/command_buffer.h://  +------------+
../../drivers/amdgpu/device/command_buffer.h://  | dispatch B |  --> acquire AGENT, release (as needed)
../../drivers/amdgpu/device/command_buffer.h://  +------------+
../../drivers/amdgpu/device/command_buffer.h://  +------------+
../../drivers/amdgpu/device/command_buffer.h://  | barrier    |  --> acquire (as needed), release AGENT
../../drivers/amdgpu/device/command_buffer.h://  +------------+
../../drivers/amdgpu/device/command_buffer.h://  | dispatch A |  --> acquire/release NONE
../../drivers/amdgpu/device/command_buffer.h://  +------------+
../../drivers/amdgpu/device/command_buffer.h://  | dispatch B |  --> acquire/release NONE
../../drivers/amdgpu/device/command_buffer.h://  +------------+
../../drivers/amdgpu/device/command_buffer.h://  | barrier    |  --> release (as needed)
../../drivers/amdgpu/device/command_buffer.h://  +------------+
../../drivers/amdgpu/device/command_buffer.h:// record-time the command buffer logic running here on device is kept much
../../drivers/amdgpu/device/command_buffer.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.h:  // TODO(benvanik): trace flush block for intra-block query/sampling resets.
../../drivers/amdgpu/device/command_buffer.h:  // common case of straight-line execution.
../../drivers/amdgpu/device/command_buffer.h:// Commands are fixed-size to allow for indexing into an array of commands.
../../drivers/amdgpu/device/command_buffer.h:// Additional variable-length data is stored out-of-band of the command struct.
../../drivers/amdgpu/device/command_buffer.h:  // Value must be a pointer to a process-lifetime string literal. The host-side
../../drivers/amdgpu/device/command_buffer.h:// prior commands have completed. This is effectively a no-op packet that just
../../drivers/amdgpu/device/command_buffer.h:// have an events table-like thing or something that allows capture at time of
../../drivers/amdgpu/device/command_buffer.h:// verify lifetime and invalid cross-command-buffer usage. The event handle
../../drivers/amdgpu/device/command_buffer.h:// For now the event-based code below uses an opaque value that we can
../../drivers/amdgpu/device/command_buffer.h:// barrier-and packet and allows us to avoid additional storage/indirections in
../../drivers/amdgpu/device/command_buffer.h:// packets if the event count exceeds the capacity of the barrier-and packet.
../../drivers/amdgpu/device/command_buffer.h:  // Block-relative kernel arguments address.
../../drivers/amdgpu/device/command_buffer.h:  // Block-relative kernel arguments address.
../../drivers/amdgpu/device/command_buffer.h:  // appended (with 8-byte alignment) to the kernargs.
../../drivers/amdgpu/device/command_buffer.h:  // Block-relative kernel arguments address.
../../drivers/amdgpu/device/command_buffer.h:  // This will be added to the per-execution base kernel arguments address
../../drivers/amdgpu/device/command_buffer.h:  // Block-relative kernel arguments address.
../../drivers/amdgpu/device/command_buffer.h:  // Block-relative kernel arguments address.
../../drivers/amdgpu/device/command_buffer.h:  // Block-relative kernel arguments address.
../../drivers/amdgpu/device/command_buffer.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.h:  // Each entry contains the query ID to use in control-only mode and the one to
../../drivers/amdgpu/device/command_buffer.h:// device such that any embedded device-local pointers are always valid for any
../../drivers/amdgpu/device/command_buffer.h:// queue the block is issued on. Any pointers that reference per-execution
../../drivers/amdgpu/device/command_buffer.h:// Blocks are stored in a read-only memory region.
../../drivers/amdgpu/device/command_buffer.h:  // valid no-op AQL packets to ensure forward progress by the packet processor.
../../drivers/amdgpu/device/command_buffer.h:  // Aligned storage for fixed-length command structures.
../../drivers/amdgpu/device/command_buffer.h:// Command buffers are stored in a read-only memory region.
../../drivers/amdgpu/device/command_buffer.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.h:  // Timings are captured by the hardware and stored on a per-command query
../../drivers/amdgpu/device/command_buffer.h:// issue a sequence of commands before tail-enqueuing further processing or a
../../drivers/amdgpu/device/command_buffer.h:// return back to the top-level scheduler.
../../drivers/amdgpu/device/command_buffer.h:    // This lets us toll-free share the transfer_state with the command buffer
../../drivers/amdgpu/device/command_buffer.h:      // This may differ from the top-level scheduling queue.
../../drivers/amdgpu/device/command_buffer.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.h:// Device-side Enqueuing
../../drivers/amdgpu/device/command_buffer.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/CMakeLists.txt:# CMake-only content.                                                          #
../../drivers/amdgpu/CMakeLists.txt:    "iree-hal-drivers-amdgpu-tests"
../../drivers/amdgpu/CMakeLists.txt:    "iree-hal-drivers-amdgpu-tests"
../../drivers/amdgpu/CMakeLists.txt:    "iree-hal-drivers-amdgpu-tests"
../../drivers/amdgpu/CMakeLists.txt:    "iree-hal-drivers-amdgpu-tests"
../../drivers/vulkan/util/intrusive_list_unique_ptr.inc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/util/intrusive_list_unique_ptr.inc:    if (link->prev) {
../../drivers/vulkan/util/intrusive_list_unique_ptr.inc:      link->prev->next = link->next;
../../drivers/vulkan/util/intrusive_list_unique_ptr.inc:      head_ = link->next;
../../drivers/vulkan/util/intrusive_list_unique_ptr.inc:    if (link->next) {
../../drivers/vulkan/util/intrusive_list_unique_ptr.inc:      link->next->prev = link->prev;
../../drivers/vulkan/util/intrusive_list_unique_ptr.inc:      tail_ = link->prev;
../../drivers/vulkan/util/intrusive_list_unique_ptr.inc:    link->next = link->prev = nullptr;
../../drivers/vulkan/util/intrusive_list_unique_ptr.inc:    --count_;
../../drivers/amdgpu/device/blit.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/device/blit.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/blit.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/device/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.c:  const uint64_t queue_mask = state->execution_queue.size - 1;  // power of two
../../drivers/amdgpu/device/command_buffer.c:  return state->execution_queue.base_address + (packet_id & queue_mask) * 64;
../../drivers/amdgpu/device/command_buffer.c:  // Translate command flags; they're mostly just bit-packed header bits.
../../drivers/amdgpu/device/command_buffer.c:      ((cmd_header->flags &
../../drivers/amdgpu/device/command_buffer.c:                     : ((cmd_header->flags >>
../../drivers/amdgpu/device/command_buffer.c:                     : ((cmd_header->flags >>
../../drivers/amdgpu/device/command_buffer.c:// Emplaces a lightweight barrier packet (no cache management, no-op wait)
../../drivers/amdgpu/device/command_buffer.c:  const uint64_t queue_mask = state->execution_queue.size - 1;  // power of two
../../drivers/amdgpu/device/command_buffer.c:      state->execution_queue.base_address + (packet_id & queue_mask) * 64;
../../drivers/amdgpu/device/command_buffer.c:  // No signals to make this a no-op.
../../drivers/amdgpu/device/command_buffer.c:  for (size_t i = 0; i < IREE_AMDGPU_ARRAYSIZE(packet->dep_signal); ++i) {
../../drivers/amdgpu/device/command_buffer.c:    packet->dep_signal[i] = iree_hsa_signal_null();
../../drivers/amdgpu/device/command_buffer.c:  packet->completion_signal = completion_signal;
../../drivers/amdgpu/device/command_buffer.c:      iree_hal_amdgpu_device_make_cmd_packet_header(cmd_header, state->flags);
../../drivers/amdgpu/device/command_buffer.c:  const uint64_t queue_mask = state->execution_queue.size - 1;  // power of two
../../drivers/amdgpu/device/command_buffer.c:      (iree_hsa_kernel_dispatch_packet_t*)state->execution_queue.base_address +
../../drivers/amdgpu/device/command_buffer.c:  packet->setup = kernel_args->setup;
../../drivers/amdgpu/device/command_buffer.c:  packet->workgroup_size[0] = kernel_args->workgroup_size[0];
../../drivers/amdgpu/device/command_buffer.c:  packet->workgroup_size[1] = kernel_args->workgroup_size[1];
../../drivers/amdgpu/device/command_buffer.c:  packet->workgroup_size[2] = kernel_args->workgroup_size[2];
../../drivers/amdgpu/device/command_buffer.c:  packet->reserved0 = 0;
../../drivers/amdgpu/device/command_buffer.c:  packet->grid_size[0] = 1;
../../drivers/amdgpu/device/command_buffer.c:  packet->grid_size[1] = 1;
../../drivers/amdgpu/device/command_buffer.c:  packet->grid_size[2] = 1;
../../drivers/amdgpu/device/command_buffer.c:  packet->private_segment_size = kernel_args->private_segment_size;
../../drivers/amdgpu/device/command_buffer.c:  packet->group_segment_size = kernel_args->group_segment_size;
../../drivers/amdgpu/device/command_buffer.c:  packet->kernel_object = kernel_args->kernel_object;
../../drivers/amdgpu/device/command_buffer.c:  packet->kernarg_address = kernarg_ptr;
../../drivers/amdgpu/device/command_buffer.c:  packet->reserved2 = 0;
../../drivers/amdgpu/device/command_buffer.c:    packet->completion_signal =
../../drivers/amdgpu/device/command_buffer.c:            state->trace_buffer,
../../drivers/amdgpu/device/command_buffer.c:            kernel_args->trace_src_loc, execution_query_id);
../../drivers/amdgpu/device/command_buffer.c:    packet->completion_signal = iree_hsa_signal_null();
../../drivers/amdgpu/device/command_buffer.c:  packet->completion_signal = iree_hsa_signal_null();
../../drivers/amdgpu/device/command_buffer.c:      iree_hal_amdgpu_device_make_cmd_packet_header(cmd_header, state->flags);
../../drivers/amdgpu/device/command_buffer.c:  const uint32_t header_setup = header | (uint32_t)(packet->setup << 16);
../../drivers/amdgpu/device/command_buffer.c:  iree_hsa_signal_store(state->execution_queue.doorbell_signal, packet_id,
../../drivers/amdgpu/device/command_buffer.c:    packet->completion_signal =
../../drivers/amdgpu/device/command_buffer.c:            state->trace_buffer, execution_zone_type, export_loc,
../../drivers/amdgpu/device/command_buffer.c:    packet->completion_signal = iree_hsa_signal_null();
../../drivers/amdgpu/device/command_buffer.c:  packet->completion_signal = iree_hsa_signal_null();
../../drivers/amdgpu/device/command_buffer.c:  // NOTE: we don't assign the packet type yet - the commit needs to do that
../../drivers/amdgpu/device/command_buffer.c:  packet->header =
../../drivers/amdgpu/device/command_buffer.c:      iree_hal_amdgpu_device_make_cmd_packet_header(cmd_header, state->flags);
../../drivers/amdgpu/device/command_buffer.c:      (packet->header &
../../drivers/amdgpu/device/command_buffer.c:  const uint32_t header_setup = header | (uint32_t)(packet->setup << 16);
../../drivers/amdgpu/device/command_buffer.c:          state->trace_buffer, state->trace_block_query_base_id,
../../drivers/amdgpu/device/command_buffer.c:          state->trace_block_query_count);
../../drivers/amdgpu/device/command_buffer.c:  for (uint16_t i = 0; i < state->trace_block_query_count; ++i) {
../../drivers/amdgpu/device/command_buffer.c:                &state->trace_buffer->query_ringbuffer,
../../drivers/amdgpu/device/command_buffer.c:                state->trace_block_query_base_id + i)
../../drivers/amdgpu/device/command_buffer.c:        .begin = signal->start_ts,
../../drivers/amdgpu/device/command_buffer.c:        .end = signal->end_ts,
../../drivers/amdgpu/device/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.c:// Device-side Enqueuing
../../drivers/amdgpu/device/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.c:      &state->execution_queue, state->block->max_packet_count,
../../drivers/amdgpu/device/command_buffer.c:  while (base_packet_id -
../../drivers/amdgpu/device/command_buffer.c:             iree_hsa_queue_load_read_index(&state->execution_queue,
../../drivers/amdgpu/device/command_buffer.c:         state->execution_queue.size) {
../../drivers/amdgpu/device/command_buffer.c:  iree_hsa_signal_store(state->execution_queue.doorbell_signal,
../../drivers/amdgpu/device/command_buffer.c:                        base_packet_id + state->block->max_packet_count,
../../drivers/amdgpu/device/command_buffer.c:  for (uint32_t i = 0; i < state->block->command_count; ++i) {
../../drivers/amdgpu/device/command_buffer.c:    iree_hal_amdgpu_device_cmd_issue(state, state->block, i, base_packet_id);
../../drivers/amdgpu/device/command_buffer.c:  const iree_amd_cached_queue_t* control_queue = state->control_queue;
../../drivers/amdgpu/device/command_buffer.c:  while (control_packet_id -
../../drivers/amdgpu/device/command_buffer.c:         control_queue->size) {
../../drivers/amdgpu/device/command_buffer.c:      &state->execution_queue, state->block->max_packet_count,
../../drivers/amdgpu/device/command_buffer.c:  while (base_packet_id -
../../drivers/amdgpu/device/command_buffer.c:             iree_hsa_queue_load_read_index(&state->execution_queue,
../../drivers/amdgpu/device/command_buffer.c:         state->execution_queue.size) {
../../drivers/amdgpu/device/command_buffer.c:  uint64_t* kernarg_ptr = (uint64_t*)state->control_kernarg_storage;
../../drivers/amdgpu/device/command_buffer.c:  kernarg_ptr[1] = (uint64_t)state->block;
../../drivers/amdgpu/device/command_buffer.c:      state->kernels->iree_hal_amdgpu_device_cmd_block_issue;
../../drivers/amdgpu/device/command_buffer.c:  const uint64_t queue_mask = control_queue->size - 1;  // power of two
../../drivers/amdgpu/device/command_buffer.c:      (iree_hsa_kernel_dispatch_packet_t*)control_queue->base_address +
../../drivers/amdgpu/device/command_buffer.c:  control_packet->setup = control_args.setup;
../../drivers/amdgpu/device/command_buffer.c:  control_packet->workgroup_size[0] = control_args.workgroup_size[0];
../../drivers/amdgpu/device/command_buffer.c:  control_packet->workgroup_size[1] = control_args.workgroup_size[1];
../../drivers/amdgpu/device/command_buffer.c:  control_packet->workgroup_size[2] = control_args.workgroup_size[2];
../../drivers/amdgpu/device/command_buffer.c:  control_packet->reserved0 = 0;
../../drivers/amdgpu/device/command_buffer.c:  control_packet->grid_size[0] = state->block->command_count;
../../drivers/amdgpu/device/command_buffer.c:  control_packet->grid_size[1] = 1;
../../drivers/amdgpu/device/command_buffer.c:  control_packet->grid_size[2] = 1;
../../drivers/amdgpu/device/command_buffer.c:  control_packet->private_segment_size = control_args.private_segment_size;
../../drivers/amdgpu/device/command_buffer.c:  control_packet->group_segment_size = control_args.group_segment_size;
../../drivers/amdgpu/device/command_buffer.c:  control_packet->kernel_object = control_args.kernel_object;
../../drivers/amdgpu/device/command_buffer.c:  control_packet->kernarg_address = kernarg_ptr;
../../drivers/amdgpu/device/command_buffer.c:  control_packet->reserved2 = 0;
../../drivers/amdgpu/device/command_buffer.c:  control_packet->completion_signal.handle = 0;
../../drivers/amdgpu/device/command_buffer.c:      control_header | (uint32_t)(control_packet->setup << 16);
../../drivers/amdgpu/device/command_buffer.c:  iree_hsa_signal_store(control_queue->doorbell_signal, control_packet_id,
../../drivers/amdgpu/device/command_buffer.c:  if (state->flags & IREE_HAL_AMDGPU_DEVICE_EXECUTION_FLAG_TRACE_DISPATCH) {
../../drivers/amdgpu/device/command_buffer.c:    query_count = state->block->query_map.max_dispatch_query_count;
../../drivers/amdgpu/device/command_buffer.c:  } else if (state->flags &
../../drivers/amdgpu/device/command_buffer.c:    query_count = state->block->query_map.max_control_query_count;
../../drivers/amdgpu/device/command_buffer.c:  state->trace_block_query_count = query_count;
../../drivers/amdgpu/device/command_buffer.c:    state->trace_block_query_base_id =
../../drivers/amdgpu/device/command_buffer.c:            &state->trace_buffer->query_ringbuffer, query_count);
../../drivers/amdgpu/device/command_buffer.c:  if (state->flags & IREE_HAL_AMDGPU_DEVICE_EXECUTION_FLAG_ISSUE_SERIALLY) {
../../drivers/amdgpu/device/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.c:        state->trace_buffer, execution_query_id, cmd->src_loc);
../../drivers/amdgpu/device/command_buffer.c:  // Emit a lightweight barrier packet (no cache management, no-op wait) to
../../drivers/amdgpu/device/command_buffer.c:      state, &cmd->header, packet_id, completion_signal);
../../drivers/amdgpu/device/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.c:        state->trace_buffer, execution_query_id);
../../drivers/amdgpu/device/command_buffer.c:  // Emit a lightweight barrier packet (no cache management, no-op wait) to
../../drivers/amdgpu/device/command_buffer.c:      state, &cmd->header, packet_id, completion_signal);
../../drivers/amdgpu/device/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.c:      state, &cmd->header, packet_id, iree_hsa_signal_null());
../../drivers/amdgpu/device/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.c:  void* target_ptr = iree_hal_amdgpu_device_buffer_ref_resolve(cmd->target_ref,
../../drivers/amdgpu/device/command_buffer.c:                                                               state->bindings);
../../drivers/amdgpu/device/command_buffer.c:  const uint64_t length = cmd->target_ref.length;
../../drivers/amdgpu/device/command_buffer.c:      (uint64_t*)(state->execution_kernarg_storage + cmd->kernarg_offset);
../../drivers/amdgpu/device/command_buffer.c:          &state->transfer_context, target_ptr, length, cmd->pattern,
../../drivers/amdgpu/device/command_buffer.c:          cmd->pattern_length, kernarg_ptr, packet_id);
../../drivers/amdgpu/device/command_buffer.c:      state, &cmd->header, packet,
../../drivers/amdgpu/device/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.c:      cmd->source_ref, state->bindings);
../../drivers/amdgpu/device/command_buffer.c:  void* target_ptr = iree_hal_amdgpu_device_buffer_ref_resolve(cmd->target_ref,
../../drivers/amdgpu/device/command_buffer.c:                                                               state->bindings);
../../drivers/amdgpu/device/command_buffer.c:  const uint64_t length = cmd->target_ref.length;
../../drivers/amdgpu/device/command_buffer.c:      (uint64_t*)(state->execution_kernarg_storage + cmd->kernarg_offset);
../../drivers/amdgpu/device/command_buffer.c:          &state->transfer_context, source_ptr, target_ptr, length, kernarg_ptr,
../../drivers/amdgpu/device/command_buffer.c:      state, &cmd->header, packet,
../../drivers/amdgpu/device/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.c:      cmd->config.kernel_args;
../../drivers/amdgpu/device/command_buffer.c:  for (uint16_t i = 0; i < dispatch_args->binding_count; ++i) {
../../drivers/amdgpu/device/command_buffer.c:        (uint64_t)iree_hal_amdgpu_device_buffer_ref_resolve(cmd->bindings[i],
../../drivers/amdgpu/device/command_buffer.c:                                                            state->bindings);
../../drivers/amdgpu/device/command_buffer.c:      kernarg_base + dispatch_args->binding_count * sizeof(void*);
../../drivers/amdgpu/device/command_buffer.c:  iree_amdgpu_memcpy(kernarg_ptr, cmd->constants,
../../drivers/amdgpu/device/command_buffer.c:                     dispatch_args->constant_count * sizeof(uint32_t));
../../drivers/amdgpu/device/command_buffer.c:  packet->setup = dispatch_args->setup;
../../drivers/amdgpu/device/command_buffer.c:  packet->workgroup_size[0] = dispatch_args->workgroup_size[0];
../../drivers/amdgpu/device/command_buffer.c:  packet->workgroup_size[1] = dispatch_args->workgroup_size[1];
../../drivers/amdgpu/device/command_buffer.c:  packet->workgroup_size[2] = dispatch_args->workgroup_size[2];
../../drivers/amdgpu/device/command_buffer.c:  packet->reserved0 = 0;
../../drivers/amdgpu/device/command_buffer.c:  packet->private_segment_size = dispatch_args->private_segment_size;
../../drivers/amdgpu/device/command_buffer.c:  packet->group_segment_size =
../../drivers/amdgpu/device/command_buffer.c:      dispatch_args->group_segment_size + cmd->config.dynamic_lds_size;
../../drivers/amdgpu/device/command_buffer.c:  packet->kernel_object = dispatch_args->kernel_object;
../../drivers/amdgpu/device/command_buffer.c:  packet->kernarg_address = kernarg_ptr;
../../drivers/amdgpu/device/command_buffer.c:  packet->reserved2 = 0;
../../drivers/amdgpu/device/command_buffer.c:  if (cmd->config.flags &
../../drivers/amdgpu/device/command_buffer.c:            cmd->config.workgroup_count.ref, state->bindings);
../../drivers/amdgpu/device/command_buffer.c:    workgroup_count_ptr = cmd->config.workgroup_count.dims;
../../drivers/amdgpu/device/command_buffer.c:  packet->grid_size[0] = workgroup_count_ptr[0] * packet->workgroup_size[0];
../../drivers/amdgpu/device/command_buffer.c:  packet->grid_size[1] = workgroup_count_ptr[1] * packet->workgroup_size[1];
../../drivers/amdgpu/device/command_buffer.c:  packet->grid_size[2] = workgroup_count_ptr[2] * packet->workgroup_size[2];
../../drivers/amdgpu/device/command_buffer.c:  // IREE_AMDGPU_KERNEL_IMPLICIT_ARGS_SIZE-byte suffix that we initialize
../../drivers/amdgpu/device/command_buffer.c:  if (cmd->header.flags & IREE_HAL_AMDGPU_DEVICE_DISPATCH_FLAG_IMPLICIT_ARGS) {
../../drivers/amdgpu/device/command_buffer.c:        iree_amdgpu_align(dispatch_args->constant_count * sizeof(uint32_t), 8);
../../drivers/amdgpu/device/command_buffer.c:    implicit_args->block_count[0] = workgroup_count_ptr[0];
../../drivers/amdgpu/device/command_buffer.c:    implicit_args->block_count[1] = workgroup_count_ptr[1];
../../drivers/amdgpu/device/command_buffer.c:    implicit_args->block_count[2] = workgroup_count_ptr[2];
../../drivers/amdgpu/device/command_buffer.c:    implicit_args->group_size[0] = dispatch_args->workgroup_size[0];
../../drivers/amdgpu/device/command_buffer.c:    implicit_args->group_size[1] = dispatch_args->workgroup_size[1];
../../drivers/amdgpu/device/command_buffer.c:    implicit_args->group_size[2] = dispatch_args->workgroup_size[2];
../../drivers/amdgpu/device/command_buffer.c:    implicit_args->remainder[0] = 0;
../../drivers/amdgpu/device/command_buffer.c:    implicit_args->remainder[1] = 0;
../../drivers/amdgpu/device/command_buffer.c:    implicit_args->remainder[2] = 0;
../../drivers/amdgpu/device/command_buffer.c:    implicit_args->global_offset[0] = 0;
../../drivers/amdgpu/device/command_buffer.c:    implicit_args->global_offset[1] = 0;
../../drivers/amdgpu/device/command_buffer.c:    implicit_args->global_offset[2] = 0;
../../drivers/amdgpu/device/command_buffer.c:    implicit_args->grid_dims = 3;
../../drivers/amdgpu/device/command_buffer.c:    implicit_args->printf_buffer = NULL;
../../drivers/amdgpu/device/command_buffer.c:    implicit_args->hostcall_buffer = NULL;
../../drivers/amdgpu/device/command_buffer.c:    implicit_args->dynamic_lds_size = cmd->config.dynamic_lds_size;
../../drivers/amdgpu/device/command_buffer.c:  uint8_t* kernarg_ptr = state->execution_kernarg_storage + cmd->kernarg_offset;
../../drivers/amdgpu/device/command_buffer.c:      state, &cmd->header, packet,
../../drivers/amdgpu/device/command_buffer.c:      cmd->config.kernel_args->trace_src_loc, execution_query_id);
../../drivers/amdgpu/device/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.c:  // Read the uint32_t[3] workgroup count buffer and update the packet in-place.
../../drivers/amdgpu/device/command_buffer.c:  packet->grid_size[0] = workgroups_ptr[0] * packet->workgroup_size[0];
../../drivers/amdgpu/device/command_buffer.c:  packet->grid_size[1] = workgroups_ptr[1] * packet->workgroup_size[0];
../../drivers/amdgpu/device/command_buffer.c:  packet->grid_size[2] = workgroups_ptr[2] * packet->workgroup_size[0];
../../drivers/amdgpu/device/command_buffer.c:  if (cmd->header.flags & IREE_HAL_AMDGPU_DEVICE_DISPATCH_FLAG_IMPLICIT_ARGS) {
../../drivers/amdgpu/device/command_buffer.c:        cmd->config.kernel_args;
../../drivers/amdgpu/device/command_buffer.c:        (uint8_t*)packet->kernarg_address +
../../drivers/amdgpu/device/command_buffer.c:        dispatch_args->binding_count * sizeof(void*) +
../../drivers/amdgpu/device/command_buffer.c:        iree_amdgpu_align(dispatch_args->constant_count * sizeof(uint32_t), 8);
../../drivers/amdgpu/device/command_buffer.c:    implicit_args->block_count[0] = workgroups_ptr[0];
../../drivers/amdgpu/device/command_buffer.c:    implicit_args->block_count[1] = workgroups_ptr[1];
../../drivers/amdgpu/device/command_buffer.c:    implicit_args->block_count[2] = workgroups_ptr[2];
../../drivers/amdgpu/device/command_buffer.c:  // that - it _should_ be spinning on the packet.
../../drivers/amdgpu/device/command_buffer.c:      (packet->header &
../../drivers/amdgpu/device/command_buffer.c:  const uint32_t header_setup = header | (uint32_t)(packet->setup << 16);
../../drivers/amdgpu/device/command_buffer.c:      state->execution_kernarg_storage + cmd->kernarg_offset +
../../drivers/amdgpu/device/command_buffer.c:      state, &cmd->header, dispatch_packet,
../../drivers/amdgpu/device/command_buffer.c:      cmd->config.kernel_args->trace_src_loc, execution_query_id);
../../drivers/amdgpu/device/command_buffer.c:      (uint64_t*)(state->execution_kernarg_storage + cmd->kernarg_offset);
../../drivers/amdgpu/device/command_buffer.c:          cmd->config.workgroup_count.ref, state->bindings);
../../drivers/amdgpu/device/command_buffer.c:      state->kernels->iree_hal_amdgpu_device_cmd_dispatch_update;
../../drivers/amdgpu/device/command_buffer.c:  update_packet->setup = update_args.setup;
../../drivers/amdgpu/device/command_buffer.c:  update_packet->workgroup_size[0] = update_args.workgroup_size[0];
../../drivers/amdgpu/device/command_buffer.c:  update_packet->workgroup_size[1] = update_args.workgroup_size[1];
../../drivers/amdgpu/device/command_buffer.c:  update_packet->workgroup_size[2] = update_args.workgroup_size[2];
../../drivers/amdgpu/device/command_buffer.c:  update_packet->reserved0 = 0;
../../drivers/amdgpu/device/command_buffer.c:  update_packet->grid_size[0] = 1;
../../drivers/amdgpu/device/command_buffer.c:  update_packet->grid_size[1] = 1;
../../drivers/amdgpu/device/command_buffer.c:  update_packet->grid_size[2] = 1;
../../drivers/amdgpu/device/command_buffer.c:  update_packet->private_segment_size = update_args.private_segment_size;
../../drivers/amdgpu/device/command_buffer.c:  update_packet->group_segment_size = update_args.group_segment_size;
../../drivers/amdgpu/device/command_buffer.c:  update_packet->kernel_object = update_args.kernel_object;
../../drivers/amdgpu/device/command_buffer.c:  update_packet->kernarg_address = update_kernarg_ptr;
../../drivers/amdgpu/device/command_buffer.c:  update_packet->reserved2 = 0;
../../drivers/amdgpu/device/command_buffer.c:      state, &cmd->header, update_packet,
../../drivers/amdgpu/device/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.c:  state->block = next_block;
../../drivers/amdgpu/device/command_buffer.c:  // Rescheduling would allow for better QoS as older but newly-runnable entries
../../drivers/amdgpu/device/command_buffer.c:        state->scheduler, state->scheduler_queue_entry);
../../drivers/amdgpu/device/command_buffer.c:  // following block. The kernargs are stored in state->control_kernarg_storage
../../drivers/amdgpu/device/command_buffer.c:      (uint64_t*)(state->execution_kernarg_storage + cmd->kernarg_offset);
../../drivers/amdgpu/device/command_buffer.c:  kernarg_ptr[1] = (uint64_t)&state->command_buffer->blocks[cmd->target_block];
../../drivers/amdgpu/device/command_buffer.c:      state, &cmd->header, packet_id, execution_query_id,
../../drivers/amdgpu/device/command_buffer.c:      &state->kernels->iree_hal_amdgpu_device_cmd_branch, kernarg_ptr);
../../drivers/amdgpu/device/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.c:  state->block = next_block;
../../drivers/amdgpu/device/command_buffer.c:  // Rescheduling would allow for better QoS as older but newly-runnable entries
../../drivers/amdgpu/device/command_buffer.c:        state->scheduler, state->scheduler_queue_entry);
../../drivers/amdgpu/device/command_buffer.c:  // following block. The kernargs are stored in state->control_kernarg_storage
../../drivers/amdgpu/device/command_buffer.c:      (uint64_t*)(state->execution_kernarg_storage + cmd->kernarg_offset);
../../drivers/amdgpu/device/command_buffer.c:      cmd->ref, state->bindings);
../../drivers/amdgpu/device/command_buffer.c:  kernarg_ptr[2] = cmd->cond;
../../drivers/amdgpu/device/command_buffer.c:  kernarg_ptr[3] = cmd->value;
../../drivers/amdgpu/device/command_buffer.c:  kernarg_ptr[4] = (uint64_t)&state->command_buffer->blocks[cmd->true_block];
../../drivers/amdgpu/device/command_buffer.c:  kernarg_ptr[5] = (uint64_t)&state->command_buffer->blocks[cmd->false_block];
../../drivers/amdgpu/device/command_buffer.c:      state, &cmd->header, packet_id, execution_query_id,
../../drivers/amdgpu/device/command_buffer.c:      &state->kernels->iree_hal_amdgpu_device_cmd_cond_branch, kernarg_ptr);
../../drivers/amdgpu/device/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.c:  state->block = NULL;
../../drivers/amdgpu/device/command_buffer.c:      state->scheduler, state->scheduler_queue_entry);
../../drivers/amdgpu/device/command_buffer.c:      (uint64_t*)(state->execution_kernarg_storage + cmd->kernarg_offset);
../../drivers/amdgpu/device/command_buffer.c:      state, &cmd->header, packet_id, execution_query_id,
../../drivers/amdgpu/device/command_buffer.c:      &state->kernels->iree_hal_amdgpu_device_cmd_return, kernarg_ptr);
../../drivers/amdgpu/device/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/command_buffer.c:// (even if they are no-oped).
../../drivers/amdgpu/device/command_buffer.c:// provided with the per-command relative offset and performs the required queue
../../drivers/amdgpu/device/command_buffer.c:// write index to keep the window between nearly-populated packets (those who
../../drivers/amdgpu/device/command_buffer.c:// fully-populated packets (with INVALID transitioned to a packet type) as small
../../drivers/amdgpu/device/command_buffer.c:// need that here (device->device) it does close off some design space we may
../../drivers/amdgpu/device/command_buffer.c:  if (command_ordinal >= block->command_count) return;
../../drivers/amdgpu/device/command_buffer.c:// NOTE: this should be tail-called to avoid non-trivial stack management
../../drivers/amdgpu/device/command_buffer.c:// correctly tail-calling such that LLVM can recognize it can easily double
../../drivers/amdgpu/device/command_buffer.c:  // state->trace_block_query_base_id. Here we then take that base ID and add a
../../drivers/amdgpu/device/command_buffer.c:  // There's probably a much simpler way of doing this - not needing all this
../../drivers/amdgpu/device/command_buffer.c:      block->query_map.query_ids[command_ordinal];
../../drivers/amdgpu/device/command_buffer.c:  if ((state->flags & IREE_HAL_AMDGPU_DEVICE_EXECUTION_FLAG_TRACE_DISPATCH) &&
../../drivers/amdgpu/device/command_buffer.c:        &state->trace_buffer->query_ringbuffer,
../../drivers/amdgpu/device/command_buffer.c:        state->trace_block_query_base_id + command_query_id.dispatch_id);
../../drivers/amdgpu/device/command_buffer.c:  } else if ((state->flags &
../../drivers/amdgpu/device/command_buffer.c:        &state->trace_buffer->query_ringbuffer,
../../drivers/amdgpu/device/command_buffer.c:        state->trace_block_query_base_id + command_query_id.control_id);
../../drivers/amdgpu/device/command_buffer.c:  // Tail-call into the command handler.
../../drivers/amdgpu/device/command_buffer.c:      &block->commands[command_ordinal];
../../drivers/amdgpu/device/command_buffer.c:  const uint64_t packet_id = base_packet_id + cmd->header.packet_offset;
../../drivers/amdgpu/device/command_buffer.c:  switch (cmd->header.type) {
../../drivers/amdgpu/device/command_buffer.c:      return;  // no-op
../../drivers/vulkan/registration/BUILD.bazel:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/logical_device.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/logical_device.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/logical_device.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/logical_device.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/logical_device.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/logical_device.c:// Power-of-two size for the shared host small block pool in bytes.
../../drivers/amdgpu/logical_device.c:// Used for small host-side transients/wrappers of device-side resources.
../../drivers/amdgpu/logical_device.c:// Power-of-two size for the shared host large block pool in bytes.
../../drivers/amdgpu/logical_device.c:  out_options->host_block_pools.small.block_size =
../../drivers/amdgpu/logical_device.c:  out_options->host_block_pools.large.block_size =
../../drivers/amdgpu/logical_device.c:  out_options->device_block_pools.small.block_size =
../../drivers/amdgpu/logical_device.c:  out_options->device_block_pools.small.initial_capacity =
../../drivers/amdgpu/logical_device.c:  out_options->device_block_pools.large.block_size =
../../drivers/amdgpu/logical_device.c:  out_options->device_block_pools.large.initial_capacity =
../../drivers/amdgpu/logical_device.c:  out_options->queue_placement = IREE_HAL_AMDGPU_QUEUE_PLACEMENT_ANY;
../../drivers/amdgpu/logical_device.c:  out_options->preallocate_pools = 1;
../../drivers/amdgpu/logical_device.c:  if (!params.count) return iree_ok_status();  // no-op
../../drivers/amdgpu/logical_device.c:  if (options->host_block_pools.small.block_size <
../../drivers/amdgpu/logical_device.c:          options->host_block_pools.small.block_size)) {
../../drivers/amdgpu/logical_device.c:        "power-of-two greater than %d and got %" PRIhsz,
../../drivers/amdgpu/logical_device.c:        options->host_block_pools.small.block_size);
../../drivers/amdgpu/logical_device.c:  if (options->host_block_pools.large.block_size <
../../drivers/amdgpu/logical_device.c:          options->host_block_pools.large.block_size)) {
../../drivers/amdgpu/logical_device.c:        "power-of-two greater than %d and got %" PRIhsz,
../../drivers/amdgpu/logical_device.c:        options->host_block_pools.large.block_size);
../../drivers/amdgpu/logical_device.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/logical_device.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/logical_device.c:          &logical_device->failure_status, &current_value, (intptr_t)status,
../../drivers/amdgpu/logical_device.c:  // churn for too little benefit - option parsing is still possible, though.
../../drivers/amdgpu/logical_device.c:      options->device_block_pools.small.block_size;
../../drivers/amdgpu/logical_device.c:      options->device_block_pools.small.initial_capacity;
../../drivers/amdgpu/logical_device.c:      options->device_block_pools.large.block_size;
../../drivers/amdgpu/logical_device.c:      options->device_block_pools.large.initial_capacity;
../../drivers/amdgpu/logical_device.c:      options->preallocate_pools ? 16 : 0;
../../drivers/amdgpu/logical_device.c:  physical_device_options.queue_count = topology->gpu_agent_queue_count;
../../drivers/amdgpu/logical_device.c:  if (options->trace_execution) {
../../drivers/amdgpu/logical_device.c:  if (options->exclusive_execution) {
../../drivers/amdgpu/logical_device.c:  // peer communication as though a CPU<->GPU may be able to communicate OK a
../../drivers/amdgpu/logical_device.c:  // GPU<->GPU pair may not be able to.
../../drivers/amdgpu/logical_device.c:  IREE_ASSERT_LE(topology->gpu_agent_count, 128);
../../drivers/amdgpu/logical_device.c:          topology->gpu_agent_count *
../../drivers/amdgpu/logical_device.c:  for (iree_host_size_t i = 0; i < topology->gpu_agent_count; ++i) {
../../drivers/amdgpu/logical_device.c:    switch (options->queue_placement) {
../../drivers/amdgpu/logical_device.c:        hsa_agent_t cpu_agent = topology->cpu_agents[topology->gpu_cpu_map[i]];
../../drivers/amdgpu/logical_device.c:        hsa_agent_t gpu_agent = topology->gpu_agents[i];
../../drivers/amdgpu/logical_device.c:        gpu_agent_queue_placement[i] = options->queue_placement;
../../drivers/amdgpu/logical_device.c:  for (iree_host_size_t i = 0; i < topology->gpu_agent_count; ++i) {
../../drivers/amdgpu/logical_device.c:    hsa_agent_t gpu_agent = topology->gpu_agents[i];
../../drivers/amdgpu/logical_device.c:    hsa_agent_t cpu_agent = topology->cpu_agents[topology->gpu_cpu_map[i]];
../../drivers/amdgpu/logical_device.c:      iree_host_align(sizeof(logical_device->physical_devices[0]) *
../../drivers/amdgpu/logical_device.c:                          topology->gpu_agent_count,
../../drivers/amdgpu/logical_device.c:                               &logical_device->resource);
../../drivers/amdgpu/logical_device.c:      identifier, &logical_device->identifier,
../../drivers/amdgpu/logical_device.c:      (char*)logical_device + total_size - identifier.size);
../../drivers/amdgpu/logical_device.c:  logical_device->host_allocator = host_allocator;
../../drivers/amdgpu/logical_device.c:  logical_device->failure_status = IREE_ATOMIC_VAR_INIT(0);
../../drivers/amdgpu/logical_device.c:  logical_device->physical_device_count = topology->gpu_agent_count;
../../drivers/amdgpu/logical_device.c:      iree_host_align(sizeof(logical_device->physical_devices[0]) *
../../drivers/amdgpu/logical_device.c:                          topology->gpu_agent_count,
../../drivers/amdgpu/logical_device.c:       i < logical_device->physical_device_count; ++i) {
../../drivers/amdgpu/logical_device.c:    logical_device->physical_devices[i] =
../../drivers/amdgpu/logical_device.c:    for (iree_host_size_t j = 0; j < topology->gpu_agent_queue_count;
../../drivers/amdgpu/logical_device.c:      iree_hal_queue_affinity_or_into(logical_device->queue_affinity_mask,
../../drivers/amdgpu/logical_device.c:  iree_arena_block_pool_initialize(options->host_block_pools.small.block_size,
../../drivers/amdgpu/logical_device.c:                                   &logical_device->host_block_pools.small);
../../drivers/amdgpu/logical_device.c:  iree_arena_block_pool_initialize(options->host_block_pools.large.block_size,
../../drivers/amdgpu/logical_device.c:                                   &logical_device->host_block_pools.large);
../../drivers/amdgpu/logical_device.c:  // fixed per-agent resources like the device library.
../../drivers/amdgpu/logical_device.c:      .trace_execution = options->trace_execution,
../../drivers/amdgpu/logical_device.c:      .exclusive_execution = options->exclusive_execution,
../../drivers/amdgpu/logical_device.c:                                      host_allocator, &logical_device->system);
../../drivers/amdgpu/logical_device.c:  iree_hal_amdgpu_system_t* system = logical_device->system;
../../drivers/amdgpu/logical_device.c:        IREE_LIBHSA(&system->libhsa), 0ull, topology->all_agent_count,
../../drivers/amdgpu/logical_device.c:        topology->all_agents, 0, &initialization_signal);
../../drivers/amdgpu/logical_device.c:  //       host_allocator, &logical_device->device_allocator);
../../drivers/amdgpu/logical_device.c:        .wait_active_for_ns = options->wait_active_for_ns,
../../drivers/amdgpu/logical_device.c:        &system->libhsa, &system->topology,
../../drivers/amdgpu/logical_device.c:        system->host_memory_pools[0].fine_pool,
../../drivers/amdgpu/logical_device.c:        &logical_device->semaphore_pool);
../../drivers/amdgpu/logical_device.c:        &system->libhsa, &system->topology, placement,
../../drivers/amdgpu/logical_device.c:        system->host_memory_pools[0].fine_pool, &logical_device->buffer_pool);
../../drivers/amdgpu/logical_device.c:         device_ordinal < logical_device->physical_device_count;
../../drivers/amdgpu/logical_device.c:          topology->gpu_cpu_map[device_ordinal];
../../drivers/amdgpu/logical_device.c:          &system->host_memory_pools[host_ordinal], device_ordinal,
../../drivers/amdgpu/logical_device.c:          &logical_device->buffer_pool, error_callback, initialization_signal,
../../drivers/amdgpu/logical_device.c:          host_allocator, logical_device->physical_devices[device_ordinal]);
../../drivers/amdgpu/logical_device.c:  // that's ok - users can warmup if they want.
../../drivers/amdgpu/logical_device.c:  if (options->preallocate_pools) {
../../drivers/amdgpu/logical_device.c:          &logical_device->host_block_pools.small, 16);
../../drivers/amdgpu/logical_device.c:          &logical_device->host_block_pools.large, 16);
../../drivers/amdgpu/logical_device.c:          &logical_device->semaphore_pool, 256);
../../drivers/amdgpu/logical_device.c:          &logical_device->buffer_pool, 256);
../../drivers/amdgpu/logical_device.c:  for (iree_host_size_t i = 0; i < logical_device->physical_device_count; ++i) {
../../drivers/amdgpu/logical_device.c:        logical_device->physical_devices[i]);
../../drivers/amdgpu/logical_device.c:  iree_hal_amdgpu_buffer_pool_deinitialize(&logical_device->buffer_pool);
../../drivers/amdgpu/logical_device.c:  iree_hal_amdgpu_semaphore_pool_deinitialize(&logical_device->semaphore_pool);
../../drivers/amdgpu/logical_device.c:  iree_hal_allocator_release(logical_device->device_allocator);
../../drivers/amdgpu/logical_device.c:  iree_hal_channel_provider_release(logical_device->channel_provider);
../../drivers/amdgpu/logical_device.c:  iree_hal_amdgpu_system_free(logical_device->system);
../../drivers/amdgpu/logical_device.c:  iree_arena_block_pool_deinitialize(&logical_device->host_block_pools.small);
../../drivers/amdgpu/logical_device.c:  iree_arena_block_pool_deinitialize(&logical_device->host_block_pools.large);
../../drivers/amdgpu/logical_device.c:  return logical_device->identifier;
../../drivers/amdgpu/logical_device.c:  return logical_device->host_allocator;
../../drivers/amdgpu/logical_device.c:  return logical_device->device_allocator;
../../drivers/amdgpu/logical_device.c:  iree_hal_allocator_release(logical_device->device_allocator);
../../drivers/amdgpu/logical_device.c:  logical_device->device_allocator = new_allocator;
../../drivers/amdgpu/logical_device.c:  iree_hal_channel_provider_release(logical_device->channel_provider);
../../drivers/amdgpu/logical_device.c:  logical_device->channel_provider = new_provider;
../../drivers/amdgpu/logical_device.c:  for (iree_host_size_t i = 0; i < logical_device->physical_device_count; ++i) {
../../drivers/amdgpu/logical_device.c:    iree_hal_amdgpu_physical_device_trim(logical_device->physical_devices[i]);
../../drivers/amdgpu/logical_device.c:  iree_hal_amdgpu_buffer_pool_trim(&logical_device->buffer_pool);
../../drivers/amdgpu/logical_device.c:  iree_hal_amdgpu_semaphore_pool_trim(&logical_device->semaphore_pool);
../../drivers/amdgpu/logical_device.c:      iree_hal_allocator_trim(logical_device->device_allocator));
../../drivers/amdgpu/logical_device.c:  iree_arena_block_pool_trim(&logical_device->host_block_pools.small);
../../drivers/amdgpu/logical_device.c:  iree_arena_block_pool_trim(&logical_device->host_block_pools.large);
../../drivers/amdgpu/logical_device.c:        iree_string_view_match_pattern(logical_device->identifier, key) ? 1 : 0;
../../drivers/amdgpu/logical_device.c:  iree_hal_amdgpu_system_t* system = logical_device->system;
../../drivers/amdgpu/logical_device.c:        &system->libhsa, system->topology.gpu_agents[0], key, &is_supported,
../../drivers/amdgpu/logical_device.c:      *out_value = system->topology.gpu_agent_count *
../../drivers/amdgpu/logical_device.c:                   system->topology.gpu_agent_queue_count;
../../drivers/amdgpu/logical_device.c:          IREE_LIBHSA(&system->libhsa), system->topology.gpu_agents[0],
../../drivers/amdgpu/logical_device.c:  // Mask the user-provided queue affinity to only those we have.
../../drivers/amdgpu/logical_device.c:                                   logical_device->queue_affinity_mask);
../../drivers/amdgpu/logical_device.c:  // channel. The device->channel_provider can be used to get default
../../drivers/amdgpu/logical_device.c:  // Mask the user-provided queue affinity to only those we have.
../../drivers/amdgpu/logical_device.c:                                   logical_device->queue_affinity_mask);
../../drivers/amdgpu/logical_device.c:          logical_device->system->topology.gpu_agent_queue_count);
../../drivers/amdgpu/logical_device.c:  // to reuse allocations when command buffers are short-lived.
../../drivers/amdgpu/logical_device.c:  options.host_block_pools = &logical_device->host_block_pools;
../../drivers/amdgpu/logical_device.c:  // Gather block pools for all of the physical devices - the command buffer
../../drivers/amdgpu/logical_device.c:        logical_device->physical_devices[device_ordinal];
../../drivers/amdgpu/logical_device.c:    device_block_pools[device_index] = &physical_device->coarse_block_pools;
../../drivers/amdgpu/logical_device.c:      &options, logical_device->host_allocator, out_command_buffer);
../../drivers/amdgpu/logical_device.c:  // Mask the user-provided queue affinity to only those we have.
../../drivers/amdgpu/logical_device.c:                                   logical_device->queue_affinity_mask);
../../drivers/amdgpu/logical_device.c:      &logical_device->system->libhsa, &logical_device->system->topology,
../../drivers/amdgpu/logical_device.c:  // Mask the user-provided queue affinity to only those we have.
../../drivers/amdgpu/logical_device.c:                                   logical_device->queue_affinity_mask);
../../drivers/amdgpu/logical_device.c:      &logical_device->semaphore_pool, initial_value, flags, out_semaphore);
../../drivers/amdgpu/logical_device.c:// first-set will handle most cases the compiler generates beyond the
../../drivers/amdgpu/logical_device.c:  // Mask the user-provided queue affinity to only those we have.
../../drivers/amdgpu/logical_device.c:                                   logical_device->queue_affinity_mask);
../../drivers/amdgpu/logical_device.c:      logical_device->system->topology.gpu_agent_queue_count;
../../drivers/amdgpu/logical_device.c:  *out_queue = logical_device->physical_devices[physical_device_ordinal]
../../drivers/amdgpu/logical_device.c:                   ->queues[physical_queue_ordinal];
../../drivers/amdgpu/logical_device.c:  return queue->vtable->alloca(queue, wait_semaphore_list,
../../drivers/amdgpu/logical_device.c:  return queue->vtable->dealloca(queue, wait_semaphore_list,
../../drivers/amdgpu/logical_device.c:          "pattern length must be 1, 2, 4, or 8 - got %" PRIhsz,
../../drivers/amdgpu/logical_device.c:  return queue->vtable->fill(queue, wait_semaphore_list, signal_semaphore_list,
../../drivers/amdgpu/logical_device.c:  return queue->vtable->update(
../../drivers/amdgpu/logical_device.c:  return queue->vtable->copy(queue, wait_semaphore_list, signal_semaphore_list,
../../drivers/amdgpu/logical_device.c:  if (queue->vtable->read) {
../../drivers/amdgpu/logical_device.c:    return queue->vtable->read(
../../drivers/amdgpu/logical_device.c:                                   logical_device->queue_affinity_mask);
../../drivers/amdgpu/logical_device.c:  if (queue->vtable->read) {
../../drivers/amdgpu/logical_device.c:    return queue->vtable->write(
../../drivers/amdgpu/logical_device.c:                                   logical_device->queue_affinity_mask);
../../drivers/amdgpu/logical_device.c:  return queue->vtable->execute(queue, wait_semaphore_list,
../../drivers/amdgpu/logical_device.c:  return queue->vtable->flush(queue);
../../drivers/amdgpu/logical_device.c:  return iree_hal_amdgpu_wait_semaphores(&logical_device->system->libhsa,
../../drivers/amdgpu/logical_device.c:                                         logical_device->semaphore_pool.options,
../../drivers/vulkan/registration/driver_module.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/registration/driver_module.cc:          "SPIR-V executables compiled to use it.");
../../drivers/vulkan/registration/driver_module.cc:// TODO(benvanik): make this a flag - it's useful for testing the same binary
../../drivers/vulkan/handle_util.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/handle_util.h:// Vulkan usage mostly functional and C-like to ensure minimal code size and
../../drivers/vulkan/handle_util.h:// clang-format off: must be included before all other headers.
../../drivers/vulkan/handle_util.h:// clang-format on
../../drivers/vulkan/handle_util.h:      syms_->vkDestroyDevice(value_, allocator_);
../../drivers/vulkan/handle_util.h:    syms()->vkDestroyCommandPool(*logical_device_, value_, allocator());
../../drivers/vulkan/handle_util.h:    return logical_device_->syms();
../../drivers/vulkan/handle_util.h:    return logical_device_->allocator();
../../drivers/vulkan/handle_util.h:        VK_RESULT_TO_STATUS(syms()->vkAllocateCommandBuffers(
../../drivers/vulkan/handle_util.h:    syms()->vkFreeCommandBuffers(*logical_device_, value_, 1, &handle);
../../drivers/amdgpu/executable.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/executable.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/executable.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/executable.h:// reported by HSA, e.g. `amdgcn-amd-amdhsa--gfx1100`. It's not pretty, but it
../../drivers/amdgpu/executable.h:// changes if LLVM<->HSA naming changes with new code object versions.
../../drivers/amdgpu/executable.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/executable.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/executable.h:// The maximum number of per-dispatch bindings allowed.
../../drivers/amdgpu/executable.h:// The maximum number of per-dispatch constants allowed.
../../drivers/amdgpu/executable.h:// |libhsa| and |topology| are captured by-reference and must remain valid for
../../drivers/amdgpu/executable.h:// is no host representation and objects are per agent. To get an agent-specific
../../drivers/amdgpu/device/buffer.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/device/buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/buffer.c:// TODO(benvanik): simplify this for command buffers by pre-baking as much as we
../../drivers/amdgpu/device/buffer.c:// can during the queue issue - we can at least dereference handles and add in
../../drivers/amdgpu/device/buffer.c:                                ? buffer_ref.length - offset
../../drivers/amdgpu/device/buffer.c:    buffer_ref.value.ptr = buffer_ref.value.handle->ptr;
../../drivers/amdgpu/device/buffer.c:    buffer_ref.value.ptr = buffer_ref.value.handle->ptr;
../../drivers/amdgpu/device/buffer.c:    buffer_ref.value.ptr = buffer_ref.value.handle->ptr;
../../drivers/amdgpu/driver.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/driver.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/driver.h://===----------------------------------------------------------------------===//
../../drivers/vulkan/tracing.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/tracing.cc:// Total number of queries the per-queue query pool will contain. This
../../drivers/vulkan/tracing.cc:// The more we do the better confidence we have in a lower-bound.
../../drivers/vulkan/tracing.cc:  uint64_t availability;  // non-zero if available
../../drivers/vulkan/tracing.cc:  // Defines how the timestamps are interpreted (device-specific, posix, QPC).
../../drivers/vulkan/tracing.cc:  // https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkTimeDomainEXT.html
../../drivers/vulkan/tracing.cc:  // Vulkan-reported CPU timestamp of the last calibration.
../../drivers/vulkan/tracing.cc:  // Availability will be non-zero if the timestamp is valid. Since we put all
../../drivers/vulkan/tracing.cc:  const auto& syms = context->logical_device->syms();
../../drivers/vulkan/tracing.cc:  command_buffer_info.commandPool = *context->maintenance_command_pool;
../../drivers/vulkan/tracing.cc:  IREE_IGNORE_ERROR(context->maintenance_command_pool->Allocate(
../../drivers/vulkan/tracing.cc:  syms->vkBeginCommandBuffer(command_buffer, &begin_info);
../../drivers/vulkan/tracing.cc:  const auto& syms = context->logical_device->syms();
../../drivers/vulkan/tracing.cc:  syms->vkEndCommandBuffer(command_buffer);
../../drivers/vulkan/tracing.cc:  syms->vkQueueSubmit(context->maintenance_dispatch_queue, 1, &submit_info,
../../drivers/vulkan/tracing.cc:  syms->vkQueueWaitIdle(context->maintenance_dispatch_queue);
../../drivers/vulkan/tracing.cc:  context->maintenance_command_pool->Free(command_buffer);
../../drivers/vulkan/tracing.cc:  const auto& syms = context->logical_device->syms();
../../drivers/vulkan/tracing.cc:  // Fast-path for when host-side vkResetQueryPool is available.
../../drivers/vulkan/tracing.cc:  if (context->logical_device->enabled_extensions().host_query_reset) {
../../drivers/vulkan/tracing.cc:    PFN_vkResetQueryPool vkResetQueryPool_fn = syms->vkResetQueryPool
../../drivers/vulkan/tracing.cc:                                                   ? syms->vkResetQueryPool
../../drivers/vulkan/tracing.cc:                                                   : syms->vkResetQueryPoolEXT;
../../drivers/vulkan/tracing.cc:      vkResetQueryPool_fn(*context->logical_device, context->query_pool,
../../drivers/vulkan/tracing.cc:  // Slow-path submitting a command buffer to reset the query pool. It's obvious
../../drivers/vulkan/tracing.cc:    syms->vkCmdResetQueryPool(command_buffer, context->query_pool, query_index,
../../drivers/vulkan/tracing.cc:  timestamp_infos[1].timeDomain = context->time_domain;
../../drivers/vulkan/tracing.cc:    context->logical_device->syms()->vkGetCalibratedTimestampsEXT(
../../drivers/vulkan/tracing.cc:        *context->logical_device, IREE_ARRAYSIZE(timestamps), timestamp_infos,
../../drivers/vulkan/tracing.cc:  } while (max_deviation > context->max_expected_deviation);
../../drivers/vulkan/tracing.cc:  switch (context->time_domain) {
../../drivers/vulkan/tracing.cc:      // TODO(benvanik): posix calibrated timestamps - ignored for now.
../../drivers/vulkan/tracing.cc:  const auto& syms = context->logical_device->syms();
../../drivers/vulkan/tracing.cc:                              context->time_domain == VK_TIME_DOMAIN_DEVICE_EXT
../../drivers/vulkan/tracing.cc:  if (context->time_domain == VK_TIME_DOMAIN_DEVICE_EXT) {
../../drivers/vulkan/tracing.cc:      syms->vkCmdWriteTimestamp(command_buffer,
../../drivers/vulkan/tracing.cc:                                context->query_pool, 0);
../../drivers/vulkan/tracing.cc:    syms->vkGetQueryPoolResults(
../../drivers/vulkan/tracing.cc:        *context->logical_device, context->query_pool, 0, 1,
../../drivers/vulkan/tracing.cc:  // re-issue the timestamp calibration call pursuing a lower devation value.
../../drivers/vulkan/tracing.cc:  // https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/vkGetCalibratedTimestampsEXT.html
../../drivers/vulkan/tracing.cc:  timestamp_infos[1].timeDomain = context->time_domain;
../../drivers/vulkan/tracing.cc:    syms->vkGetCalibratedTimestampsEXT(
../../drivers/vulkan/tracing.cc:        *context->logical_device, IREE_ARRAYSIZE(timestamps), timestamp_infos,
../../drivers/vulkan/tracing.cc:  context->max_expected_deviation = min_deviation * 3 / 2;
../../drivers/vulkan/tracing.cc:      context, &context->previous_cpu_time, out_gpu_time);
../../drivers/vulkan/tracing.cc:  if (context->time_domain == VK_TIME_DOMAIN_DEVICE_EXT) return;
../../drivers/vulkan/tracing.cc:  if (cpu_time > context->previous_cpu_time) {
../../drivers/vulkan/tracing.cc:    uint64_t cpu_delta = cpu_time - context->previous_cpu_time;
../../drivers/vulkan/tracing.cc:    context->previous_cpu_time = cpu_time;
../../drivers/vulkan/tracing.cc:    iree_tracing_gpu_context_calibrate(context->id, cpu_delta, tracy_time,
../../drivers/vulkan/tracing.cc:  while (context->logical_device->syms()->vkCreateQueryPool(
../../drivers/vulkan/tracing.cc:             *context->logical_device, &pool_info,
../../drivers/vulkan/tracing.cc:             context->logical_device->allocator(),
../../drivers/vulkan/tracing.cc:             &context->query_pool) != VK_SUCCESS) {
../../drivers/vulkan/tracing.cc:  context->query_capacity = pool_info.queryCount;
../../drivers/vulkan/tracing.cc:  iree_hal_vulkan_tracing_reset_query_pool(context, 0, context->query_capacity);
../../drivers/vulkan/tracing.cc:// Prepares the Tracy-related GPU context that events are fed into. Each context
../../drivers/vulkan/tracing.cc:  context->logical_device->syms()->vkGetPhysicalDeviceProperties(
../../drivers/vulkan/tracing.cc:  bool is_calibrated = context->time_domain == VK_TIME_DOMAIN_DEVICE_EXT;
../../drivers/vulkan/tracing.cc:  context->id = iree_tracing_gpu_context_allocate(
../../drivers/vulkan/tracing.cc:// Returns the best possible platform-supported time domain, falling back to
../../drivers/vulkan/tracing.cc:// device-relative calculations and that we need to perform our own hacky
../../drivers/vulkan/tracing.cc:  if (!logical_device->enabled_extensions().calibrated_timestamps) {
../../drivers/vulkan/tracing.cc:  if (logical_device->syms()->vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(
../../drivers/vulkan/tracing.cc:  if (logical_device->syms()->vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(
../../drivers/vulkan/tracing.cc:        // return time_domains[i];  -- ignored
../../drivers/vulkan/tracing.cc:    context->logical_device = logical_device;
../../drivers/vulkan/tracing.cc:    context->queue = queue;
../../drivers/vulkan/tracing.cc:    context->host_allocator = host_allocator;
../../drivers/vulkan/tracing.cc:    context->time_domain = iree_hal_vulkan_tracing_query_time_domain(
../../drivers/vulkan/tracing.cc:    context->maintenance_dispatch_queue = maintenance_dispatch_queue;
../../drivers/vulkan/tracing.cc:    context->maintenance_command_pool = maintenance_command_pool;
../../drivers/vulkan/tracing.cc:  if (context->query_pool != VK_NULL_HANDLE) {
../../drivers/vulkan/tracing.cc:    auto* logical_device = context->logical_device;
../../drivers/vulkan/tracing.cc:    logical_device->syms()->vkDestroyQueryPool(
../../drivers/vulkan/tracing.cc:        *logical_device, context->query_pool, logical_device->allocator());
../../drivers/vulkan/tracing.cc:  iree_allocator_t host_allocator = context->host_allocator;
../../drivers/vulkan/tracing.cc:  uint32_t id = context->query_head;
../../drivers/vulkan/tracing.cc:  context->query_head = (context->query_head + 1) % context->query_capacity;
../../drivers/vulkan/tracing.cc:  assert(context->query_head != context->query_tail);
../../drivers/vulkan/tracing.cc:  if (context->query_tail == context->query_head) {
../../drivers/vulkan/tracing.cc:  const auto& syms = context->logical_device->syms();
../../drivers/vulkan/tracing.cc:  while (context->query_tail != context->query_head) {
../../drivers/vulkan/tracing.cc:        context->query_head < context->query_tail
../../drivers/vulkan/tracing.cc:            ? context->query_capacity - context->query_tail
../../drivers/vulkan/tracing.cc:            : context->query_head - context->query_tail;
../../drivers/vulkan/tracing.cc:    uint32_t query_base = context->query_tail;
../../drivers/vulkan/tracing.cc:    if (syms->vkGetQueryPoolResults(
../../drivers/vulkan/tracing.cc:            *context->logical_device, context->query_pool, query_base,
../../drivers/vulkan/tracing.cc:            try_query_count, sizeof(context->readback_buffer),
../../drivers/vulkan/tracing.cc:            context->readback_buffer, sizeof(iree_hal_vulkan_timestamp_query_t),
../../drivers/vulkan/tracing.cc:      if (context->readback_buffer[i].availability == 0) break;
../../drivers/vulkan/tracing.cc:      iree_tracing_gpu_zone_notify(context->id, (uint16_t)(query_base + i),
../../drivers/vulkan/tracing.cc:                                   context->readback_buffer[i].timestamp);
../../drivers/vulkan/tracing.cc:      syms->vkCmdResetQueryPool(command_buffer, context->query_pool, query_base,
../../drivers/vulkan/tracing.cc:    context->query_tail += read_query_count;
../../drivers/vulkan/tracing.cc:    if (context->query_tail >= context->query_capacity) {
../../drivers/vulkan/tracing.cc:      context->query_tail = 0;
../../drivers/vulkan/tracing.cc:  // Run calibration - we could do this less frequently in cases where collect
../../drivers/vulkan/tracing.cc:  context->logical_device->syms()->vkCmdWriteTimestamp(
../../drivers/vulkan/tracing.cc:      command_buffer, VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT, context->query_pool,
../../drivers/vulkan/tracing.cc:  iree_tracing_gpu_zone_begin(context->id, (uint16_t)query_id, src_loc);
../../drivers/vulkan/tracing.cc:  context->logical_device->syms()->vkCmdWriteTimestamp(
../../drivers/vulkan/tracing.cc:      command_buffer, VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT, context->query_pool,
../../drivers/vulkan/tracing.cc:      context->id, (uint16_t)query_id, file_name, file_name_length, line,
../../drivers/vulkan/tracing.cc:  context->logical_device->syms()->vkCmdWriteTimestamp(
../../drivers/vulkan/tracing.cc:      command_buffer, VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT, context->query_pool,
../../drivers/vulkan/tracing.cc:  iree_tracing_gpu_zone_end(context->id, (uint16_t)query_id);
../../drivers/vulkan/native_allocator.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/native_allocator.h:// Creates a native Vulkan API-based allocator that directly allocates memory
../../drivers/amdgpu/channel.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/channel.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/channel.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/event.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/event.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/event.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/semaphore.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/semaphore.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/semaphore.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/semaphore.h:// Returns a no-op release callback that implies that no cleanup is required.
../../drivers/amdgpu/semaphore.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/semaphore.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/semaphore.h:// An internally-tracked HAL semaphore.
../../drivers/amdgpu/semaphore.h:// wait/wake behavior and allow device-side wait/wake.
../../drivers/amdgpu/semaphore.h:  // Device-visible semaphore in shared host/device memory.
../../drivers/amdgpu/semaphore.h:// Initializes an internal semaphore in-place with a 0 ref count.
../../drivers/amdgpu/semaphore.h:// Deinitializes an internal semaphore in-place assuming it has a 0 ref count.
../../drivers/amdgpu/semaphore.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/semaphore.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/semaphore.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/semaphore.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/semaphore.h:// Returns a device-side semaphore handle for the provided HAL semaphore.
../../drivers/amdgpu/semaphore.h:// Fails if there is no corresponding device-side handle (such as with a
../../drivers/amdgpu/device/kernel_tables.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/device/kernel_tables.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/kernel_tables.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/kernel_tables.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/kernel_tables.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/kernel_tables.h:// paths per command and can benefit from thread-level parallelism.
../../drivers/amdgpu/device/kernel_tables.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/kernel_tables.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/kernel_tables.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/kernel_tables.h://===----------------------------------------------------------------------===//
../../drivers/vulkan/BUILD.bazel:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/BUILD.bazel:# HAL implementation using Vulkan and (likely) SPIR-V executables.
../../drivers/vulkan/native_event.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/device/host_client.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/device/host_client.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/host_client.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/host_client.h:  // be of any device in the system - not just AMDGPU semaphores.
../../drivers/amdgpu/device/host_client.h:  // Host will call iree_hal_resource_release on each non-NULL resource pointer.
../../drivers/amdgpu/device/host_client.h:// need to identify the scheduler or scheduler-related resources must pass those
../../drivers/amdgpu/device/host_client.h:  // Host soft-queue processing device requests. May be servicing requests from
../../drivers/amdgpu/device/host_client.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/host_client.h:// Device-side Enqueuing
../../drivers/amdgpu/device/host_client.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/host_client.h:// Since this is device->host only operation this only uses an acquire scope
../../drivers/amdgpu/device/host_client.h:// eagerly processed. Maybe. For non-post operations we'd rely on queue barrier
../../drivers/amdgpu/device/host_client.h:// Posts a multi-resource release request to the host.
../../drivers/amdgpu/device/host_client.h:// The host will call iree_hal_resource_release on each non-NULL resource
../../drivers/vulkan/direct_command_buffer.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/pipeline_layout.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/pipeline_layout.h:// clang-format off: must be included before all other headers.
../../drivers/vulkan/pipeline_layout.h:// clang-format on
../../drivers/vulkan/pipeline_layout.h://===----------------------------------------------------------------------===//
../../drivers/vulkan/pipeline_layout.h://===----------------------------------------------------------------------===//
../../drivers/vulkan/pipeline_layout.h://===----------------------------------------------------------------------===//
../../drivers/vulkan/pipeline_layout.h://===----------------------------------------------------------------------===//
../../drivers/vulkan/pipeline_layout.h:// Creates a VkPipelineLayout-based pipeline layout composed of one or more
../../drivers/amdgpu/api.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/api.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/api.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/api.h:  // Enables dispatch-level tracing (if device instrumentation is compiled in).
../../drivers/amdgpu/api.h:  // aggressively scheduling queue entries out-of-order.
../../drivers/amdgpu/api.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/api.h://===----------------------------------------------------------------------===//
../../drivers/vulkan/cts/CMakeLists.txt:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/cts/CMakeLists.txt:  "--gtest_filter=-${FILTER_TESTS}"
../../drivers/vulkan/cts/CMakeLists.txt:    "vulkan-spirv"
../../drivers/vulkan/cts/CMakeLists.txt:    "\"vulkan-spirv-fb\""
../../drivers/amdgpu/device/support/kernel_args.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/device/support/kernel_args.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/support/kernel_args.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/support/kernel_args.h:// Kernel arguments used for fixed-size kernels.
../../drivers/amdgpu/device/support/kernel_args.h:  // XYZ dimensions of work-group, in work-items. Must be greater than 0.
../../drivers/amdgpu/device/support/kernel_args.h:  // Size in bytes of private memory allocation request (per work-item).
../../drivers/amdgpu/device/support/kernel_args.h:  // Size in bytes of group memory allocation request (per work-group). Must
../../drivers/amdgpu/device/support/kernel_args.h:  // Total number of 4-byte constants used by the dispatch (if a HAL dispatch).
../../drivers/amdgpu/device/support/common.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/device/support/common.h:// https://github.com/ROCm/rocMLIR/blob/develop/external/llvm-project/amd/device-libs/README.md
../../drivers/amdgpu/device/support/common.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/support/common.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/support/common.h:#include "third_party/hsa-runtime-headers/include/hsa/hsa.h"  // IWYU pragma: export
../../drivers/amdgpu/device/support/common.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/support/common.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/support/common.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/support/common.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/support/common.h:#define IREE_AMDGPU_CEIL_DIV(lhs, rhs) (((lhs) + (rhs) - 1) / (rhs))
../../drivers/amdgpu/device/support/common.h:// Aligns |value| up to the given power-of-two |alignment| if required.
../../drivers/amdgpu/device/support/common.h:  return (value + (alignment - 1)) & ~(alignment - 1);
../../drivers/amdgpu/device/support/common.h:// Returns the number of leading zeros in a 64-bit bitfield.
../../drivers/amdgpu/device/support/common.h:// Returns -1 if no bits are set.
../../drivers/amdgpu/device/support/common.h://  0x0000000000000000 = -1
../../drivers/amdgpu/device/support/common.h://  0xFFFFFFFFFFFFFFFF = -1
../../drivers/amdgpu/device/support/common.h:#define IREE_AMDGPU_LASTBIT_U64(v) ((v) == 0 ? -1 : __builtin_ctzl(v))
../../drivers/amdgpu/device/support/common.h:  ((v) == 0 ? -1 : iree_math_count_trailing_zeros_u64(v))
../../drivers/amdgpu/device/support/common.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/support/common.h:// OpenCL-like Scoped Atomics
../../drivers/amdgpu/device/support/common.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/support/common.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/support/common.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/support/common.h:// time as it suspends for 64*arg + 1-64 clocks but archs have different limits,
../../drivers/amdgpu/device/support/common.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/support/common.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/support/common.h:// TODO(benvanik): use memcpy builtin - these should all be small.
../../drivers/amdgpu/device/support/common.h:// TODO(benvanik): use memset builtin - these should all be small.
../../drivers/amdgpu/device/support/common.h:// GPU - this should only be used when debugging.
../../drivers/amdgpu/device/support/mutex.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/device/support/mutex.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/support/mutex.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/support/mutex.h:// Device spin-lock mutex.
../../drivers/amdgpu/device/support/mutex.h:// Note that because atomics are not guaranteed to work off-agent this is only
../../drivers/amdgpu/device/support/mutex.h:// to be used for intra-agent exclusion such as when multiple queues on the
../../drivers/amdgpu/device/support/signal.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/device/support/signal.h:// bare-metal C and the device libraries are only available in a fork of LLM.
../../drivers/amdgpu/device/support/signal.h:// https://hsafoundation.com/wp-content/uploads/2021/02/HSA-SysArch-1.2.pdf
../../drivers/amdgpu/device/support/signal.h:// https://github.com/ROCm/ROCR-Runtime
../../drivers/amdgpu/device/support/signal.h:// https://github.com/ROCm/rocMLIR/blob/develop/external/llvm-project/amd/device-libs/README.md
../../drivers/amdgpu/device/support/signal.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/support/signal.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/support/signal.h:// A value of 0 indicates a no-op signal (waits will succeed immediately and
../../drivers/amdgpu/device/support/signal.h:// completions will no-op).
../../drivers/amdgpu/device/support/signal.h:// No-op signal that will immediately succeed when waited on and be ignored when
../../drivers/amdgpu/device/support/signal.h:// With barrier value packets it's user-defined and can be any value.
../../drivers/amdgpu/device/support/signal.h:// With barrier-and/barrier-or and dispatch packets it acts as a semaphore where
../../drivers/amdgpu/device/support/signal.h:// a 0 value indicates set and a non-zero value indicates unset. For example,
../../drivers/amdgpu/device/support/signal.h:  // User-defined signal that supports all signal operations.
../../drivers/amdgpu/device/support/signal.h:  // Agent-defined doorbell (usually the queue's doorbell_signal field).
../../drivers/amdgpu/device/support/signal.h:  IREE_AMD_SIGNAL_KIND_DOORBELL = -1,
../../drivers/amdgpu/device/support/signal.h:// Doorbell signals are firmware/hardware-specific and must only be written to
../../drivers/amdgpu/device/support/signal.h:// with the APIs the signals are implemented by two types: busy-wait and
../../drivers/amdgpu/device/support/signal.h:// Busy-wait are like a futex and _mostly_ exist entirely in user-mode.
../../drivers/amdgpu/device/support/signal.h:// `hsaKmtWaitOnEvent` and other kernel-level waits can be performed. For such
../../drivers/amdgpu/device/support/signal.h:// with a futex when in-process and then the full platform handles would be
../../drivers/amdgpu/device/support/signal.h:// when it completes. These timestamps are in agent-specific ticks and need to
../../drivers/amdgpu/device/support/signal.h:// be translated into system-scope by scaling by relative frequencies of the
../../drivers/amdgpu/device/support/signal.h:// on-device we do the same thing by polling `AMDKFD_IOC_GET_CLOCK_COUNTERS`
../../drivers/amdgpu/device/support/signal.h:// we try to only do it per-submission to at least keep all of the times within
../../drivers/amdgpu/device/support/signal.h:// system by the end. Note that because work can happen out-of-order the
../../drivers/amdgpu/device/support/signal.h:// timestamps on a set of signals may be out-of-order with respect to the system
../../drivers/amdgpu/device/support/signal.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/support/signal.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/support/signal.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/support/signal.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/support/signal.h:// These are cloned from llvm-project/amd/device-libs/ockl/src/hsaqs.cl so that
../../drivers/amdgpu/device/support/signal.h:      (iree_amdgpu_scoped_atomic_uint64_t*)signal->event_mailbox_ptr;
../../drivers/amdgpu/device/support/signal.h:    const uint32_t event_id = signal->event_id;
../../drivers/amdgpu/device/support/signal.h:      (iree_amdgpu_scoped_atomic_int64_t*)&s->value, memory_order,
../../drivers/amdgpu/device/support/signal.h:      (iree_amdgpu_scoped_atomic_int64_t*)&s->value, value, memory_order,
../../drivers/amdgpu/device/support/signal.h:      (iree_amdgpu_scoped_atomic_int64_t*)&s->value, value, memory_order,
../../drivers/amdgpu/device/support/signal.h:      (iree_amdgpu_scoped_atomic_int64_t*)&s->value, value, memory_order,
../../drivers/amdgpu/device/support/signal.h:      (iree_amdgpu_scoped_atomic_int64_t*)&s->value, value, memory_order,
../../drivers/amdgpu/device/support/signal.h:      (iree_amdgpu_scoped_atomic_int64_t*)&s->value, value, memory_order,
../../drivers/amdgpu/device/support/signal.h:      (iree_amdgpu_scoped_atomic_int64_t*)&s->value, value, memory_order,
../../drivers/amdgpu/device/support/signal.h:          (iree_amdgpu_scoped_atomic_int64_t*)&s->value, &existing, value,
../../drivers/amdgpu/device/support/signal.h:  if (s->kind == IREE_AMD_SIGNAL_KIND_USER) {
../../drivers/amdgpu/device/support/signal.h:        (iree_amdgpu_scoped_atomic_int64_t*)&s->value, value, memory_order,
../../drivers/amdgpu/device/support/signal.h:        (iree_amdgpu_scoped_atomic_uint64_t*)s->hardware_doorbell_ptr,
../../drivers/amdgpu/device/buffer.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/device/buffer.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/buffer.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/buffer.h:  // Device-side pool in the memory space of the device that owns the
../../drivers/amdgpu/device/buffer.h:  // Opaque host-side pool token.
../../drivers/amdgpu/device/buffer.h:// A handle for a dynamically device-allocated pointer.
../../drivers/amdgpu/device/buffer.h:// The owner of the handle is responsible for storing it in device-visible
../../drivers/amdgpu/device/buffer.h:// the handle to get the actual pointer before using it. Device-side allocs and
../../drivers/amdgpu/device/buffer.h:// frees will update the pointer in queue-order. The handle contents are only
../../drivers/amdgpu/device/buffer.h:// Though the on-device allocator is usually responsible for manipulating the
../../drivers/amdgpu/device/buffer.h:// we'll need to enqueue a device-side deallocation to handle the cleanup. To
../../drivers/amdgpu/device/buffer.h:// avoid extra round-trips we also optimize for host-side pool growth by
../../drivers/amdgpu/device/buffer.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/buffer.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/buffer.h:  // Reference is to a queue-ordered allocation handle that is only valid at
../../drivers/amdgpu/device/buffer.h:  // - yet).
../../drivers/amdgpu/device/buffer.h:    // IREE_HAL_AMDGPU_DEVICE_BUFFER_TYPE_HANDLE: queue-ordered allocation
../../drivers/amdgpu/device/buffer.h:// This is a size-optimized version of iree_hal_amdgpu_device_buffer_ref_t so
../../drivers/amdgpu/device/buffer.h:    // IREE_HAL_AMDGPU_DEVICE_BUFFER_TYPE_HANDLE: queue-ordered allocation
../../drivers/amdgpu/device/buffer.h:// This is a size-optimized version of iree_hal_amdgpu_device_buffer_ref_t so
../../drivers/amdgpu/device/buffer.h:    // IREE_HAL_AMDGPU_DEVICE_BUFFER_TYPE_HANDLE: queue-ordered allocation
../../drivers/amdgpu/device/buffer.h:// capacity for any slot that may be referenced. All queue-ordered allocations
../../drivers/amdgpu/device/buffer.h:// fixed-size uint32_t[3] value. The returned pointer should have 4-byte
../../drivers/amdgpu/device/buffer.h:// fixed-size uint64_t value. The returned pointer should have 8-byte
../../drivers/amdgpu/buffer_pool.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/buffer_pool.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/buffer_pool.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/buffer_pool.h:// on-demand and contain a fixed-size set of HAL buffers allocated inline.
../../drivers/amdgpu/buffer_pool.h:// Thread-safe; multiple host threads may share the same pool.
../../drivers/amdgpu/buffer_pool.h:  // A doubly-linked list of all allocated blocks.
../../drivers/amdgpu/buffer_pool.h:  // A singly-linked list of blocks that have one or more free buffer.
../../drivers/amdgpu/buffer_pool.h:// buffers are acquired. Device-accessible allocation handle storage will be
../../drivers/amdgpu/buffer_pool.h:// allocated from |memory_pool| as needed (not the actual buffers - just
../../drivers/amdgpu/buffer_pool.h:// recycled (ref count 0). The returned |out_handle| is the device-side handle
../../drivers/vulkan/native_allocator.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/native_allocator.cc:  iree_allocator_t host_allocator = logical_device->host_allocator();
../../drivers/vulkan/native_allocator.cc:                               &allocator->resource);
../../drivers/vulkan/native_allocator.cc:  allocator->logical_device = logical_device;
../../drivers/vulkan/native_allocator.cc:  allocator->host_allocator = host_allocator;
../../drivers/vulkan/native_allocator.cc:  allocator->parent_device = parent_device;
../../drivers/vulkan/native_allocator.cc:  const auto& syms = logical_device->syms();
../../drivers/vulkan/native_allocator.cc:  allocator->device_props_11.sType =
../../drivers/vulkan/native_allocator.cc:  allocator->device_props_11.pNext = &external_memory_props;
../../drivers/vulkan/native_allocator.cc:  device_props_2.pNext = &allocator->device_props_11;
../../drivers/vulkan/native_allocator.cc:  syms->vkGetPhysicalDeviceProperties2(physical_device, &device_props_2);
../../drivers/vulkan/native_allocator.cc:  allocator->device_props = device_props_2.properties;
../../drivers/vulkan/native_allocator.cc:  syms->vkGetPhysicalDeviceMemoryProperties(physical_device,
../../drivers/vulkan/native_allocator.cc:                                            &allocator->memory_props);
../../drivers/vulkan/native_allocator.cc:  allocator->min_imported_host_pointer_alignment =
../../drivers/vulkan/native_allocator.cc:      &allocator->device_props, &allocator->memory_props,
../../drivers/vulkan/native_allocator.cc:      &allocator->memory_types);
../../drivers/vulkan/native_allocator.cc:  iree_allocator_t host_allocator = allocator->host_allocator;
../../drivers/vulkan/native_allocator.cc:  return allocator->host_allocator;
../../drivers/vulkan/native_allocator.cc:    memcpy(out_statistics, &allocator->statistics, sizeof(*out_statistics));
../../drivers/vulkan/native_allocator.cc:      &allocator->device_props, &allocator->memory_props,
../../drivers/vulkan/native_allocator.cc:      &allocator->memory_types, capacity, heaps, out_count);
../../drivers/vulkan/native_allocator.cc:  if (allocation_size <= allocator->device_props_11.maxMemoryAllocationSize) {
../../drivers/vulkan/native_allocator.cc:  if (iree_any_bit_set(params->usage, IREE_HAL_BUFFER_USAGE_TRANSFER)) {
../../drivers/vulkan/native_allocator.cc:  if (iree_all_bits_set(params->type, IREE_HAL_MEMORY_TYPE_DEVICE_VISIBLE)) {
../../drivers/vulkan/native_allocator.cc:    if (iree_any_bit_set(params->usage,
../../drivers/vulkan/native_allocator.cc:  params->type &= ~IREE_HAL_MEMORY_TYPE_OPTIMAL;
../../drivers/vulkan/native_allocator.cc:  // application is unlikely to do anything when requesting a 0-byte buffer; but
../../drivers/vulkan/native_allocator.cc:      iree_all_bits_set(allocator->logical_device->enabled_features(),
../../drivers/vulkan/native_allocator.cc:    if (iree_any_bit_set(params->usage,
../../drivers/vulkan/native_allocator.cc:      if (iree_all_bits_set(params->usage,
../../drivers/vulkan/native_allocator.cc:        params->usage &=
../../drivers/vulkan/native_allocator.cc:             allocator->device_props_11.maxMemoryAllocationSize) {
../../drivers/vulkan/native_allocator.cc:  logical_device->syms()->vkDestroyBuffer(*logical_device, handle,
../../drivers/vulkan/native_allocator.cc:                                          logical_device->allocator());
../../drivers/vulkan/native_allocator.cc:  logical_device->syms()->vkFreeMemory(*logical_device, device_memory,
../../drivers/vulkan/native_allocator.cc:                                       logical_device->allocator());
../../drivers/vulkan/native_allocator.cc:  VkDeviceHandle* logical_device = allocator->logical_device;
../../drivers/vulkan/native_allocator.cc:  logical_device->syms()->vkGetDeviceQueue(*logical_device, 0, 0, &queue);
../../drivers/vulkan/native_allocator.cc:      /*.device=*/allocator->parent_device,
../../drivers/vulkan/native_allocator.cc:      /*.queue_affinity=*/params->queue_affinity ? params->queue_affinity
../../drivers/vulkan/native_allocator.cc:  logical_device->syms()->vkGetBufferMemoryRequirements(*logical_device, handle,
../../drivers/vulkan/native_allocator.cc:      &allocator->device_props, &allocator->memory_props, params,
../../drivers/vulkan/native_allocator.cc:        placement, params->type, params->access, params->usage, allocation_size,
../../drivers/vulkan/native_allocator.cc:        allocator->device_props_11.maxMemoryAllocationSize,
../../drivers/vulkan/native_allocator.cc:        allocator->host_allocator, out_buffer);
../../drivers/vulkan/native_allocator.cc:          logical_device->enabled_features(),
../../drivers/vulkan/native_allocator.cc:  VK_RETURN_IF_ERROR(logical_device->syms()->vkAllocateMemory(
../../drivers/vulkan/native_allocator.cc:                         logical_device->allocator(), &device_memory),
../../drivers/vulkan/native_allocator.cc:      placement, params->type, params->access, params->usage, allocation_size,
../../drivers/vulkan/native_allocator.cc:      allocator->host_allocator, out_buffer);
../../drivers/vulkan/native_allocator.cc:    logical_device->syms()->vkFreeMemory(*logical_device, device_memory,
../../drivers/vulkan/native_allocator.cc:                                         logical_device->allocator());
../../drivers/vulkan/native_allocator.cc:        logical_device->syms()->vkBindBufferMemory(
../../drivers/vulkan/native_allocator.cc:  if (iree_all_bits_set(params->usage, IREE_HAL_BUFFER_USAGE_TRANSFER_SOURCE)) {
../../drivers/vulkan/native_allocator.cc:  if (iree_all_bits_set(params->usage, IREE_HAL_BUFFER_USAGE_TRANSFER_TARGET)) {
../../drivers/vulkan/native_allocator.cc:  if (iree_any_bit_set(params->usage, IREE_HAL_BUFFER_USAGE_DISPATCH_STORAGE)) {
../../drivers/vulkan/native_allocator.cc:    logical_device->syms()->vkGetPhysicalDeviceExternalBufferProperties(
../../drivers/vulkan/native_allocator.cc:        logical_device->physical_device(), &external_info, &external_props);
../../drivers/vulkan/native_allocator.cc:          iree_hal_buffer_usage_format(params->usage, &temp0);
../../drivers/vulkan/native_allocator.cc:          iree_hal_buffer_usage_format(params->usage, &temp0);
../../drivers/vulkan/native_allocator.cc:  VK_RETURN_IF_ERROR(logical_device->syms()->vkCreateBuffer(
../../drivers/vulkan/native_allocator.cc:                         logical_device->allocator(), &handle),
../../drivers/vulkan/native_allocator.cc:  VkDeviceHandle* logical_device = allocator->logical_device;
../../drivers/vulkan/native_allocator.cc:      !iree_all_bits_set(allocator->logical_device->enabled_features(),
../../drivers/vulkan/native_allocator.cc:        (int64_t)allocator->device_props_11.maxMemoryAllocationSize);
../../drivers/vulkan/native_allocator.cc:      logical_device->syms()->vkDestroyBuffer(*logical_device, handle,
../../drivers/vulkan/native_allocator.cc:                                              logical_device->allocator());
../../drivers/vulkan/native_allocator.cc:        &allocator->statistics, params->type, buffer->allocation_size);
../../drivers/vulkan/native_allocator.cc:  iree_hal_allocator_statistics_record_free(&allocator->statistics,
../../drivers/vulkan/native_allocator.cc:                                            base_buffer->memory_type,
../../drivers/vulkan/native_allocator.cc:                                            base_buffer->allocation_size);
../../drivers/vulkan/native_allocator.cc:    logical_device->syms()->vkDestroyBuffer(*logical_device, handle,
../../drivers/vulkan/native_allocator.cc:                                            logical_device->allocator());
../../drivers/vulkan/native_allocator.cc:    logical_device->syms()->vkFreeMemory(*logical_device, device_memory,
../../drivers/vulkan/native_allocator.cc:                                         logical_device->allocator());
../../drivers/vulkan/native_allocator.cc:      (iree_device_size_t)requirements->alignment,
../../drivers/vulkan/native_allocator.cc:      (iree_device_size_t)allocator->min_imported_host_pointer_alignment);
../../drivers/vulkan/native_allocator.cc:  VkDeviceSize memory_offset = unaligned_addr - aligned_addr;
../../drivers/vulkan/native_allocator.cc:      ((unaligned_end + desired_alignment - 1) / desired_alignment) *
../../drivers/vulkan/native_allocator.cc:  VkDeviceSize aligned_size = aligned_end - aligned_addr;
../../drivers/vulkan/native_allocator.cc:  VkDeviceHandle* logical_device = allocator->logical_device;
../../drivers/vulkan/native_allocator.cc:  if (!logical_device->enabled_extensions().external_memory_host) {
../../drivers/vulkan/native_allocator.cc:  // Some drivers incorrectly succeed when attempting to import already-mapped
../../drivers/vulkan/native_allocator.cc:  // memory: https://gitlab.freedesktop.org/mesa/mesa/-/issues/9251.
../../drivers/vulkan/native_allocator.cc:  (void)msync(external_buffer->handle.host_allocation.ptr,
../../drivers/vulkan/native_allocator.cc:              external_buffer->size, MS_SYNC);
../../drivers/vulkan/native_allocator.cc:      logical_device->syms()->vkGetMemoryHostPointerPropertiesEXT(
../../drivers/vulkan/native_allocator.cc:          external_buffer->handle.host_allocation.ptr, &props),
../../drivers/vulkan/native_allocator.cc:  // properties memory types contains allocator->memory_types.dispatch_idx then
../../drivers/vulkan/native_allocator.cc:  // we can import as device-local! Otherwise we should only allow host-local.
../../drivers/vulkan/native_allocator.cc:      logical_device, params, external_buffer->size,
../../drivers/vulkan/native_allocator.cc:  logical_device->syms()->vkGetBufferMemoryRequirements(*logical_device, handle,
../../drivers/vulkan/native_allocator.cc:      &allocator->device_props, &allocator->memory_props, params,
../../drivers/vulkan/native_allocator.cc:    logical_device->syms()->vkDestroyBuffer(*logical_device, handle,
../../drivers/vulkan/native_allocator.cc:                                            logical_device->allocator());
../../drivers/vulkan/native_allocator.cc:  void* host_ptr = external_buffer->handle.host_allocation.ptr;
../../drivers/vulkan/native_allocator.cc:  VkDeviceSize allocation_size = (VkDeviceSize)external_buffer->size;
../../drivers/vulkan/native_allocator.cc:  status = VK_RESULT_TO_STATUS(logical_device->syms()->vkAllocateMemory(
../../drivers/vulkan/native_allocator.cc:                                   logical_device->allocator(), &device_memory),
../../drivers/vulkan/native_allocator.cc:    logical_device->syms()->vkDestroyBuffer(*logical_device, handle,
../../drivers/vulkan/native_allocator.cc:                                            logical_device->allocator());
../../drivers/vulkan/native_allocator.cc:      /*.device=*/allocator->parent_device,
../../drivers/vulkan/native_allocator.cc:      /*.queue_affinity=*/params->queue_affinity ? params->queue_affinity
../../drivers/vulkan/native_allocator.cc:      placement, params->type, params->access, params->usage,
../../drivers/vulkan/native_allocator.cc:      /*byte_length=*/external_buffer->size, logical_device, device_memory,
../../drivers/vulkan/native_allocator.cc:      allocator->host_allocator, &buffer);
../../drivers/vulkan/native_allocator.cc:    logical_device->syms()->vkDestroyBuffer(*logical_device, handle,
../../drivers/vulkan/native_allocator.cc:                                            logical_device->allocator());
../../drivers/vulkan/native_allocator.cc:    logical_device->syms()->vkFreeMemory(*logical_device, device_memory,
../../drivers/vulkan/native_allocator.cc:                                         logical_device->allocator());
../../drivers/vulkan/native_allocator.cc:  // Bind the memory to the buffer at a possibly non-zero offset if we had to
../../drivers/vulkan/native_allocator.cc:      logical_device->syms()->vkBindBufferMemory(*logical_device, handle,
../../drivers/vulkan/native_allocator.cc:    logical_device->syms()->vkDestroyBuffer(*logical_device, handle,
../../drivers/vulkan/native_allocator.cc:                                            logical_device->allocator());
../../drivers/vulkan/native_allocator.cc:  VkDeviceHandle* logical_device = allocator->logical_device;
../../drivers/vulkan/native_allocator.cc:      (VkDeviceMemory)external_buffer->handle.device_allocation.ptr;
../../drivers/vulkan/native_allocator.cc:      logical_device, params, external_buffer->size,
../../drivers/vulkan/native_allocator.cc:      logical_device->syms()->vkBindBufferMemory(
../../drivers/vulkan/native_allocator.cc:    logical_device->syms()->vkDestroyBuffer(*logical_device, handle,
../../drivers/vulkan/native_allocator.cc:                                            logical_device->allocator());
../../drivers/vulkan/native_allocator.cc:      /*.device=*/allocator->parent_device,
../../drivers/vulkan/native_allocator.cc:      /*.queue_affinity=*/params->queue_affinity ? params->queue_affinity
../../drivers/vulkan/native_allocator.cc:      placement, params->type, params->access, params->usage,
../../drivers/vulkan/native_allocator.cc:      (iree_device_size_t)external_buffer->size,
../../drivers/vulkan/native_allocator.cc:      /*byte_length=*/external_buffer->size, logical_device, device_memory,
../../drivers/vulkan/native_allocator.cc:      allocator->host_allocator, out_buffer);
../../drivers/vulkan/native_allocator.cc:  switch (external_buffer->type) {
../../drivers/amdgpu/command_buffer.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/command_buffer.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/command_buffer.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/command_buffer.h:  // TODO(benvanik): support lead-physical-device storage. This would need the
../../drivers/amdgpu/command_buffer.h:  // - today the block pool is device-local only. Produced data is immutable and
../../drivers/amdgpu/command_buffer.h:  // consumption and recording time at the cost of cross-device transfers.
../../drivers/amdgpu/command_buffer.h:  // there's no unused device memory - the cost is extra host time to do the
../../drivers/amdgpu/command_buffer.h:  // Used for small allocations of around 1-4KB.
../../drivers/amdgpu/command_buffer.h:  // Used for large page-sized allocations of 32-64kB.
../../drivers/amdgpu/command_buffer.h:                                    ->packet_offset) *                       \
../../drivers/amdgpu/command_buffer.h:  // Block pools for host-only (heap) memory blocks of various sizes.
../../drivers/amdgpu/command_buffer.h:  // These pools should be allocated from coarse-grained memory as once we
../../drivers/amdgpu/command_buffer.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/command_buffer.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/command_buffer.h:// Queries the device-side command buffer representation for the GPU device
../../drivers/amdgpu/util/topology_test.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/base_buffer.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/base_buffer.c://===----------------------------------------------------------------------===//
../../drivers/vulkan/base_buffer.c://===----------------------------------------------------------------------===//
../../drivers/vulkan/base_buffer.c:  for (size_t i = 0; i < IREE_ARRAYSIZE(memory_types->indices); ++i) {
../../drivers/vulkan/base_buffer.c:    indices |= 1u << memory_types->indices[i];
../../drivers/vulkan/base_buffer.c:// Returns true if the memory type at |type_idx| is in a device-local heap.
../../drivers/vulkan/base_buffer.c:  const uint32_t heap_idx = memory_props->memoryTypes[type_idx].heapIndex;
../../drivers/vulkan/base_buffer.c:  return iree_all_bits_set(memory_props->memoryHeaps[heap_idx].flags,
../../drivers/vulkan/base_buffer.c:  iree_hal_memory_type_t requested_type = params->type;
../../drivers/vulkan/base_buffer.c:  if (device_props->deviceType == VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU) {
../../drivers/vulkan/base_buffer.c:      // Device-local, host-visible.
../../drivers/vulkan/base_buffer.c:      // Device-local only.
../../drivers/vulkan/base_buffer.c:      // Host-local, device-visible.
../../drivers/vulkan/base_buffer.c:      // Host-local only.
../../drivers/vulkan/base_buffer.c:  int most_bits_idx = -1;
../../drivers/vulkan/base_buffer.c:  for (uint32_t i = 0; i < memory_props->memoryTypeCount; ++i) {
../../drivers/vulkan/base_buffer.c:    VkMemoryPropertyFlags flags = memory_props->memoryTypes[i].propertyFlags;
../../drivers/vulkan/base_buffer.c:    if (most_bits_idx == -1) {
../../drivers/vulkan/base_buffer.c:  if (most_bits_idx == -1) {
../../drivers/vulkan/base_buffer.c:  int least_bits_idx = -1;
../../drivers/vulkan/base_buffer.c:  for (uint32_t i = 0; i < memory_props->memoryTypeCount; ++i) {
../../drivers/vulkan/base_buffer.c:    VkMemoryPropertyFlags flags = memory_props->memoryTypes[i].propertyFlags;
../../drivers/vulkan/base_buffer.c:      // Only want device-local memory that is usable for storage buffers.
../../drivers/vulkan/base_buffer.c:    // Prefer the type that is device-local and has as few other bits set as
../../drivers/vulkan/base_buffer.c:    // possible (host-visible/etc). On integrated systems we may not have any
../../drivers/vulkan/base_buffer.c:    // type that is purely device-local but still want to ensure we pick
../../drivers/vulkan/base_buffer.c:    if (least_bits_idx == -1) {
../../drivers/vulkan/base_buffer.c:  out_types->dispatch_idx = least_bits_idx;
../../drivers/vulkan/base_buffer.c:  int cached_idx = -1;
../../drivers/vulkan/base_buffer.c:  int uncached_idx = -1;
../../drivers/vulkan/base_buffer.c:  int visible_idx = -1;
../../drivers/vulkan/base_buffer.c:  for (uint32_t i = 0; i < memory_props->memoryTypeCount; ++i) {
../../drivers/vulkan/base_buffer.c:    VkMemoryPropertyFlags flags = memory_props->memoryTypes[i].propertyFlags;
../../drivers/vulkan/base_buffer.c:      // Must be host-visible for transfers.
../../drivers/vulkan/base_buffer.c:    if (visible_idx == -1) visible_idx = i;
../../drivers/vulkan/base_buffer.c:      if (cached_idx == -1) cached_idx = i;
../../drivers/vulkan/base_buffer.c:      if (uncached_idx == -1) uncached_idx = i;
../../drivers/vulkan/base_buffer.c:  // Prefer uncached for uploads to enable write-through to the device.
../../drivers/vulkan/base_buffer.c:  *out_upload_idx = uncached_idx != -1 ? uncached_idx : visible_idx;
../../drivers/vulkan/base_buffer.c:  *out_download_idx = cached_idx != -1 ? cached_idx : visible_idx;
../../drivers/vulkan/base_buffer.c:  int host_local_upload_idx = -1;
../../drivers/vulkan/base_buffer.c:  int host_local_download_idx = -1;
../../drivers/vulkan/base_buffer.c:  int device_local_upload_idx = -1;
../../drivers/vulkan/base_buffer.c:  int device_local_download_idx = -1;
../../drivers/vulkan/base_buffer.c:  // For bulk try first to select host-local memory.
../../drivers/vulkan/base_buffer.c:  // In case that fails we will use device-local memory; common on integrated.
../../drivers/vulkan/base_buffer.c:  out_types->bulk_upload_idx = host_local_upload_idx != -1
../../drivers/vulkan/base_buffer.c:  out_types->bulk_download_idx = host_local_download_idx != -1
../../drivers/vulkan/base_buffer.c:  // Always use device-local for staging if we have it. This is usually PCI-E
../../drivers/vulkan/base_buffer.c:  // BAR/page-locked memory on discrete devices while it may just be host
../../drivers/vulkan/base_buffer.c:  out_types->staging_upload_idx = device_local_upload_idx != -1
../../drivers/vulkan/base_buffer.c:  out_types->staging_download_idx = device_local_download_idx != -1
../../drivers/vulkan/base_buffer.c:// This is a train-wreck of a decision space and definitely wrong in some cases.
../../drivers/vulkan/base_buffer.c://   - DEVICE_LOCAL (dispatch)
../../drivers/vulkan/base_buffer.c://   - DEVICE_LOCAL | HOST_VISIBLE | HOST_COHERENT (upload)
../../drivers/vulkan/base_buffer.c://   - DEVICE_LOCAL | HOST_VISIBLE | HOST_CACHED (download)
../../drivers/vulkan/base_buffer.c://   - DEVICE_LOCAL | HOST_VISIBLE | HOST_COHERENT | HOST_CACHED (everything)
../../drivers/vulkan/base_buffer.c://   - DEVICE_LOCAL | HOST_VISIBLE | HOST_COHERENT | HOST_CACHED (everything)
../../drivers/vulkan/base_buffer.c://   - DEVICE_LOCAL (dispatch)
../../drivers/vulkan/base_buffer.c://   - DEVICE_LOCAL | HOST_VISIBLE | HOST_COHERENT | HOST_CACHED (everything)
../../drivers/vulkan/base_buffer.c:// NVIDIA Tegra-like (VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU):
../../drivers/vulkan/base_buffer.c://   - DEVICE_LOCAL (dispatch)
../../drivers/vulkan/base_buffer.c://   - DEVICE_LOCAL | HOST_VISIBLE | HOST_COHERENT (upload)
../../drivers/vulkan/base_buffer.c://   - DEVICE_LOCAL | HOST_VISIBLE | HOST_CACHED (everything)
../../drivers/vulkan/base_buffer.c://   - DEVICE_LOCAL (dispatch)
../../drivers/vulkan/base_buffer.c://   - DEVICE_LOCAL | HOST_VISIBLE | HOST_COHERENT (staging upload)
../../drivers/vulkan/base_buffer.c://   - DEVICE_LOCAL | HOST_VISIBLE | HOST_CACHED (staging download)
../../drivers/vulkan/base_buffer.c://   - HOST_VISIBLE | HOST_COHERENT (upload)
../../drivers/vulkan/base_buffer.c://   - HOST_VISIBLE | HOST_CACHED (download)
../../drivers/vulkan/base_buffer.c:  for (size_t i = 0; i < IREE_ARRAYSIZE(out_memory_types->indices); ++i) {
../../drivers/vulkan/base_buffer.c:    out_memory_types->indices[i] = -1;
../../drivers/vulkan/base_buffer.c:  // Find the memory type that is most device-local.
../../drivers/vulkan/base_buffer.c:  // let us correlate the memory types with vulkan-info and see if we got the
../../drivers/vulkan/base_buffer.c:  IREE_TRACE_ZONE_APPEND_VALUE_I64(z0, out_memory_types->dispatch_idx);
../../drivers/vulkan/base_buffer.c:  IREE_TRACE_ZONE_APPEND_TEXT(z0, "bulk-upload:");
../../drivers/vulkan/base_buffer.c:  IREE_TRACE_ZONE_APPEND_VALUE_I64(z0, out_memory_types->bulk_upload_idx);
../../drivers/vulkan/base_buffer.c:  IREE_TRACE_ZONE_APPEND_TEXT(z0, "bulk-download:");
../../drivers/vulkan/base_buffer.c:  IREE_TRACE_ZONE_APPEND_VALUE_I64(z0, out_memory_types->bulk_download_idx);
../../drivers/vulkan/base_buffer.c:  IREE_TRACE_ZONE_APPEND_TEXT(z0, "staging-upload:");
../../drivers/vulkan/base_buffer.c:  IREE_TRACE_ZONE_APPEND_VALUE_I64(z0, out_memory_types->staging_upload_idx);
../../drivers/vulkan/base_buffer.c:  IREE_TRACE_ZONE_APPEND_TEXT(z0, "staging-download:");
../../drivers/vulkan/base_buffer.c:  IREE_TRACE_ZONE_APPEND_VALUE_I64(z0, out_memory_types->staging_download_idx);
../../drivers/vulkan/base_buffer.c:  if (out_memory_types->dispatch_idx == -1) {
../../drivers/vulkan/base_buffer.c:                            "dispatch-compatible memory type not found");
../../drivers/vulkan/base_buffer.c:  } else if (out_memory_types->bulk_upload_idx == -1 ||
../../drivers/vulkan/base_buffer.c:             out_memory_types->bulk_download_idx == -1 ||
../../drivers/vulkan/base_buffer.c:             out_memory_types->staging_upload_idx == -1 ||
../../drivers/vulkan/base_buffer.c:             out_memory_types->staging_download_idx == -1) {
../../drivers/vulkan/base_buffer.c:                            "transfer-compatible memory types not found");
../../drivers/vulkan/base_buffer.c:      memory_props->memoryTypes[type_idx].propertyFlags;
../../drivers/vulkan/base_buffer.c:  out_heap->type = memory_type;
../../drivers/vulkan/base_buffer.c:  out_heap->allowed_usage = allowed_usage;
../../drivers/vulkan/base_buffer.c:      &memory_props->memoryHeaps[memory_props->memoryTypes[type_idx].heapIndex];
../../drivers/vulkan/base_buffer.c:  out_heap->max_allocation_size =
../../drivers/vulkan/base_buffer.c:      iree_min(max_allocation_size, memory_heap->size);
../../drivers/vulkan/base_buffer.c:  out_heap->min_alignment = min_alignment;
../../drivers/vulkan/base_buffer.c:      device_props->limits.maxStorageBufferRange;
../../drivers/vulkan/base_buffer.c:      iree_max(16, device_props->limits.minStorageBufferOffsetAlignment);
../../drivers/vulkan/base_buffer.c:    if (!(has_idx & (1u << memory_types->dispatch_idx))) {
../../drivers/vulkan/base_buffer.c:      has_idx |= 1u << memory_types->dispatch_idx;
../../drivers/vulkan/base_buffer.c:          memory_props, memory_types->dispatch_idx, max_allocation_size,
../../drivers/vulkan/base_buffer.c:    if (!(has_idx & (1u << memory_types->bulk_upload_idx))) {
../../drivers/vulkan/base_buffer.c:      has_idx |= 1u << memory_types->bulk_upload_idx;
../../drivers/vulkan/base_buffer.c:          memory_props, memory_types->bulk_upload_idx, max_allocation_size,
../../drivers/vulkan/base_buffer.c:    if (!(has_idx & (1u << memory_types->bulk_download_idx))) {
../../drivers/vulkan/base_buffer.c:      has_idx |= 1u << memory_types->bulk_download_idx;
../../drivers/vulkan/base_buffer.c:          memory_props, memory_types->bulk_download_idx, max_allocation_size,
../../drivers/vulkan/base_buffer.c:    if (!(has_idx & (1u << memory_types->staging_upload_idx))) {
../../drivers/vulkan/base_buffer.c:      has_idx |= 1u << memory_types->staging_upload_idx;
../../drivers/vulkan/base_buffer.c:          memory_props, memory_types->staging_upload_idx, max_allocation_size,
../../drivers/vulkan/base_buffer.c:    if (!(has_idx & (1u << memory_types->staging_download_idx))) {
../../drivers/vulkan/base_buffer.c:      has_idx |= 1u << memory_types->staging_download_idx;
../../drivers/vulkan/base_buffer.c:          memory_props, memory_types->staging_download_idx, max_allocation_size,
../../drivers/vulkan/base_buffer.c:    // NOTE: lightweight as this is hit in normal pre-sizing usage.
../../drivers/vulkan/base_buffer.c://===----------------------------------------------------------------------===//
../../drivers/vulkan/base_buffer.c://===----------------------------------------------------------------------===//
../../drivers/vulkan/base_buffer.c:  *out_memory = buffer->device_memory;
../../drivers/vulkan/base_buffer.c:  *out_handle = buffer->handle;
../../drivers/amdgpu/command_buffer.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/command_buffer.c:// Populates the device-side |out_ref| variant of a HAL buffer |ref|.
../../drivers/amdgpu/command_buffer.c:    out_ref->offset = ref.offset;
../../drivers/amdgpu/command_buffer.c:    out_ref->type = IREE_HAL_AMDGPU_DEVICE_BUFFER_TYPE_SLOT;
../../drivers/amdgpu/command_buffer.c:    out_ref->length = ref.length;
../../drivers/amdgpu/command_buffer.c:    out_ref->value.slot = ref.buffer_slot;
../../drivers/amdgpu/command_buffer.c:  // type-specific). Note that we use the allocated buffer and not any wrapper
../../drivers/amdgpu/command_buffer.c:      &out_ref->value.bits));
../../drivers/amdgpu/command_buffer.c:  out_ref->type = type;
../../drivers/amdgpu/command_buffer.c:  out_ref->offset = iree_hal_buffer_byte_offset(ref.buffer) + ref.offset;
../../drivers/amdgpu/command_buffer.c:    out_ref->length = iree_hal_buffer_byte_length(ref.buffer);
../../drivers/amdgpu/command_buffer.c:    out_ref->length = ref.length;
../../drivers/amdgpu/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/command_buffer.c:  // Next block-relative query ID when tracing commands.
../../drivers/amdgpu/command_buffer.c:  // Reused across blocks and copied out per-block as they each end recording.
../../drivers/amdgpu/command_buffer.c:  scratch->count = 0;
../../drivers/amdgpu/command_buffer.c:  scratch->next.control_id = 0;
../../drivers/amdgpu/command_buffer.c:  scratch->next.dispatch_id = 0;
../../drivers/amdgpu/command_buffer.c:    query_id.control_id = scratch->next.control_id++;
../../drivers/amdgpu/command_buffer.c:    query_id.dispatch_id = scratch->next.dispatch_id++;
../../drivers/amdgpu/command_buffer.c:  scratch->values[scratch->count++] = query_id;
../../drivers/amdgpu/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/command_buffer.c:// Per-device state managed by a command block encoder.
../../drivers/amdgpu/command_buffer.c:  // Arena of device-side memory used for metadata (blocks, query lists, etc)
../../drivers/amdgpu/command_buffer.c:  // Arena of device-side memory used for embedded data (inline update buffers,
../../drivers/amdgpu/command_buffer.c:  // Commands are fixed-size and we allocate one device memory block per CFG
../../drivers/amdgpu/command_buffer.c:// IDs) while command and embedded data is stored per-device.
../../drivers/amdgpu/command_buffer.c:// limits) and the maximum values allowed by the device-side scheduler. Most
../../drivers/amdgpu/command_buffer.c:// but this happens to be in-line with what devices are practically limited to
../../drivers/amdgpu/command_buffer.c:  // Total number of devices being recorded. Used to size per-device state.
../../drivers/amdgpu/command_buffer.c:  // Query ID scratch space for per-command query ID allocation.
../../drivers/amdgpu/command_buffer.c:  // Shared across all devices and copied to per-device block metadata at the
../../drivers/amdgpu/command_buffer.c:  // returned to callers appending commands so they can do per-device updates.
../../drivers/amdgpu/command_buffer.c:  // Allocate the dynamically-sized encoder from the arena.
../../drivers/amdgpu/command_buffer.c:      sizeof(*encoder) + device_count * sizeof(encoder->device_state[0]);
../../drivers/amdgpu/command_buffer.c:  encoder->device_count = device_count;
../../drivers/amdgpu/command_buffer.c:  encoder->host_arena = host_arena;
../../drivers/amdgpu/command_buffer.c:  encoder->command_capacity =
../../drivers/amdgpu/command_buffer.c:      iree_host_size_floor_div(options->device_block_pools[0]->large.block_size,
../../drivers/amdgpu/command_buffer.c:  encoder->max_aql_packet_capacity = options->block_aql_packet_count;
../../drivers/amdgpu/command_buffer.c:  encoder->max_kernarg_capacity = UINT32_MAX;
../../drivers/amdgpu/command_buffer.c:  // TODO(benvanik): support options->recording_flags bit for tracing control
../../drivers/amdgpu/command_buffer.c:  // per-command-buffer. If not set we can disable it here and save some scratch
../../drivers/amdgpu/command_buffer.c:                              sizeof(*encoder->query_ids) +
../../drivers/amdgpu/command_buffer.c:                                  encoder->command_capacity *
../../drivers/amdgpu/command_buffer.c:                                      sizeof(encoder->query_ids->values[0]),
../../drivers/amdgpu/command_buffer.c:                              (void**)&encoder->query_ids));
../../drivers/amdgpu/command_buffer.c:  encoder->query_ids->next.control_id = 0;
../../drivers/amdgpu/command_buffer.c:  encoder->query_ids->next.dispatch_id = 0;
../../drivers/amdgpu/command_buffer.c:  encoder->query_ids->count = 0;
../../drivers/amdgpu/command_buffer.c:                              device_count * sizeof(encoder->device_cmds[0]),
../../drivers/amdgpu/command_buffer.c:                              (void**)&encoder->device_cmds));
../../drivers/amdgpu/command_buffer.c:  // Initialize per-device encoder state.
../../drivers/amdgpu/command_buffer.c:        &encoder->device_state[i];
../../drivers/amdgpu/command_buffer.c:        &options->device_block_pools[i]->small, &device_state->metadata_arena);
../../drivers/amdgpu/command_buffer.c:        &options->device_block_pools[i]->large, &device_state->storage_arena);
../../drivers/amdgpu/command_buffer.c:    device_state->cmd_block.pool = &options->device_block_pools[i]->large;
../../drivers/amdgpu/command_buffer.c:  for (iree_host_size_t i = 0; i < encoder->device_count; ++i) {
../../drivers/amdgpu/command_buffer.c:        &encoder->device_state[i];
../../drivers/amdgpu/command_buffer.c:    if (device_state->cmd_block.head) {
../../drivers/amdgpu/command_buffer.c:      iree_hal_amdgpu_block_pool_release_list(device_state->cmd_block.pool,
../../drivers/amdgpu/command_buffer.c:                                              device_state->cmd_block.head);
../../drivers/amdgpu/command_buffer.c:    if (device_state->cmd_block.current) {
../../drivers/amdgpu/command_buffer.c:      iree_hal_amdgpu_block_pool_release(device_state->cmd_block.pool,
../../drivers/amdgpu/command_buffer.c:                                         device_state->cmd_block.current);
../../drivers/amdgpu/command_buffer.c:    iree_hal_amdgpu_block_arena_deinitialize(&device_state->storage_arena);
../../drivers/amdgpu/command_buffer.c:    iree_hal_amdgpu_block_arena_deinitialize(&device_state->metadata_arena);
../../drivers/amdgpu/command_buffer.c:  if (IREE_UNLIKELY(encoder->in_block)) {
../../drivers/amdgpu/command_buffer.c:  for (iree_host_size_t i = 0; i < encoder->device_count; ++i) {
../../drivers/amdgpu/command_buffer.c:        &encoder->device_state[i];
../../drivers/amdgpu/command_buffer.c:        iree_hal_amdgpu_block_pool_acquire(device_state->cmd_block.pool,
../../drivers/amdgpu/command_buffer.c:                                           &device_state->cmd_block.current));
../../drivers/amdgpu/command_buffer.c:  encoder->in_block = 1;
../../drivers/amdgpu/command_buffer.c:  encoder->barrier_pending = 1;
../../drivers/amdgpu/command_buffer.c:  ++encoder->block_count;
../../drivers/amdgpu/command_buffer.c:// Ends the current command buffer block and finalizes its device-side
../../drivers/amdgpu/command_buffer.c:  if (IREE_UNLIKELY(!encoder->in_block)) {
../../drivers/amdgpu/command_buffer.c:  // Per-block metadata contains the query map sized based on the number of
../../drivers/amdgpu/command_buffer.c:  const iree_hal_amdgpu_query_id_scratch_t* query_ids = encoder->query_ids;
../../drivers/amdgpu/command_buffer.c:      (query_ids ? query_ids->count *
../../drivers/amdgpu/command_buffer.c:  for (iree_host_size_t i = 0; i < encoder->device_count; ++i) {
../../drivers/amdgpu/command_buffer.c:        &encoder->device_state[i];
../../drivers/amdgpu/command_buffer.c:        &device_state->metadata_arena, total_metadata_size,
../../drivers/amdgpu/command_buffer.c:    iree_hal_amdgpu_block_t* cmd_block = device_state->cmd_block.current;
../../drivers/amdgpu/command_buffer.c:    device_state->cmd_block.current = NULL;
../../drivers/amdgpu/command_buffer.c:    cmd_block->next = NULL;
../../drivers/amdgpu/command_buffer.c:    if (device_state->cmd_block.tail) {
../../drivers/amdgpu/command_buffer.c:      device_state->cmd_block.tail->next = cmd_block;
../../drivers/amdgpu/command_buffer.c:      device_state->cmd_block.head = cmd_block;
../../drivers/amdgpu/command_buffer.c:    device_state->cmd_block.tail = cmd_block;
../../drivers/amdgpu/command_buffer.c:    cmd_block->user_data[0] = (uint64_t)block_metadata;
../../drivers/amdgpu/command_buffer.c:    block_metadata->max_packet_count = encoder->aql_packet_offset;
../../drivers/amdgpu/command_buffer.c:    block_metadata->command_count = encoder->command_count;
../../drivers/amdgpu/command_buffer.c:    block_metadata->commands =
../../drivers/amdgpu/command_buffer.c:        (const iree_hal_amdgpu_device_cmd_t*)cmd_block->ptr;
../../drivers/amdgpu/command_buffer.c:      block_metadata->query_map.max_control_query_count =
../../drivers/amdgpu/command_buffer.c:          query_ids->next.control_id;
../../drivers/amdgpu/command_buffer.c:      block_metadata->query_map.max_dispatch_query_count =
../../drivers/amdgpu/command_buffer.c:          query_ids->next.dispatch_id;
../../drivers/amdgpu/command_buffer.c:      iree_memcpy_stream_dst(block_metadata->query_map.query_ids,
../../drivers/amdgpu/command_buffer.c:                             query_ids->values,
../../drivers/amdgpu/command_buffer.c:                             query_ids->count * sizeof(query_ids->values[0]));
../../drivers/amdgpu/command_buffer.c:  encoder->command_count = 0;
../../drivers/amdgpu/command_buffer.c:  encoder->peak_aql_packet_count = encoder->aql_packet_offset;
../../drivers/amdgpu/command_buffer.c:  encoder->aql_packet_offset = 0;
../../drivers/amdgpu/command_buffer.c:  encoder->peak_kernarg_size = encoder->kernarg_offset;
../../drivers/amdgpu/command_buffer.c:  encoder->kernarg_offset = 0;
../../drivers/amdgpu/command_buffer.c:  iree_hal_amdgpu_query_id_scratch_reset(encoder->query_ids);
../../drivers/amdgpu/command_buffer.c:  encoder->in_block = 0;
../../drivers/amdgpu/command_buffer.c:  if (IREE_UNLIKELY(!encoder->in_block)) {
../../drivers/amdgpu/command_buffer.c:  const uint32_t target_block = encoder->block_count + 1;
../../drivers/amdgpu/command_buffer.c:  for (iree_host_size_t i = 0; i < encoder->device_count; ++i) {
../../drivers/amdgpu/command_buffer.c:    device_cmds[i]->kernarg_offset = kernarg_offset;
../../drivers/amdgpu/command_buffer.c:    device_cmds[i]->target_block = target_block;
../../drivers/amdgpu/command_buffer.c:// will be calculated. Callers must populate any additional command-specific
../../drivers/amdgpu/command_buffer.c:// information or flags per-device in the returned |out_device_cmds| list.
../../drivers/amdgpu/command_buffer.c:// NOTE: the command data returned should be treated as write-only as its memory
../../drivers/amdgpu/command_buffer.c:// we'd probably be producing commands in host memory and doing a non-temporal
../../drivers/amdgpu/command_buffer.c:// finalization per-device is just a quick fixup.
../../drivers/amdgpu/command_buffer.c:  if (IREE_UNLIKELY(!encoder->in_block)) {
../../drivers/amdgpu/command_buffer.c:  // requested AQL packets - usually command capacity is conservative enough to
../../drivers/amdgpu/command_buffer.c:      !is_terminator && encoder->command_count + 1 >= encoder->command_capacity;
../../drivers/amdgpu/command_buffer.c:      encoder->aql_packet_offset + aql_packet_count >
../../drivers/amdgpu/command_buffer.c:      encoder->max_aql_packet_capacity;
../../drivers/amdgpu/command_buffer.c:      iree_host_align(encoder->kernarg_offset, kernarg_alignment) +
../../drivers/amdgpu/command_buffer.c:          encoder->max_kernarg_capacity;
../../drivers/amdgpu/command_buffer.c:  // --- WARNING ------------------------------------------------------------ //
../../drivers/amdgpu/command_buffer.c:  // --- WARNING ------------------------------------------------------------ //
../../drivers/amdgpu/command_buffer.c:  uint16_t command_offset = encoder->command_count;
../../drivers/amdgpu/command_buffer.c:  ++encoder->command_count;
../../drivers/amdgpu/command_buffer.c:  if (encoder->barrier_pending) {
../../drivers/amdgpu/command_buffer.c:    encoder->barrier_pending = 0;
../../drivers/amdgpu/command_buffer.c:  cmd.packet_offset = encoder->aql_packet_offset;
../../drivers/amdgpu/command_buffer.c:  encoder->aql_packet_offset += aql_packet_count;
../../drivers/amdgpu/command_buffer.c:        iree_host_align(encoder->kernarg_offset, kernarg_alignment);
../../drivers/amdgpu/command_buffer.c:    encoder->kernarg_offset = encoder->kernarg_offset + kernarg_size;
../../drivers/amdgpu/command_buffer.c:  iree_hal_amdgpu_assign_cmd_query_ids(encoder->query_ids, cmd.type);
../../drivers/amdgpu/command_buffer.c:  // TODO(benvanik): find a way to avoid needing to do this here - if we could
../../drivers/amdgpu/command_buffer.c:  // per-device command information.
../../drivers/amdgpu/command_buffer.c:  for (uint32_t i = 0; i < encoder->device_count; ++i) {
../../drivers/amdgpu/command_buffer.c:        (iree_hal_amdgpu_device_cmd_header_t*)encoder->device_state[i]
../../drivers/amdgpu/command_buffer.c:            .cmd_block.current->ptr +
../../drivers/amdgpu/command_buffer.c:    encoder->device_cmds[i] = device_cmd;
../../drivers/amdgpu/command_buffer.c:  *out_device_cmds = (void**)encoder->device_cmds;
../../drivers/amdgpu/command_buffer.c:      &encoder->device_state[device_index];
../../drivers/amdgpu/command_buffer.c:      &device_state->storage_arena, data.data_length, (void**)&out_ptr));
../../drivers/amdgpu/command_buffer.c:      &encoder->device_state[device_index];
../../drivers/amdgpu/command_buffer.c:      &device_state->storage_arena, total_size, (void**)&base_ptr));
../../drivers/amdgpu/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/command_buffer.c:#define IREE_HAL_AMDGPU_COMMAND_BUFFER_MIN_HOST_SMALL_BLOCK_SIZE (4 * 1024 - 32)
../../drivers/amdgpu/command_buffer.c:#define IREE_HAL_AMDGPU_COMMAND_BUFFER_MIN_METADATA_BLOCK_SIZE (8 * 1024 - 32)
../../drivers/amdgpu/command_buffer.c:  out_options->device_allocator = device_allocator;
../../drivers/amdgpu/command_buffer.c:  out_options->mode = mode;
../../drivers/amdgpu/command_buffer.c:  out_options->command_categories = command_categories;
../../drivers/amdgpu/command_buffer.c:  out_options->queue_affinity = queue_affinity;
../../drivers/amdgpu/command_buffer.c:  out_options->binding_capacity = binding_capacity;
../../drivers/amdgpu/command_buffer.c:  out_options->recording_flags =
../../drivers/amdgpu/command_buffer.c:  out_options->block_aql_packet_count =
../../drivers/amdgpu/command_buffer.c:  if (options->block_aql_packet_count <
../../drivers/amdgpu/command_buffer.c:      options->block_aql_packet_count >
../../drivers/amdgpu/command_buffer.c:        options->block_aql_packet_count);
../../drivers/amdgpu/command_buffer.c:      iree_hal_amdgpu_device_affinity_count(options->device_affinity);
../../drivers/amdgpu/command_buffer.c:  // if we end up needing a power-of-two allocation.
../../drivers/amdgpu/command_buffer.c:  if (options->host_block_pools->small.usable_block_size <
../../drivers/amdgpu/command_buffer.c:        options->host_block_pools->small.usable_block_size);
../../drivers/amdgpu/command_buffer.c:  if (options->host_block_pools->large.usable_block_size <
../../drivers/amdgpu/command_buffer.c:        options->host_block_pools->large.usable_block_size);
../../drivers/amdgpu/command_buffer.c:  // Verify that the device-side pools will fit our data structures that we
../../drivers/amdgpu/command_buffer.c:    if (options->device_block_pools[i]->small.block_size <
../../drivers/amdgpu/command_buffer.c:          options->device_block_pools[i]->small.block_size);
../../drivers/amdgpu/command_buffer.c:    if (options->device_block_pools[i]->large.block_size <
../../drivers/amdgpu/command_buffer.c:          options->device_block_pools[i]->large.block_size);
../../drivers/amdgpu/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/command_buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/command_buffer.c:// A host-side HAL command buffer wrapping a device-side handle.
../../drivers/amdgpu/command_buffer.c:// data will reside in device-local memory. Expensive validation, encoding
../../drivers/amdgpu/command_buffer.c:// Once finalized a command buffer owns per-device references to a list of
../../drivers/amdgpu/command_buffer.c:// memory blocks holding command buffer metadata such as the device-side
../../drivers/amdgpu/command_buffer.c:// and per-device arenas. Once recording completes the encoder is discarded.
../../drivers/amdgpu/command_buffer.c:// not suffer from the support for multiple devices - in most cases no
../../drivers/amdgpu/command_buffer.c:// predictable 1-trip loop has no meaningful additional per-command overhead.
../../drivers/amdgpu/command_buffer.c:// using the HAL may not be able to and we want one-shot command buffers to not
../../drivers/amdgpu/command_buffer.c:// be super inefficient. A one-shot command buffer will never achieve the
../../drivers/amdgpu/command_buffer.c:// latency of a CUDA stream-like API but 99% of application-level operations are
../../drivers/amdgpu/command_buffer.c:// the program than the cheap/garbage-y ones: it's best to have deterministic
../../drivers/amdgpu/command_buffer.c:// cannot time-travel to begin executing while the command buffer is still
../../drivers/amdgpu/command_buffer.c:// Thread-compatible during recording and thread-safe once finalized. Multiple
../../drivers/amdgpu/command_buffer.c:    // the time there is a single executable we fast-path this to avoid
../../drivers/amdgpu/command_buffer.c:  // Compacted list of device-side copies of the command buffer.
../../drivers/amdgpu/command_buffer.c:    // Device-side command buffer descriptor used to launch execution.
../../drivers/amdgpu/command_buffer.c:    // Pool used for the device-side command blocks.
../../drivers/amdgpu/command_buffer.c:    // Pool used for the device-side metadata like the command buffer and CFG
../../drivers/amdgpu/command_buffer.c:    // device-side command buffer metadata.
../../drivers/amdgpu/command_buffer.c:    // device-side command buffer embedded data.
../../drivers/amdgpu/command_buffer.c:      iree_hal_command_buffer_validation_state_size(options->mode,
../../drivers/amdgpu/command_buffer.c:                                                    options->binding_capacity);
../../drivers/amdgpu/command_buffer.c:      iree_hal_amdgpu_device_affinity_count(options->device_affinity);
../../drivers/amdgpu/command_buffer.c:      device_count * sizeof(command_buffer->device_state[0]) +
../../drivers/amdgpu/command_buffer.c:      options->device_allocator, options->mode, options->command_categories,
../../drivers/amdgpu/command_buffer.c:      options->queue_affinity, options->binding_capacity,
../../drivers/amdgpu/command_buffer.c:      (uint8_t*)command_buffer + total_size - validation_state_size,
../../drivers/amdgpu/command_buffer.c:      &iree_hal_amdgpu_command_buffer_vtable, &command_buffer->base);
../../drivers/amdgpu/command_buffer.c:  command_buffer->host_allocator = host_allocator;
../../drivers/amdgpu/command_buffer.c:  command_buffer->device_affinity = options->device_affinity;
../../drivers/amdgpu/command_buffer.c:    command_buffer->device_state[i].cmd_block_pool =
../../drivers/amdgpu/command_buffer.c:        &options->device_block_pools[i]->large;
../../drivers/amdgpu/command_buffer.c:    command_buffer->device_state[i].metadata_pool =
../../drivers/amdgpu/command_buffer.c:        &options->device_block_pools[i]->small;
../../drivers/amdgpu/command_buffer.c:    command_buffer->device_state[i].storage_pool =
../../drivers/amdgpu/command_buffer.c:        &options->device_block_pools[i]->large;
../../drivers/amdgpu/command_buffer.c:  // If we supported re-recording we'd need to save this information so that we
../../drivers/amdgpu/command_buffer.c:  iree_arena_initialize(&options->host_block_pools->large,
../../drivers/amdgpu/command_buffer.c:                        &command_buffer->recording_state.host_arena);
../../drivers/amdgpu/command_buffer.c:      options, device_count, &command_buffer->recording_state.host_arena,
../../drivers/amdgpu/command_buffer.c:      &command_buffer->recording_state.encoder);
../../drivers/amdgpu/command_buffer.c:  // would want to repack/trim the resource set when freezing (if not one-shot
../../drivers/amdgpu/command_buffer.c:    status = iree_hal_resource_set_allocate(&options->host_block_pools->small,
../../drivers/amdgpu/command_buffer.c:                                            &command_buffer->resource_set);
../../drivers/amdgpu/command_buffer.c:    *out_command_buffer = &command_buffer->base;
../../drivers/amdgpu/command_buffer.c:    iree_hal_command_buffer_release(&command_buffer->base);
../../drivers/amdgpu/command_buffer.c:  iree_allocator_t host_allocator = command_buffer->host_allocator;
../../drivers/amdgpu/command_buffer.c:      iree_hal_amdgpu_device_affinity_count(command_buffer->device_affinity);
../../drivers/amdgpu/command_buffer.c:        command_buffer->device_state[i].cmd_block_pool,
../../drivers/amdgpu/command_buffer.c:        command_buffer->device_state[i].cmd_block_head);
../../drivers/amdgpu/command_buffer.c:        command_buffer->device_state[i].metadata_pool,
../../drivers/amdgpu/command_buffer.c:        command_buffer->device_state[i].metadata_head);
../../drivers/amdgpu/command_buffer.c:        command_buffer->device_state[i].storage_pool,
../../drivers/amdgpu/command_buffer.c:        command_buffer->device_state[i].storage_head);
../../drivers/amdgpu/command_buffer.c:      command_buffer->recording_state.encoder);
../../drivers/amdgpu/command_buffer.c:  iree_arena_deinitialize(&command_buffer->recording_state.host_arena);
../../drivers/amdgpu/command_buffer.c:  iree_hal_resource_set_free(command_buffer->resource_set);
../../drivers/amdgpu/command_buffer.c:  return iree_hal_resource_is(&command_buffer->resource,
../../drivers/amdgpu/command_buffer.c:      iree_hal_amdgpu_device_affinity_count(command_buffer->device_affinity);
../../drivers/amdgpu/command_buffer.c:      command_buffer->device_state[device_ordinal].handle;
../../drivers/amdgpu/command_buffer.c:  *out_max_kernarg_capacity = command_buffer->max_kernarg_capacity;
../../drivers/amdgpu/command_buffer.c:  // Today we only support a single recording. If we want to allow re-recording
../../drivers/amdgpu/command_buffer.c:      command_buffer->recording_state.encoder;
../../drivers/amdgpu/command_buffer.c:      command_buffer->recording_state.encoder;
../../drivers/amdgpu/command_buffer.c:  if (IREE_UNLIKELY(encoder->in_block)) {
../../drivers/amdgpu/command_buffer.c:  // Capture host-side metadata used for submissions.
../../drivers/amdgpu/command_buffer.c:  command_buffer->max_kernarg_capacity = encoder->peak_kernarg_size;
../../drivers/amdgpu/command_buffer.c:  // Capture device-side metadata used for scheduling.
../../drivers/amdgpu/command_buffer.c:  for (iree_host_size_t i = 0; i < encoder->device_count; ++i) {
../../drivers/amdgpu/command_buffer.c:        &encoder->device_state[i];
../../drivers/amdgpu/command_buffer.c:        sizeof(*handle) + encoder->block_count * sizeof(handle->blocks[0]);
../../drivers/amdgpu/command_buffer.c:        &device_state->metadata_arena, handle_size, (void**)&handle));
../../drivers/amdgpu/command_buffer.c:    handle->max_kernarg_capacity = encoder->peak_kernarg_size;
../../drivers/amdgpu/command_buffer.c:    handle->block_count = encoder->block_count;
../../drivers/amdgpu/command_buffer.c:    command_buffer->device_state[i].handle = handle;
../../drivers/amdgpu/command_buffer.c:    iree_hal_amdgpu_block_t* cmd_head = device_state->cmd_block.head;
../../drivers/amdgpu/command_buffer.c:    device_state->cmd_block.head = NULL;
../../drivers/amdgpu/command_buffer.c:    device_state->cmd_block.tail = NULL;
../../drivers/amdgpu/command_buffer.c:    IREE_ASSERT(!device_state->cmd_block.current);
../../drivers/amdgpu/command_buffer.c:    command_buffer->device_state[i].cmd_block_head = cmd_head;
../../drivers/amdgpu/command_buffer.c:    for (iree_host_size_t j = 0; j < encoder->block_count;
../../drivers/amdgpu/command_buffer.c:         ++j, cmd_block = cmd_block->next) {
../../drivers/amdgpu/command_buffer.c:      handle->blocks[j] =
../../drivers/amdgpu/command_buffer.c:          (iree_hal_amdgpu_device_command_block_t*)cmd_block->user_data[0];
../../drivers/amdgpu/command_buffer.c:    command_buffer->device_state[i].metadata_head =
../../drivers/amdgpu/command_buffer.c:            &device_state->metadata_arena);
../../drivers/amdgpu/command_buffer.c:    command_buffer->device_state[i].storage_head =
../../drivers/amdgpu/command_buffer.c:            &device_state->storage_arena);
../../drivers/amdgpu/command_buffer.c:      command_buffer->recording_state.encoder;
../../drivers/amdgpu/command_buffer.c:  for (iree_host_size_t i = 0; i < encoder->device_count; ++i) {
../../drivers/amdgpu/command_buffer.c:    device_cmds[i]->kernarg_offset = kernarg_offset;
../../drivers/amdgpu/command_buffer.c:  // from and cleaning up other host-only recording state.
../../drivers/amdgpu/command_buffer.c:  iree_arena_deinitialize(&command_buffer->recording_state.host_arena);
../../drivers/amdgpu/command_buffer.c:  memset(&command_buffer->recording_state, 0,
../../drivers/amdgpu/command_buffer.c:         sizeof(command_buffer->recording_state));
../../drivers/amdgpu/command_buffer.c:  iree_hal_resource_set_freeze(command_buffer->resource_set);
../../drivers/amdgpu/command_buffer.c:  // Tracing disabled - this wouldn't go anywhere.
../../drivers/amdgpu/command_buffer.c:      command_buffer->recording_state.encoder;
../../drivers/amdgpu/command_buffer.c:  // per-device information.
../../drivers/amdgpu/command_buffer.c:  for (iree_host_size_t i = 0; i < encoder->device_count; ++i) {
../../drivers/amdgpu/command_buffer.c:    cmd->src_loc = src_loc;
../../drivers/amdgpu/command_buffer.c:    cmd->label_literal = (uint64_t)label_literal;
../../drivers/amdgpu/command_buffer.c:    cmd->label_literal_length = label.size;
../../drivers/amdgpu/command_buffer.c:    cmd->color = label_color.value;
../../drivers/amdgpu/command_buffer.c:  // Tracing disabled - this wouldn't go anywhere.
../../drivers/amdgpu/command_buffer.c:      command_buffer->recording_state.encoder;
../../drivers/amdgpu/command_buffer.c:      command_buffer->recording_state.encoder;
../../drivers/amdgpu/command_buffer.c:  encoder->barrier_pending = 1;
../../drivers/amdgpu/command_buffer.c:  //     command_buffer->encoder, IREE_HAL_AMDGPU_DEVICE_CMD_BARRIER,
../../drivers/amdgpu/command_buffer.c:  // enacts the specified set of barriers. Implementations without fine-grained
../../drivers/amdgpu/command_buffer.c:  // madvise-like command that can be used to control prefetching and other
../../drivers/amdgpu/command_buffer.c:  // Translate the target buffer to its device-side representations. Translation
../../drivers/amdgpu/command_buffer.c:  // is currently device-independent.
../../drivers/amdgpu/command_buffer.c:        command_buffer->resource_set, IREE_ARRAYSIZE(resources), resources));
../../drivers/amdgpu/command_buffer.c:      command_buffer->recording_state.encoder;
../../drivers/amdgpu/command_buffer.c:  // per-device information.
../../drivers/amdgpu/command_buffer.c:  for (iree_host_size_t i = 0; i < encoder->device_count; ++i) {
../../drivers/amdgpu/command_buffer.c:    cmd->kernarg_offset = kernarg_offset;
../../drivers/amdgpu/command_buffer.c:    cmd->target_ref = resolved_target_ref;
../../drivers/amdgpu/command_buffer.c:    memcpy(&cmd->pattern, pattern, pattern_length);
../../drivers/amdgpu/command_buffer.c:    cmd->pattern_length = pattern_length;
../../drivers/amdgpu/command_buffer.c:  // Translate the target buffer to its device-side representations. Translation
../../drivers/amdgpu/command_buffer.c:  // is currently device-independent.
../../drivers/amdgpu/command_buffer.c:  // If the size exceeds the data block capacity we cannot allocate it - we
../../drivers/amdgpu/command_buffer.c:        command_buffer->resource_set, IREE_ARRAYSIZE(resources), resources));
../../drivers/amdgpu/command_buffer.c:      command_buffer->recording_state.encoder;
../../drivers/amdgpu/command_buffer.c:  // per-device information.
../../drivers/amdgpu/command_buffer.c:  for (iree_host_size_t i = 0; i < encoder->device_count; ++i) {
../../drivers/amdgpu/command_buffer.c:    cmd->kernarg_offset = kernarg_offset;
../../drivers/amdgpu/command_buffer.c:    cmd->target_ref = resolved_target_ref;
../../drivers/amdgpu/command_buffer.c:    // Capture and embed the source data per-device.
../../drivers/amdgpu/command_buffer.c:    // That would reduce total memory consumption in multi-device cases at the
../../drivers/amdgpu/command_buffer.c:    // cost of additional cross-device traffic when the command buffer is issued
../../drivers/amdgpu/command_buffer.c:    cmd->source_ref = (iree_hal_amdgpu_device_buffer_ref_t){
../../drivers/amdgpu/command_buffer.c:            &cmd->source_ref.value.ptr),
../../drivers/amdgpu/command_buffer.c:  // Translate the buffers to their device-side representations. Translation is
../../drivers/amdgpu/command_buffer.c:  // currently device-independent.
../../drivers/amdgpu/command_buffer.c:        command_buffer->resource_set, IREE_ARRAYSIZE(resources), resources));
../../drivers/amdgpu/command_buffer.c:      command_buffer->recording_state.encoder;
../../drivers/amdgpu/command_buffer.c:  // per-device information.
../../drivers/amdgpu/command_buffer.c:  for (iree_host_size_t i = 0; i < encoder->device_count; ++i) {
../../drivers/amdgpu/command_buffer.c:    cmd->kernarg_offset = kernarg_offset;
../../drivers/amdgpu/command_buffer.c:    cmd->source_ref = resolved_source_ref;
../../drivers/amdgpu/command_buffer.c:    cmd->target_ref = resolved_target_ref;
../../drivers/amdgpu/command_buffer.c:  // device-side command buffer.
../../drivers/amdgpu/command_buffer.c:                    host_kernel_args->constant_count * sizeof(uint32_t))) {
../../drivers/amdgpu/command_buffer.c:                            host_kernel_args->constant_count * sizeof(uint32_t),
../../drivers/amdgpu/command_buffer.c:  } else if (IREE_UNLIKELY(bindings.count != host_kernel_args->binding_count)) {
../../drivers/amdgpu/command_buffer.c:                            host_kernel_args->binding_count, bindings.count);
../../drivers/amdgpu/command_buffer.c:      host_kernel_args->kernarg_size - explicit_kernarg_size;
../../drivers/amdgpu/command_buffer.c:          : host_kernel_args->kernarg_size;
../../drivers/amdgpu/command_buffer.c:  // Resolve all bindings ahead of the per-device work.
../../drivers/amdgpu/command_buffer.c:  // Today we do not have per-device resolution but could in the future if we
../../drivers/amdgpu/command_buffer.c:  // TODO(benvanik): add support for lead-physical-device mode:
../../drivers/amdgpu/command_buffer.c:  // was ever a need for lead-device placement it'd be for this information. I'm
../../drivers/amdgpu/command_buffer.c:  // not sure there's a need, though, so it's kept simple/time-efficient today.
../../drivers/amdgpu/command_buffer.c:        command_buffer->resource_set, 1, &config.workgroup_count_ref.buffer));
../../drivers/amdgpu/command_buffer.c:      command_buffer->resource_set, bindings.count, bindings.values,
../../drivers/amdgpu/command_buffer.c:  // aren't recording for - that's ok).
../../drivers/amdgpu/command_buffer.c:  // This is a micro-optimization that mostly shows up in either smaller
../../drivers/amdgpu/command_buffer.c:  if (executable != command_buffer->recording_state.last_executable) {
../../drivers/amdgpu/command_buffer.c:        command_buffer->resource_set, 1, &executable));
../../drivers/amdgpu/command_buffer.c:    command_buffer->recording_state.last_executable = executable;
../../drivers/amdgpu/command_buffer.c:      command_buffer->recording_state.encoder;
../../drivers/amdgpu/command_buffer.c:      kernarg_size, host_kernel_args->kernarg_alignment, (void***)&device_cmds,
../../drivers/amdgpu/command_buffer.c:  // per-device information.
../../drivers/amdgpu/command_buffer.c:  IREE_HAL_AMDGPU_FOR_PHYSICAL_DEVICE(command_buffer->device_affinity) {
../../drivers/amdgpu/command_buffer.c:    cmd->kernarg_offset = kernarg_offset;
../../drivers/amdgpu/command_buffer.c:    // Lookup the per-device kernel information. Each device has its own
../../drivers/amdgpu/command_buffer.c:    cmd->config.flags = cmd_flags;
../../drivers/amdgpu/command_buffer.c:    cmd->config.kernel_args = device_kernel_args;
../../drivers/amdgpu/command_buffer.c:    memcpy(&cmd->config.workgroup_count, &workgroup_count,
../../drivers/amdgpu/command_buffer.c:           sizeof(cmd->config.workgroup_count));
../../drivers/amdgpu/command_buffer.c:        constants, (void**)&cmd->bindings, (void**)&cmd->constants));
../../drivers/amdgpu/device/support/queue.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/device/support/queue.h:// bare-metal C and the device libraries are only available in a fork of LLM.
../../drivers/amdgpu/device/support/queue.h:// https://hsafoundation.com/wp-content/uploads/2021/02/HSA-SysArch-1.2.pdf
../../drivers/amdgpu/device/support/queue.h:// https://github.com/ROCm/ROCR-Runtime
../../drivers/amdgpu/device/support/queue.h:// https://github.com/ROCm/rocMLIR/blob/develop/external/llvm-project/amd/device-libs/README.md
../../drivers/amdgpu/device/support/queue.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/support/queue.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/support/queue.h:  // Queue features mask. This is a bit-field of iree_hsa_queue_feature_t
../../drivers/amdgpu/device/support/queue.h:  name = (((1 << (width)) - 1) << (shift))
../../drivers/amdgpu/device/support/queue.h:  // All devices we care about are 64-bit.
../../drivers/amdgpu/device/support/queue.h:// properties to check modes - otherwise we just treat any queue handle as
../../drivers/amdgpu/device/support/queue.h:  volatile uint64_t scratch_last_used_index; /* async-reclaim */
../../drivers/amdgpu/device/support/queue.h:  volatile uint64_t alt_scratch_last_used_index; /* async-reclaim */
../../drivers/amdgpu/device/support/queue.h:  uint64_t alt_scratch_backing_memory_location;  /* async-reclaim */
../../drivers/amdgpu/device/support/queue.h:  uint64_t alt_scratch_backing_memory_byte_size; /* async-reclaim */
../../drivers/amdgpu/device/support/queue.h:  uint32_t alt_scratch_dispatch_limit_x;         /* async-reclaim */
../../drivers/amdgpu/device/support/queue.h:  uint32_t alt_scratch_dispatch_limit_y;         /* async-reclaim */
../../drivers/amdgpu/device/support/queue.h:  uint32_t alt_scratch_dispatch_limit_z;         /* async-reclaim */
../../drivers/amdgpu/device/support/queue.h:  uint32_t alt_scratch_wave64_lane_byte_size;    /* async-reclaim */
../../drivers/amdgpu/device/support/queue.h:  uint32_t alt_compute_tmpring_size;             /* async-reclaim */
../../drivers/amdgpu/device/support/queue.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/support/queue.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/support/queue.h:// prevents the device from possibly needing to dereference the host-side
../../drivers/amdgpu/device/support/queue.h:      /*.base_address=*/queue->base_address,
../../drivers/amdgpu/device/support/queue.h:      /*.size=*/queue->size,
../../drivers/amdgpu/device/support/queue.h:      /*.doorbell_signal=*/{queue->doorbell_signal.handle},
../../drivers/amdgpu/device/support/queue.h:          ->write_dispatch_id,
../../drivers/amdgpu/device/support/queue.h:          ->read_dispatch_id,
../../drivers/amdgpu/device/support/queue.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/support/queue.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/support/queue.h:// Since the smallest atomic width is 32-bits and this header is 16-bits any
../../drivers/amdgpu/device/support/queue.h:// operations updating the header must include the subsequent 16-bits of the
../../drivers/amdgpu/device/support/queue.h:// Width in bits of the sub-fields in iree_hsa_packet_header_t.
../../drivers/amdgpu/device/support/queue.h:// Forms a packet 16-bit AQL packet header.
../../drivers/amdgpu/device/support/queue.h:// Pseudo-code:
../../drivers/amdgpu/device/support/queue.h:  // Number of grid dimensions (1, 2, or 3 - we always use 3).
../../drivers/amdgpu/device/support/queue.h:  // Work-group size in work-items.
../../drivers/amdgpu/device/support/queue.h:  // Grid size in work-items.
../../drivers/amdgpu/device/support/queue.h:  // Total size in bytes of the per-work-item memory.
../../drivers/amdgpu/device/support/queue.h:  // Total size in bytes of the per-work-group memory.
../../drivers/amdgpu/device/support/queue.h:  // Must be 16-byte aligned and live until the dispatch has completed.
../../drivers/amdgpu/device/support/queue.h:  // Optional signal indicating completion of all work-groups.
../../drivers/amdgpu/device/support/queue.h:// Pseudo-code:
../../drivers/amdgpu/device/support/queue.h:  // Agent-defined type (discriminator).
../../drivers/amdgpu/device/support/queue.h:// Barrier-AND (2.9.8 in the spec).
../../drivers/amdgpu/device/support/queue.h:// Pseudo-code:
../../drivers/amdgpu/device/support/queue.h:// Barrier-OR (2.9.9 in the spec).
../../drivers/amdgpu/device/support/queue.h:// Pseudo-code:
../../drivers/amdgpu/device/support/queue.h:// Prefix of AMD-specific vendor packets.
../../drivers/amdgpu/device/support/queue.h:  // Secondary type indicating which AMD-specific packet this is.
../../drivers/amdgpu/device/support/queue.h:// Pseudo-code:
../../drivers/amdgpu/device/support/queue.h:  // AMD vendor-specific packet header.
../../drivers/amdgpu/device/support/queue.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/support/queue.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/support/queue.h:// Layout-wise explicit args always start at offset 0 and implicit args follow
../../drivers/amdgpu/device/support/queue.h:// those with 8-byte alignment.
../../drivers/amdgpu/device/support/queue.h:// https://github.com/llvm/llvm-project/blob/7f1b465c6ae476e59dc90652d58fc648932d23b1/llvm/lib/Target/AMDGPU/AMDGPUHSAMetadataStreamer.cpp#L389
../../drivers/amdgpu/device/support/queue.h:// https://github.com/llvm/llvm-project/blob/7f1b465c6ae476e59dc90652d58fc648932d23b1/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp#L299
../../drivers/amdgpu/device/support/queue.h:// the kernel -- there's no way for us to know. In the ideal case none of them
../../drivers/amdgpu/device/support/queue.h:// are read and the kernel function gets the `amdgpu-no-implicitarg-ptr` attr
../../drivers/amdgpu/device/support/queue.h:// We really should try to force `amdgpu-no-implicitarg-ptr` when we generate
../../drivers/amdgpu/device/support/queue.h:// For our bare-metal C runtime device code we have total freedom and don't use
../../drivers/amdgpu/device/support/queue.h:// any OpenCL/HIP-related things that would emit the implicit args.
../../drivers/amdgpu/device/support/queue.h:  // dimension being partial. This count only includes the non-partial
../../drivers/amdgpu/device/support/queue.h:  // This size only applies to the non-partial workgroups. This is the same
../../drivers/amdgpu/device/support/queue.h:  // Fixed-size buffer for `-mprintf-kind=buffered` support.
../../drivers/amdgpu/device/support/queue.h:  // Each printf consists of a control DWORD followed by 8-byte aligned
../../drivers/amdgpu/device/support/queue.h:  //  data[0] contains the lower 64-bits of the MD5 hash of the string followed
../../drivers/amdgpu/device/support/queue.h:  //  by size_in_bytes-12 arguments. The data buffer needs to be expanded into
../../drivers/amdgpu/device/support/queue.h:  //  an 8-byte aligned NUL-terminated string with the corresponding hash
../../drivers/amdgpu/device/support/queue.h:  // The data buffer is an 8-byte aligned NUL-terminated string followed by
../../drivers/amdgpu/device/support/queue.h:  // (with the last byte being padding to an 8-byte boundary). The reference
../../drivers/amdgpu/device/support/queue.h:  // Note that in another disappointing display of rube-goldbergian development
../../drivers/amdgpu/device/support/queue.h:  // but never aligns it - meaning that consumer code must use unaligned loads
../../drivers/amdgpu/device/support/queue.h:  // wrote it did a find from the end instead of a prefix consume - there's
../../drivers/amdgpu/device/support/queue.h:  // it's just a semi-unique value we use to lookup the string formats. On load
../../drivers/amdgpu/device/support/queue.h:  // https://github.com/ROCm/llvm-project/commit/631c965483e03355cdc1dba578e787b259c4d79d
../../drivers/amdgpu/device/support/queue.h:  // https://github.com/ROCm/llvm-project/blob/997363823fcc5ccc7b0cc572aad05ba08714bf5f/amd/device-libs/ockl/src/cprintf.cl#L17
../../drivers/amdgpu/device/support/queue.h:  // https://github.com/ROCm/clr/blob/a2550e0a9ecaa8f371cb14d08904c51874c37cbe/rocclr/device/rocm/rocprintf.cpp#L428-L429
../../drivers/amdgpu/device/support/queue.h:  // `amdgpu-no-hostcall-ptr` attribute is set). At this point I'm quite sure no
../../drivers/amdgpu/device/support/queue.h:  // Multi-grid support was deprecated in ROCM 5.x and should never appear in
../../drivers/amdgpu/device/support/queue.h:  // https://github.com/ROCm/llvm-project/blob/97753eeaa4c79c2db2dcd9f37b7989596a8d4f15/amd/device-libs/ockl/src/dm.cl#L192
../../drivers/amdgpu/device/support/queue.h:  // AQL queue handles are only used by OpenCL device-side enqueue and we do not
../../drivers/amdgpu/device/support/queue.h:  // to support device-enqueue we'd do it in a structured fashion instead of
../../drivers/amdgpu/device/support/queue.h:  // https://github.com/ROCm/llvm-project/blob/97753eeaa4c79c2db2dcd9f37b7989596a8d4f15/amd/device-libs/opencl/src/devenq/enqueue.cl#L310
../../drivers/amdgpu/device/support/queue.h:  // HIP has never supported them. Device-side enqueue in OpenCL uses this but
../../drivers/amdgpu/device/support/queue.h:  // https://github.com/ROCm/llvm-project/blob/97753eeaa4c79c2db2dcd9f37b7989596a8d4f15/amd/device-libs/opencl/src/devenq/enqueue.cl#L311
../../drivers/amdgpu/device/support/queue.h:  // Only used by pre-GFX9 devices, which we don't support.
../../drivers/amdgpu/device/support/queue.h:   sizeof(((iree_amdgpu_kernel_implicit_args_t*)NULL)->dynamic_lds_size))
../../drivers/amdgpu/device/support/queue.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/support/queue.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/support/queue.h:// These come from llvm-project/amd/device-libs/ockl/src/workitem.cl (the ockl
../../drivers/amdgpu/device/support/queue.h:// functions) and llvm-project/clang/lib/CodeGen/CGBuiltin.cpp (e.g.
../../drivers/amdgpu/device/support/queue.h:// workgroup offset and device-side enqueue - that's our job).
../../drivers/amdgpu/device/support/queue.h:  const uint32_t group_size = iree_amdgcn_dispatch_ptr()->workgroup_size[0];
../../drivers/amdgpu/device/support/queue.h:  const uint32_t group_size = iree_amdgcn_dispatch_ptr()->workgroup_size[1];
../../drivers/amdgpu/device/support/queue.h:  const uint32_t group_size = iree_amdgcn_dispatch_ptr()->workgroup_size[2];
../../drivers/amdgpu/device/support/queue.h:  const uint32_t grid_size = iree_amdgcn_dispatch_ptr()->grid_size[0];
../../drivers/amdgpu/device/support/queue.h:  const uint32_t group_size = iree_amdgcn_dispatch_ptr()->workgroup_size[0];
../../drivers/amdgpu/device/support/queue.h:  const uint32_t grid_size = iree_amdgcn_dispatch_ptr()->grid_size[1];
../../drivers/amdgpu/device/support/queue.h:  const uint32_t group_size = iree_amdgcn_dispatch_ptr()->workgroup_size[1];
../../drivers/amdgpu/device/support/queue.h:  const uint32_t grid_size = iree_amdgcn_dispatch_ptr()->grid_size[2];
../../drivers/amdgpu/device/support/queue.h:  const uint32_t group_size = iree_amdgcn_dispatch_ptr()->workgroup_size[2];
../../drivers/amdgpu/device/support/queue.h:  const uint32_t group_size = iree_amdgcn_dispatch_ptr()->workgroup_size[0];
../../drivers/amdgpu/device/support/queue.h:  const uint32_t grid_size = iree_amdgcn_dispatch_ptr()->grid_size[0];
../../drivers/amdgpu/device/support/queue.h:  const uint32_t r = grid_size - group_id * group_size;
../../drivers/amdgpu/device/support/queue.h:  const uint32_t group_size = iree_amdgcn_dispatch_ptr()->workgroup_size[1];
../../drivers/amdgpu/device/support/queue.h:  const uint32_t grid_size = iree_amdgcn_dispatch_ptr()->grid_size[1];
../../drivers/amdgpu/device/support/queue.h:  const uint32_t r = grid_size - group_id * group_size;
../../drivers/amdgpu/device/support/queue.h:  const uint32_t group_size = iree_amdgcn_dispatch_ptr()->workgroup_size[2];
../../drivers/amdgpu/device/support/queue.h:  const uint32_t grid_size = iree_amdgcn_dispatch_ptr()->grid_size[2];
../../drivers/amdgpu/device/support/queue.h:  const uint32_t r = grid_size - group_id * group_size;
../../drivers/amdgpu/device/support/queue.h:             iree_amdgcn_dispatch_ptr()->workgroup_size[0] +
../../drivers/amdgpu/device/support/queue.h:                          iree_amdgcn_dispatch_ptr()->workgroup_size[0] +
../../drivers/amdgpu/device/support/queue.h:                          iree_amdgcn_dispatch_ptr()->workgroup_size[1] +
../../drivers/amdgpu/device/support/queue.h:  return id_y * iree_amdgcn_dispatch_ptr()->grid_size[0] + id_x;
../../drivers/amdgpu/device/support/queue.h:                          iree_amdgcn_dispatch_ptr()->workgroup_size[0] +
../../drivers/amdgpu/device/support/queue.h:                          iree_amdgcn_dispatch_ptr()->workgroup_size[1] +
../../drivers/amdgpu/device/support/queue.h:                          iree_amdgcn_dispatch_ptr()->workgroup_size[2] +
../../drivers/amdgpu/device/support/queue.h:  return (id_z * iree_amdgcn_dispatch_ptr()->grid_size[1] + id_y) *
../../drivers/amdgpu/device/support/queue.h:             iree_amdgcn_dispatch_ptr()->grid_size[0] +
../../drivers/amdgpu/device/support/queue.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/support/queue.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/support/queue.h:// These are cloned from llvm-project/amd/device-libs/ockl/src/hsaqs.cl so that
../../drivers/amdgpu/device/support/queue.h:  return iree_amdgpu_scoped_atomic_load(queue->read_dispatch_id, memory_order,
../../drivers/amdgpu/device/support/queue.h:  iree_amdgpu_scoped_atomic_store(queue->read_dispatch_id, value, memory_order,
../../drivers/amdgpu/device/support/queue.h:  return iree_amdgpu_scoped_atomic_load(queue->write_dispatch_id, memory_order,
../../drivers/amdgpu/device/support/queue.h:  return iree_amdgpu_scoped_atomic_fetch_add(queue->write_dispatch_id, value,
../../drivers/amdgpu/device/support/queue.h:      queue->write_dispatch_id, &e, value, memory_order,
../../drivers/amdgpu/device/support/queue.h:  iree_amdgpu_scoped_atomic_store(queue->write_dispatch_id, value, memory_order,
../../drivers/amdgpu/util/bitmap.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/util/bitmap.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/bitmap.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/bitmap.c:// TODO(benvanik): move to iree/base/internal/math.h? Also used in device-side
../../drivers/amdgpu/util/bitmap.c:  ((v) == 0 ? -1 : iree_math_count_trailing_zeros_u64(v))
../../drivers/amdgpu/util/bitmap.c:  (~0ull << ((bit_offset) & (IREE_HAL_AMDGPU_BITMAP_BITS_PER_WORD - 1)))
../../drivers/amdgpu/util/bitmap.c:  (~0ull >> (-(bit_offset) & (IREE_HAL_AMDGPU_BITMAP_BITS_PER_WORD - 1)))
../../drivers/amdgpu/util/bitmap.c:                 (bit_index & (IREE_HAL_AMDGPU_BITMAP_BITS_PER_WORD - 1)));
../../drivers/amdgpu/util/bitmap.c:  int64_t bit_chunk = IREE_HAL_AMDGPU_BITMAP_BITS_PER_WORD -
../../drivers/amdgpu/util/bitmap.c:  while ((int64_t)bit_length - bit_chunk >= 0) {
../../drivers/amdgpu/util/bitmap.c:    bit_length -= bit_chunk;
../../drivers/amdgpu/util/bitmap.c:  int64_t bit_chunk = IREE_HAL_AMDGPU_BITMAP_BITS_PER_WORD -
../../drivers/amdgpu/util/bitmap.c:  while ((int64_t)bit_length - bit_chunk >= 0) {
../../drivers/amdgpu/util/bitmap.c:    bit_length -= bit_chunk;
../../drivers/vulkan/debug_reporter.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/debug_reporter.h:// instance-specific reporter.
../../drivers/amdgpu/util/CMakeLists.txt:# CMake-only content.                                                          #
../../drivers/amdgpu/util/CMakeLists.txt:    "iree-hal-drivers-amdgpu-tests"
../../drivers/amdgpu/util/CMakeLists.txt:    "iree-hal-drivers-amdgpu-tests"
../../drivers/amdgpu/util/CMakeLists.txt:    "iree-hal-drivers-amdgpu-tests"
../../drivers/amdgpu/util/CMakeLists.txt:    "iree-hal-drivers-amdgpu-tests"
../../drivers/amdgpu/util/CMakeLists.txt:    "iree-hal-drivers-amdgpu-tests"
../../drivers/amdgpu/util/CMakeLists.txt:    "iree-hal-drivers-amdgpu-tests"
../../drivers/amdgpu/util/CMakeLists.txt:    "iree-hal-drivers-amdgpu-tests"
../../drivers/amdgpu/util/CMakeLists.txt:# Enable statically linking against ROCR-Runtime.
../../drivers/amdgpu/util/CMakeLists.txt:# unless it is known that the deployment is always on an up-to-date AMDGPU
../../drivers/amdgpu/util/CMakeLists.txt:       "Statically link against the installed hsa-runtime64 package."
../../drivers/amdgpu/util/CMakeLists.txt:  find_package(hsa-runtime64 1.0 REQUIRED)
../../drivers/amdgpu/util/CMakeLists.txt:      "-DIREE_HAL_AMDGPU_LIBHSA_STATIC=1"
../../drivers/amdgpu/util/CMakeLists.txt:      hsa-runtime64::hsa-runtime64
../../drivers/amdgpu/util/kfd_test.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/util/kfd_test.cc:// NOTE: ROCR also opens the KFD - if it initializes then we're likely to
../../drivers/amdgpu/util/kfd_test.cc:// Note that we currently no-op the helpers on non-Linux platforms and this
../../drivers/amdgpu/util/kfd_test.cc:  int kfd = -1;
../../drivers/amdgpu/util/kfd_test.cc:// Tests that we get non-zero counters from the clock.
../../drivers/amdgpu/util/kfd_test.cc:// We always make the call but only expect non-zero if the returned kfd fd is
../../drivers/amdgpu/util/kfd_test.cc:// not 0 (the special value for "not a real fd" we use on non-Linux).
../../drivers/amdgpu/util/kfd_test.cc:  int kfd = -1;
../../drivers/amdgpu/util/BUILD.bazel:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/util/BUILD.bazel:##----------------------------------------------------------------------------##
../../drivers/amdgpu/util/BUILD.bazel:##----------------------------------------------------------------------------##
../../drivers/amdgpu/util/BUILD.bazel:    group = "iree-hal-drivers-amdgpu-tests",
../../drivers/amdgpu/util/BUILD.bazel:    group = "iree-hal-drivers-amdgpu-tests",
../../drivers/amdgpu/util/BUILD.bazel:##----------------------------------------------------------------------------##
../../drivers/amdgpu/util/BUILD.bazel:##----------------------------------------------------------------------------##
../../drivers/amdgpu/util/BUILD.bazel:    group = "iree-hal-drivers-amdgpu-tests",
../../drivers/amdgpu/util/BUILD.bazel:    group = "iree-hal-drivers-amdgpu-tests",
../../drivers/amdgpu/util/BUILD.bazel:    group = "iree-hal-drivers-amdgpu-tests",
../../drivers/amdgpu/util/BUILD.bazel:    group = "iree-hal-drivers-amdgpu-tests",
../../drivers/amdgpu/util/BUILD.bazel:    group = "iree-hal-drivers-amdgpu-tests",
../../drivers/amdgpu/util/libhsa.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/util/libhsa.h:#include "third_party/hsa-runtime-headers/include/hsa/amd_hsa_queue.h"  // IWYU pragma: export
../../drivers/amdgpu/util/libhsa.h:#include "third_party/hsa-runtime-headers/include/hsa/amd_hsa_signal.h"  // IWYU pragma: export
../../drivers/amdgpu/util/libhsa.h:#include "third_party/hsa-runtime-headers/include/hsa/hsa.h"  // IWYU pragma: export
../../drivers/amdgpu/util/libhsa.h:#include "third_party/hsa-runtime-headers/include/hsa/hsa_ext_amd.h"  // IWYU pragma: export
../../drivers/amdgpu/util/libhsa.h:#include "third_party/hsa-runtime-headers/include/hsa/hsa_ven_amd_loader.h"  // IWYU pragma: export
../../drivers/amdgpu/util/libhsa.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/libhsa.h:// Compile-time Configuration
../../drivers/amdgpu/util/libhsa.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/libhsa.h:// By default we dynamically link against ROCR-Runtime. This allows us to keep
../../drivers/amdgpu/util/libhsa.h:// software, and produce binaries that run on systems without ROCR-Runtime
../../drivers/amdgpu/util/libhsa.h:// be run on a machine with an AMD GPU and up-to-date drivers we support
../../drivers/amdgpu/util/libhsa.h:// statically linking against the installed ROCR-Runtime instead. This very
../../drivers/amdgpu/util/libhsa.h:// Set `-DIREE_HAL_AMDGPU_LIBHSA_STATIC=1` in CMake to link against the package.
../../drivers/amdgpu/util/libhsa.h:// If already linking ROCR-Runtime into the top-level binary then add a compiler
../../drivers/amdgpu/util/libhsa.h:// define `-DIREE_HAL_AMDGPU_LIBHSA_STATIC=1` to have this code emit imports
../../drivers/amdgpu/util/libhsa.h:// TODO(benvanik): expose as a more configurable setting - for now we try to
../../drivers/amdgpu/util/libhsa.h:// stick to low-frequency events by default and have this for people debugging
../../drivers/amdgpu/util/libhsa.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/libhsa.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/libhsa.h:// Dynamically loaded libhsa-runtime64.so (or equivalent).
../../drivers/amdgpu/util/libhsa.h:// structure can be treated by-value so long as the appropriate copy method is
../../drivers/amdgpu/util/libhsa.h:// Thread-safe; immutable.
../../drivers/amdgpu/util/libhsa.h:// Initializes |out_libhsa| in-place with dynamically loaded HSA symbols.
../../drivers/amdgpu/util/libhsa.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/libhsa.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/device_library.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/util/device_library.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/device_library.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/device_library.c:  if (isas->count >= IREE_ARRAYSIZE(isas->values)) {
../../drivers/amdgpu/util/device_library.c:  isas->values[isas->count++] = isa;
../../drivers/amdgpu/util/device_library.c:  for (iree_host_size_t i = 0; i < isas->count; ++i) {
../../drivers/amdgpu/util/device_library.c:        iree_hsa_isa_get_info_alt(IREE_LIBHSA(libhsa), isas->values[i],
../../drivers/amdgpu/util/device_library.c:        builder, isa_name_length - 1, &isa_name));
../../drivers/amdgpu/util/device_library.c:        IREE_LIBHSA(libhsa), isas->values[i], HSA_ISA_INFO_NAME, isa_name));
../../drivers/amdgpu/util/device_library.c:    // Get the ISA name - it'll be something like `amdgcn-amd-amdhsa--gfx1100`
../../drivers/amdgpu/util/device_library.c:        iree_make_string_view(isa_name_buffer, isa_name_length - /*NUL*/ 1);
../../drivers/amdgpu/util/device_library.c:      if (iree_string_view_starts_with(IREE_SV(file_toc->name), isa_name)) {
../../drivers/amdgpu/util/device_library.c:    IREE_TRACE_ZONE_APPEND_TEXT(z0, best_file_toc->name);
../../drivers/amdgpu/util/device_library.c:  if (IREE_UNLIKELY(topology->gpu_agent_count == 0)) {
../../drivers/amdgpu/util/device_library.c:  out_library->libhsa = libhsa;
../../drivers/amdgpu/util/device_library.c:  // multi-device HAL usage is expected for different devices.
../../drivers/amdgpu/util/device_library.c:          libhsa, topology->gpu_agents[0], host_allocator, &isa, &file_toc));
../../drivers/amdgpu/util/device_library.c:              IREE_LIBHSA(libhsa), file_toc->data, file_toc->size,
../../drivers/amdgpu/util/device_library.c:                                     options, &out_library->executable);
../../drivers/amdgpu/util/device_library.c:  // Note that we could save off the loaded_code_object per-agent here but then
../../drivers/amdgpu/util/device_library.c:  // we'd need big fixed storage or dynamically allocated storage - instead we
../../drivers/amdgpu/util/device_library.c:    for (iree_host_size_t i = 0; i < topology->gpu_agent_count; ++i) {
../../drivers/amdgpu/util/device_library.c:          IREE_LIBHSA(libhsa), out_library->executable, topology->gpu_agents[i],
../../drivers/amdgpu/util/device_library.c:                                        out_library->executable, options);
../../drivers/amdgpu/util/device_library.c:  if (library->executable.handle) {
../../drivers/amdgpu/util/device_library.c:    IREE_IGNORE_ERROR(iree_hsa_executable_destroy(IREE_LIBHSA(library->libhsa),
../../drivers/amdgpu/util/device_library.c:                                                  library->executable));
../../drivers/amdgpu/util/device_library.c:      find_state->libhsa->amd_loader
../../drivers/amdgpu/util/device_library.c:  if (agent.handle == find_state->agent.handle) {
../../drivers/amdgpu/util/device_library.c:    find_state->loaded_code_object = loaded_code_object;
../../drivers/amdgpu/util/device_library.c:      libhsa->amd_loader
../../drivers/amdgpu/util/device_library.c:  const iree_hal_amdgpu_libhsa_t* libhsa = library->libhsa;
../../drivers/amdgpu/util/device_library.c:              libhsa, library->executable, device_agent, &loaded_code_object));
../../drivers/amdgpu/util/device_library.c:        libhsa->amd_loader.hsa_ven_amd_loader_loaded_code_object_get_info(
../../drivers/amdgpu/util/device_library.c:    hsa_status = libhsa->amd_loader.hsa_ven_amd_loader_query_host_address(
../../drivers/amdgpu/util/device_library.c:        libhsa->amd_loader.hsa_ven_amd_loader_loaded_code_object_get_info(
../../drivers/amdgpu/util/device_library.c:  const iree_hal_amdgpu_libhsa_t* libhsa = library->libhsa;
../../drivers/amdgpu/util/device_library.c:                                             library->executable, symbol_name,
../../drivers/amdgpu/util/device_library.c:  out_kernel_args->setup = 3 << HSA_KERNEL_DISPATCH_PACKET_SETUP_DIMENSIONS;
../../drivers/amdgpu/util/device_library.c:  out_kernel_args->workgroup_size[0] = workgroup_size_x;
../../drivers/amdgpu/util/device_library.c:  out_kernel_args->workgroup_size[1] = workgroup_size_y;
../../drivers/amdgpu/util/device_library.c:  out_kernel_args->workgroup_size[2] = workgroup_size_z;
../../drivers/amdgpu/util/device_library.c:          &out_kernel_args->kernel_object));
../../drivers/amdgpu/util/device_library.c:              &out_kernel_args->private_segment_size));
../../drivers/amdgpu/util/device_library.c:              &out_kernel_args->group_segment_size));
../../drivers/amdgpu/util/device_library.c:              &out_kernel_args->kernarg_size));
../../drivers/amdgpu/util/device_library.c:              &out_kernel_args->kernarg_alignment));
../../drivers/amdgpu/util/device_library.c:  out_kernel_args->trace_src_loc = 0;
../../drivers/amdgpu/util/device_library.c:  out_kernel_args->trace_src_loc = 0;
../../drivers/amdgpu/util/device_library.c:          workgroup_size_y, workgroup_size_z, &out_kernels->name),        \
../../drivers/amdgpu/util/kfd.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/util/kfd.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/kfd.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/kfd.h:// non-portable and code using it must be tolerant (usually #ifdef'd on
../../drivers/amdgpu/util/kfd.h:// Interrupt-tolerant ioctl.
../../drivers/amdgpu/util/kfd.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/kfd.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/kfd.h:// https://github.com/ROCm/ROCR-Runtime/issues/278
../../drivers/amdgpu/device/BUILD.bazel:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/device/BUILD.bazel:#===------------------------------------------------------------------------===#
../../drivers/amdgpu/device/BUILD.bazel:#===------------------------------------------------------------------------===#
../../drivers/amdgpu/device/BUILD.bazel:#===------------------------------------------------------------------------===#
../../drivers/amdgpu/device/BUILD.bazel:#===------------------------------------------------------------------------===#
../../drivers/amdgpu/device/BUILD.bazel:#===------------------------------------------------------------------------===#
../../drivers/amdgpu/device/BUILD.bazel:# Architecture-specific Binaries
../../drivers/amdgpu/device/BUILD.bazel:#===------------------------------------------------------------------------===#
../../drivers/amdgpu/device/BUILD.bazel:# for now we include a hand-picked set that people using bazel request.
../../drivers/amdgpu/device/BUILD.bazel:    name = "amdgcn-amd-amdhsa--gfx1100",
../../drivers/amdgpu/device/BUILD.bazel:    target = "amdgcn-amd-amdhsa",
../../drivers/amdgpu/device/BUILD.bazel:#===------------------------------------------------------------------------===#
../../drivers/amdgpu/device/BUILD.bazel:#===------------------------------------------------------------------------===#
../../drivers/amdgpu/device/BUILD.bazel:        ":amdgcn-amd-amdhsa--gfx1100.so",
../../drivers/amdgpu/util/affinity.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/util/affinity.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/affinity.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/block_pool.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/util/block_pool.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/block_pool.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/block_pool.c:                             "block size must be a power-of-two; got %" PRIdsz,
../../drivers/amdgpu/util/block_pool.c:  out_block_pool->libhsa = libhsa;
../../drivers/amdgpu/util/block_pool.c:  out_block_pool->host_allocator = host_allocator;
../../drivers/amdgpu/util/block_pool.c:  out_block_pool->agent = agent;
../../drivers/amdgpu/util/block_pool.c:  out_block_pool->memory_pool = memory_pool;
../../drivers/amdgpu/util/block_pool.c:  out_block_pool->block_size = options.block_size;
../../drivers/amdgpu/util/block_pool.c:  out_block_pool->blocks_per_allocation =
../../drivers/amdgpu/util/block_pool.c:  IREE_TRACE_ZONE_APPEND_VALUE_I64(z0, out_block_pool->blocks_per_allocation);
../../drivers/amdgpu/util/block_pool.c:  iree_slim_mutex_initialize(&out_block_pool->mutex);
../../drivers/amdgpu/util/block_pool.c:  iree_slim_mutex_lock(&out_block_pool->mutex);
../../drivers/amdgpu/util/block_pool.c:      options.initial_capacity, out_block_pool->blocks_per_allocation);
../../drivers/amdgpu/util/block_pool.c:  iree_slim_mutex_unlock(&out_block_pool->mutex);
../../drivers/amdgpu/util/block_pool.c:  IREE_ASSERT(!block_pool->allocations_head,
../../drivers/amdgpu/util/block_pool.c:  iree_slim_mutex_deinitialize(&block_pool->mutex);
../../drivers/amdgpu/util/block_pool.c:          IREE_LIBHSA(block_pool->libhsa), block_pool->memory_pool,
../../drivers/amdgpu/util/block_pool.c:          block_pool->blocks_per_allocation * block_pool->block_size,
../../drivers/amdgpu/util/block_pool.c:      block_pool->block_size * block_pool->blocks_per_allocation);
../../drivers/amdgpu/util/block_pool.c:      block_pool->host_allocator,
../../drivers/amdgpu/util/block_pool.c:      sizeof(*block_allocation) + block_pool->blocks_per_allocation *
../../drivers/amdgpu/util/block_pool.c:                                      sizeof(block_allocation->blocks[0]),
../../drivers/amdgpu/util/block_pool.c:    block_allocation->next = block_pool->allocations_head;
../../drivers/amdgpu/util/block_pool.c:    block_allocation->base_ptr = base_ptr;
../../drivers/amdgpu/util/block_pool.c:    block_allocation->used_count = 0;
../../drivers/amdgpu/util/block_pool.c:    block_pool->allocations_head = block_allocation;
../../drivers/amdgpu/util/block_pool.c:    for (iree_host_size_t i = 0; i < block_pool->blocks_per_allocation; ++i) {
../../drivers/amdgpu/util/block_pool.c:      iree_hal_amdgpu_block_t* block = &block_allocation->blocks[i];
../../drivers/amdgpu/util/block_pool.c:      block->ptr = base_ptr + i * block_pool->block_size;
../../drivers/amdgpu/util/block_pool.c:      block->allocation = block_allocation;
../../drivers/amdgpu/util/block_pool.c:      block->next = block_pool->free_blocks_head;
../../drivers/amdgpu/util/block_pool.c:      block_pool->free_blocks_head = block;
../../drivers/amdgpu/util/block_pool.c:        IREE_LIBHSA(block_pool->libhsa), base_ptr));
../../drivers/amdgpu/util/block_pool.c:  // completed - otherwise a sequence of trim+alloc could cause higher peak
../../drivers/amdgpu/util/block_pool.c:  iree_slim_mutex_lock(&block_pool->mutex);
../../drivers/amdgpu/util/block_pool.c:  iree_hal_amdgpu_block_t* free_block = block_pool->free_blocks_head;
../../drivers/amdgpu/util/block_pool.c:    iree_hal_amdgpu_block_t* next_free_block = free_block->next;
../../drivers/amdgpu/util/block_pool.c:    if (free_block->allocation->used_count == 0) {
../../drivers/amdgpu/util/block_pool.c:      // Allocation will be freed below - unlink.
../../drivers/amdgpu/util/block_pool.c:      if (free_block == block_pool->free_blocks_head) {
../../drivers/amdgpu/util/block_pool.c:        block_pool->free_blocks_head = next_free_block;
../../drivers/amdgpu/util/block_pool.c:        prev_free_block->next = next_free_block;
../../drivers/amdgpu/util/block_pool.c:      // Allocation still has uses - keep the block in the list.
../../drivers/amdgpu/util/block_pool.c:  iree_hal_amdgpu_block_allocation_t* allocation = block_pool->allocations_head;
../../drivers/amdgpu/util/block_pool.c:    iree_hal_amdgpu_block_allocation_t* next_allocation = allocation->next;
../../drivers/amdgpu/util/block_pool.c:    if (allocation->used_count == 0) {
../../drivers/amdgpu/util/block_pool.c:      // No blocks outstanding - can free and remove from the allocation list.
../../drivers/amdgpu/util/block_pool.c:          IREE_LIBHSA(block_pool->libhsa), allocation->base_ptr));
../../drivers/amdgpu/util/block_pool.c:      if (allocation == block_pool->allocations_head) {
../../drivers/amdgpu/util/block_pool.c:        block_pool->allocations_head = next_allocation;
../../drivers/amdgpu/util/block_pool.c:        prev_allocation->next = next_allocation;
../../drivers/amdgpu/util/block_pool.c:      iree_allocator_free(block_pool->host_allocator, allocation);
../../drivers/amdgpu/util/block_pool.c:  iree_slim_mutex_unlock(&block_pool->mutex);
../../drivers/amdgpu/util/block_pool.c:  iree_slim_mutex_lock(&block_pool->mutex);
../../drivers/amdgpu/util/block_pool.c:  if (!block_pool->free_blocks_head) {
../../drivers/amdgpu/util/block_pool.c:  iree_hal_amdgpu_block_t* block = block_pool->free_blocks_head;
../../drivers/amdgpu/util/block_pool.c:  block_pool->free_blocks_head = block->next;
../../drivers/amdgpu/util/block_pool.c:  block->next = NULL;  // user may use this
../../drivers/amdgpu/util/block_pool.c:  block->prev = NULL;
../../drivers/amdgpu/util/block_pool.c:  memset(block->user_data, 0, sizeof(block->user_data));
../../drivers/amdgpu/util/block_pool.c:  ++block->allocation->used_count;
../../drivers/amdgpu/util/block_pool.c:  iree_slim_mutex_unlock(&block_pool->mutex);
../../drivers/amdgpu/util/block_pool.c:  iree_slim_mutex_lock(&block_pool->mutex);
../../drivers/amdgpu/util/block_pool.c:  block->next = block_pool->free_blocks_head;
../../drivers/amdgpu/util/block_pool.c:  block_pool->free_blocks_head = block;
../../drivers/amdgpu/util/block_pool.c:  --block->allocation->used_count;
../../drivers/amdgpu/util/block_pool.c:  iree_slim_mutex_unlock(&block_pool->mutex);
../../drivers/amdgpu/util/block_pool.c:  iree_slim_mutex_lock(&block_pool->mutex);
../../drivers/amdgpu/util/block_pool.c:    --block->allocation->used_count;
../../drivers/amdgpu/util/block_pool.c:    block = block->next;
../../drivers/amdgpu/util/block_pool.c:  // If we didn't have the per-block work we could do this without scanning the
../../drivers/amdgpu/util/block_pool.c:  block_tail->next = block_pool->free_blocks_head;
../../drivers/amdgpu/util/block_pool.c:  block_pool->free_blocks_head = block_tail;
../../drivers/amdgpu/util/block_pool.c:  iree_slim_mutex_unlock(&block_pool->mutex);
../../drivers/amdgpu/util/block_pool.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/block_pool.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/block_pool.c:  out_arena->block_pool = block_pool;
../../drivers/amdgpu/util/block_pool.c:  if (arena->block_head != NULL) {
../../drivers/amdgpu/util/block_pool.c:    iree_hal_amdgpu_block_pool_release_list(arena->block_pool,
../../drivers/amdgpu/util/block_pool.c:                                            arena->block_head);
../../drivers/amdgpu/util/block_pool.c:    arena->block_head = NULL;
../../drivers/amdgpu/util/block_pool.c:    arena->block_tail = NULL;
../../drivers/amdgpu/util/block_pool.c:  arena->total_allocation_size = 0;
../../drivers/amdgpu/util/block_pool.c:  arena->used_allocation_size = 0;
../../drivers/amdgpu/util/block_pool.c:  arena->block_bytes_remaining = 0;
../../drivers/amdgpu/util/block_pool.c:  iree_hal_amdgpu_block_t* block_head = arena->block_head;
../../drivers/amdgpu/util/block_pool.c:  arena->block_head = NULL;
../../drivers/amdgpu/util/block_pool.c:  arena->block_tail = NULL;
../../drivers/amdgpu/util/block_pool.c:  arena->total_allocation_size = 0;
../../drivers/amdgpu/util/block_pool.c:  arena->used_allocation_size = 0;
../../drivers/amdgpu/util/block_pool.c:  arena->block_bytes_remaining = 0;
../../drivers/amdgpu/util/block_pool.c:  iree_hal_amdgpu_block_pool_t* block_pool = arena->block_pool;
../../drivers/amdgpu/util/block_pool.c:  const iree_device_size_t block_size = block_pool->block_size;
../../drivers/amdgpu/util/block_pool.c:  // Check to see if the current block (if any) has space - if not, get another.
../../drivers/amdgpu/util/block_pool.c:  if (arena->block_head == NULL ||
../../drivers/amdgpu/util/block_pool.c:      arena->block_bytes_remaining < aligned_length) {
../../drivers/amdgpu/util/block_pool.c:        z0, iree_hal_amdgpu_block_pool_acquire(arena->block_pool, &block));
../../drivers/amdgpu/util/block_pool.c:    block->next = NULL;
../../drivers/amdgpu/util/block_pool.c:    if (arena->block_tail) {
../../drivers/amdgpu/util/block_pool.c:      arena->block_tail->next = block;
../../drivers/amdgpu/util/block_pool.c:      block->prev = arena->block_tail;
../../drivers/amdgpu/util/block_pool.c:      arena->block_head = block;
../../drivers/amdgpu/util/block_pool.c:    arena->block_tail = block;
../../drivers/amdgpu/util/block_pool.c:    arena->total_allocation_size += block_size;
../../drivers/amdgpu/util/block_pool.c:    arena->block_bytes_remaining = block_size;
../../drivers/amdgpu/util/block_pool.c:  IREE_AMDGPU_DEVICE_PTR void* ptr = (uint8_t*)arena->block_tail->ptr +
../../drivers/amdgpu/util/block_pool.c:                                     block_size - arena->block_bytes_remaining;
../../drivers/amdgpu/util/block_pool.c:  arena->block_bytes_remaining -= aligned_length;
../../drivers/amdgpu/util/block_pool.c:  arena->used_allocation_size += aligned_length;
../../drivers/amdgpu/util/block_pool.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/block_pool.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/block_pool.c:                            " bytes must be a power-of-two",
../../drivers/amdgpu/util/block_pool.c:  } else if (IREE_UNLIKELY(block_pool->block_size < min_page_size)) {
../../drivers/amdgpu/util/block_pool.c:        min_page_size, block_pool->block_size);
../../drivers/amdgpu/util/block_pool.c:      iree_max(min_page_size, block_pool->block_size / max_page_count);
../../drivers/amdgpu/util/block_pool.c:  const iree_host_size_t page_count = block_pool->block_size / page_size;
../../drivers/amdgpu/util/block_pool.c:  out_allocator->page_size = page_size;
../../drivers/amdgpu/util/block_pool.c:  out_allocator->page_count = page_count;
../../drivers/amdgpu/util/block_pool.c:  out_allocator->block_pool = block_pool;
../../drivers/amdgpu/util/block_pool.c:  iree_slim_mutex_initialize(&out_allocator->mutex);
../../drivers/amdgpu/util/block_pool.c:  out_allocator->block_head = NULL;
../../drivers/amdgpu/util/block_pool.c:  out_allocator->block_tail = NULL;
../../drivers/amdgpu/util/block_pool.c:  IREE_ASSERT_EQ(allocator->block_head, NULL);
../../drivers/amdgpu/util/block_pool.c:  IREE_ASSERT_EQ(allocator->block_tail, NULL);
../../drivers/amdgpu/util/block_pool.c:  iree_slim_mutex_deinitialize(&allocator->mutex);
../../drivers/amdgpu/util/block_pool.c:  iree_hal_amdgpu_block_t* block = allocator->block_head;
../../drivers/amdgpu/util/block_pool.c:        .bit_count = allocator->page_count,
../../drivers/amdgpu/util/block_pool.c:        .words = &block->user_data[0],
../../drivers/amdgpu/util/block_pool.c:      // No span of sufficient size found - try the next block with free pages.
../../drivers/amdgpu/util/block_pool.c:      block = block->next;
../../drivers/amdgpu/util/block_pool.c:    *out_ptr = (uint8_t*)block->ptr + page_index * allocator->page_size;
../../drivers/amdgpu/util/block_pool.c:    out_token->page_count = (uint64_t)page_count;
../../drivers/amdgpu/util/block_pool.c:    out_token->block = (uint64_t)block;
../../drivers/amdgpu/util/block_pool.c:      iree_hal_amdgpu_block_pool_acquire(allocator->block_pool, &block));
../../drivers/amdgpu/util/block_pool.c:      .bit_count = allocator->page_count,
../../drivers/amdgpu/util/block_pool.c:      .words = &block->user_data[0],
../../drivers/amdgpu/util/block_pool.c:  if (page_count == allocator->page_count) {
../../drivers/amdgpu/util/block_pool.c:    block->next = NULL;
../../drivers/amdgpu/util/block_pool.c:    block->prev = allocator->block_tail;
../../drivers/amdgpu/util/block_pool.c:    if (allocator->block_tail) {
../../drivers/amdgpu/util/block_pool.c:      allocator->block_tail->next = block;
../../drivers/amdgpu/util/block_pool.c:      allocator->block_head = block;
../../drivers/amdgpu/util/block_pool.c:    allocator->block_tail = block;
../../drivers/amdgpu/util/block_pool.c:    block->next = allocator->block_head;
../../drivers/amdgpu/util/block_pool.c:    block->prev = NULL;
../../drivers/amdgpu/util/block_pool.c:    if (allocator->block_head) {
../../drivers/amdgpu/util/block_pool.c:      allocator->block_head->prev = block;
../../drivers/amdgpu/util/block_pool.c:      allocator->block_tail = block;
../../drivers/amdgpu/util/block_pool.c:    allocator->block_head = block;
../../drivers/amdgpu/util/block_pool.c:  *out_ptr = (uint8_t*)block->ptr + page_index * allocator->page_size;
../../drivers/amdgpu/util/block_pool.c:  out_token->page_count = (uint64_t)page_count;
../../drivers/amdgpu/util/block_pool.c:  out_token->block = (uint64_t)block;
../../drivers/amdgpu/util/block_pool.c:      iree_host_size_ceil_div(size, allocator->page_size);
../../drivers/amdgpu/util/block_pool.c:  // path and dedicated allocations for high-frequency transient allocations are
../../drivers/amdgpu/util/block_pool.c:  if (page_count > allocator->page_count) {
../../drivers/amdgpu/util/block_pool.c:        page_count, size, allocator->page_count, allocator->page_size);
../../drivers/amdgpu/util/block_pool.c:  iree_slim_mutex_lock(&allocator->mutex);
../../drivers/amdgpu/util/block_pool.c:  iree_slim_mutex_unlock(&allocator->mutex);
../../drivers/amdgpu/util/block_pool.c:  const uint64_t byte_offset = (uint64_t)ptr - (uint64_t)block->ptr;
../../drivers/amdgpu/util/block_pool.c:  const iree_host_size_t page_index = byte_offset / allocator->page_size;
../../drivers/amdgpu/util/block_pool.c:      .bit_count = allocator->page_count,
../../drivers/amdgpu/util/block_pool.c:      .words = &block->user_data[0],
../../drivers/amdgpu/util/block_pool.c:  if (block->next) {
../../drivers/amdgpu/util/block_pool.c:    block->next->prev = block->prev;
../../drivers/amdgpu/util/block_pool.c:    allocator->block_tail = block->prev;
../../drivers/amdgpu/util/block_pool.c:  if (block->prev) {
../../drivers/amdgpu/util/block_pool.c:    block->prev->next = block->next;
../../drivers/amdgpu/util/block_pool.c:    allocator->block_head = block->next;
../../drivers/amdgpu/util/block_pool.c:  block->prev = block->next = NULL;
../../drivers/amdgpu/util/block_pool.c:    iree_hal_amdgpu_block_pool_release(allocator->block_pool, block);
../../drivers/amdgpu/util/block_pool.c:  // their scan. Or not - there's pathological cases where it'll just create
../../drivers/amdgpu/util/block_pool.c:  if (allocator->block_head) {
../../drivers/amdgpu/util/block_pool.c:    allocator->block_head->prev = block;
../../drivers/amdgpu/util/block_pool.c:    allocator->block_tail = block;
../../drivers/amdgpu/util/block_pool.c:  block->next = allocator->block_head;
../../drivers/amdgpu/util/block_pool.c:  allocator->block_head = block;
../../drivers/amdgpu/util/block_pool.c:  iree_slim_mutex_lock(&allocator->mutex);
../../drivers/amdgpu/util/block_pool.c:  iree_slim_mutex_unlock(&allocator->mutex);
../../drivers/amdgpu/util/info.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/util/info.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/info.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/info.c:                "only little-endian systems are supported "
../../drivers/amdgpu/util/info.c:                "only 64-bit systems are supported "
../../drivers/amdgpu/util/info.c:  out_info->svm_accessible_by_default = svm_accessible_by_default ? 1 : 0;
../../drivers/amdgpu/util/info.c:  out_info->dmabuf_supported = dmabuf_supported ? 1 : 0;
../../drivers/amdgpu/util/info.c:                               &out_info->timestamp_frequency),
../../drivers/amdgpu/util/device_library.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/util/device_library.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/device_library.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/device_library.h:// |libhsa| is captured by-reference and must remain valid for the lifetime of
../../drivers/amdgpu/util/device_library.h:  // Base pointer in the loaded code in device memory (agent-specific).
../../drivers/amdgpu/util/vmem.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/util/vmem.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/vmem.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/vmem.c:      IREE_LIBHSA(state->libhsa), memory_pool, HSA_AMD_MEMORY_POOL_INFO_SEGMENT,
../../drivers/amdgpu/util/vmem.c:  // matches the other flags. Workgroup-private pools won't have this set.
../../drivers/amdgpu/util/vmem.c:      IREE_LIBHSA(state->libhsa), memory_pool,
../../drivers/amdgpu/util/vmem.c:      IREE_LIBHSA(state->libhsa), memory_pool,
../../drivers/amdgpu/util/vmem.c:  if (global_flag & state->match_flags) {
../../drivers/amdgpu/util/vmem.c:    state->best_pool = memory_pool;
../../drivers/amdgpu/util/vmem.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/vmem.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/vmem.c:  out_ringbuffer->capacity = capacity;
../../drivers/amdgpu/util/vmem.c:          IREE_LIBHSA(libhsa), &out_ringbuffer->va_base_ptr, capacity * 3,
../../drivers/amdgpu/util/vmem.c:  out_ringbuffer->ring_base_ptr =
../../drivers/amdgpu/util/vmem.c:      (uint8_t*)out_ringbuffer->va_base_ptr + capacity;
../../drivers/amdgpu/util/vmem.c:      /*flags=*/0, &out_ringbuffer->alloc_handle);
../../drivers/amdgpu/util/vmem.c:      (uint8_t*)out_ringbuffer->va_base_ptr + 0 * capacity,
../../drivers/amdgpu/util/vmem.c:      (uint8_t*)out_ringbuffer->va_base_ptr + 1 * capacity,
../../drivers/amdgpu/util/vmem.c:      (uint8_t*)out_ringbuffer->va_base_ptr + 2 * capacity,
../../drivers/amdgpu/util/vmem.c:                              out_ringbuffer->alloc_handle, /*flags=*/0);
../../drivers/amdgpu/util/vmem.c:          topology->all_agent_count * sizeof(hsa_amd_memory_access_desc_t));
../../drivers/amdgpu/util/vmem.c:      for (iree_host_size_t i = 0; i < topology->all_agent_count; ++i) {
../../drivers/amdgpu/util/vmem.c:            .agent_handle = topology->all_agents[i],
../../drivers/amdgpu/util/vmem.c:      for (iree_host_size_t i = 0; i < topology->all_agent_count; ++i) {
../../drivers/amdgpu/util/vmem.c:        hsa_agent_t agent = topology->all_agents[i];
../../drivers/amdgpu/util/vmem.c:            .agent_handle = topology->all_agents[i],
../../drivers/amdgpu/util/vmem.c:      for (iree_host_size_t i = 0; i < topology->all_agent_count; ++i) {
../../drivers/amdgpu/util/vmem.c:        hsa_agent_t agent = topology->all_agents[i];
../../drivers/amdgpu/util/vmem.c:            .agent_handle = topology->all_agents[i],
../../drivers/amdgpu/util/vmem.c:  if (ringbuffer->alloc_handle.handle) {
../../drivers/amdgpu/util/vmem.c:        (uint8_t*)ringbuffer->va_base_ptr + 0 * ringbuffer->capacity,
../../drivers/amdgpu/util/vmem.c:        (uint8_t*)ringbuffer->va_base_ptr + 1 * ringbuffer->capacity,
../../drivers/amdgpu/util/vmem.c:        (uint8_t*)ringbuffer->va_base_ptr + 2 * ringbuffer->capacity,
../../drivers/amdgpu/util/vmem.c:          IREE_LIBHSA(libhsa), va_offsets[i], ringbuffer->capacity));
../../drivers/amdgpu/util/vmem.c:        IREE_LIBHSA(libhsa), ringbuffer->alloc_handle));
../../drivers/amdgpu/util/vmem.c:  if (ringbuffer->va_base_ptr) {
../../drivers/amdgpu/util/vmem.c:                                                     ringbuffer->va_base_ptr,
../../drivers/amdgpu/util/vmem.c:                                                     ringbuffer->capacity * 3));
../../drivers/amdgpu/util/vmem_test.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/util/vmem_test.cc://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/vmem_test.cc://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/vmem_test.cc://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/vmem_test.cc://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/vmem_test.cc:  EXPECT_EQ(ptr[-1], ptr[capacity_u32 - 1]);
../../drivers/amdgpu/util/vmem.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/util/vmem.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/vmem.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/vmem.h:// Finds a coarse-grained memory pool on the |agent|.
../../drivers/amdgpu/util/vmem.h:// Finds a fine-grained memory pool on the |agent|.
../../drivers/amdgpu/util/vmem.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/vmem.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/vmem.h:// approach documented in https://lo.calho.st/posts/black-magic-buffer/ and
../../drivers/amdgpu/util/vmem.h:// https://www.mikeash.com/pyblog/friday-qa-2012-02-17-ring-buffers-and-mirrored-memory-part-ii.html
../../drivers/amdgpu/util/vmem.h:// https://github.com/google/wuffs/blob/main/script/mmap-ring-buffer.c
../../drivers/amdgpu/util/vmem.h://   physical: <ringbuffer size> --+------+------+
../../drivers/amdgpu/util/vmem.h://                                 |      +-- ring_base_ptr
../../drivers/amdgpu/util/vmem.h://                                 +--------- va_base_ptr
../../drivers/amdgpu/util/vmem.h:// least the requested power-of-two |min_capacity| with at least
../../drivers/amdgpu/util/topology.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/util/topology.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/topology.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/topology.h:// represent with a 64-bit bitfield avoids the need for a substantial number of
../../drivers/amdgpu/util/topology.h:// instead of cores/etc within those nodes we'll need a 64-socket NUMA machine
../../drivers/amdgpu/util/topology.h:// We could support a mix and pick the lowest-common-denominator so long as all
../../drivers/amdgpu/util/topology.h:// ISAs are compatible - several place in the code querying agent properties
../../drivers/amdgpu/util/topology.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/topology.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/topology.h:// https://rocm.docs.amd.com/en/latest/conceptual/gpu-isolation.html
../../drivers/amdgpu/util/topology.h://  $ export ROCR_VISIBLE_DEVICES="0,GPU-DEADBEEFDEADBEEF"
../../drivers/amdgpu/util/topology.h:// Supported identifiers are `GPU-0e12865a3bf5b7ab`-style IDs (matching
../../drivers/amdgpu/util/topology.h:// Note that system-level variables like `ROCR_VISIBLE_DEVICES` will still
../../drivers/amdgpu/util/bitmap.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/util/bitmap.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/bitmap.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/bitmap.h:// Reference to a bitmap stored in 64-bit words.
../../drivers/amdgpu/util/libhsa.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/util/libhsa.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/libhsa.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/libhsa.c:             "or create internal OS-specific events.";
../../drivers/amdgpu/util/libhsa.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/libhsa.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/libhsa.c:      library, #symbol, (void**)&out_libhsa->symbol));
../../drivers/amdgpu/util/libhsa.c:// TODO(benvanik): move someplace central - status and string_builder have a
../../drivers/amdgpu/util/libhsa.c:    "hsa-runtime64.dll",
../../drivers/amdgpu/util/libhsa.c:    "libhsa-runtime64.so",
../../drivers/amdgpu/util/libhsa.c:  // we do that locally in a heap-allocated NUL-terminated string builder.
../../drivers/amdgpu/util/libhsa.c:    // User provided a filename - try to use it directly. If it's an absolute
../../drivers/amdgpu/util/libhsa.c:  out_libhsa->library = NULL;
../../drivers/amdgpu/util/libhsa.c:                         "HSA/ROCR-Runtime library not found; ensure it is "
../../drivers/amdgpu/util/libhsa.c:    if (!iree_status_is_ok(status) && out_libhsa->hsa_init) {
../../drivers/amdgpu/util/libhsa.c:          out_libhsa->hsa_init, &annotation_builder));
../../drivers/amdgpu/util/libhsa.c:    out_libhsa->library = library;
../../drivers/amdgpu/util/libhsa.c:  iree_dynamic_library_release(libhsa->library);
../../drivers/amdgpu/util/libhsa.c:  iree_dynamic_library_retain(out_libhsa->library);
../../drivers/amdgpu/util/libhsa.c:  return iree_dynamic_library_append_symbol_path_to_builder(libhsa->hsa_init,
../../drivers/amdgpu/util/libhsa.c:  // In static compilation mode this is a no-op.
../../drivers/amdgpu/util/libhsa.c:      out_libhsa->initialized = true;
../../drivers/amdgpu/util/libhsa.c:            sizeof(out_libhsa->amd_loader), &out_libhsa->amd_loader),
../../drivers/amdgpu/util/libhsa.c:  // Decrement HSA ref count; others may still have it loaded/in-use.
../../drivers/amdgpu/util/libhsa.c:  if (libhsa->initialized) {
../../drivers/amdgpu/util/libhsa.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/libhsa.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/libhsa.c:#define IREE_HAL_AMDGPU_LIBHSA_LIBPTR(libhsa) (libhsa)->
../../drivers/amdgpu/util/libhsa.c:// If we wanted to statically link HSA we could use this mechanism to re-route
../../drivers/amdgpu/util/libhsa.c:// value. These are usually high-frequency operations like signals.
../../drivers/amdgpu/util/libhsa.c:// status value. These are usually high-frequency operations like signals.
../../drivers/amdgpu/util/block_pool_test.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/util/block_pool_test.cc://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/block_pool_test.cc://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/block_pool_test.cc:  EXPECT_NE(block0->ptr, nullptr);
../../drivers/amdgpu/util/block_pool_test.cc:  EXPECT_EQ(block0->next, nullptr);
../../drivers/amdgpu/util/block_pool_test.cc:  EXPECT_NE(block1->ptr, nullptr);
../../drivers/amdgpu/util/block_pool_test.cc:  EXPECT_NE(block1->ptr, block0->ptr);
../../drivers/amdgpu/util/block_pool_test.cc:  EXPECT_EQ(block1->next, nullptr);
../../drivers/amdgpu/util/block_pool_test.cc:  EXPECT_NE(block0->ptr, nullptr);
../../drivers/amdgpu/util/block_pool_test.cc:  EXPECT_EQ(block0->next, nullptr);
../../drivers/amdgpu/util/block_pool_test.cc:  // Fail if block size is not a power-of-two.
../../drivers/amdgpu/util/block_pool_test.cc:  // Link together: block0 -> block1 -> block2
../../drivers/amdgpu/util/block_pool_test.cc:  block0->next = block1;
../../drivers/amdgpu/util/block_pool_test.cc:  block1->next = block2;
../../drivers/amdgpu/util/block_pool_test.cc:  block2->next = NULL;
../../drivers/amdgpu/util/block_pool_test.cc:    // batches[1] = all but one allocated - release only the last.
../../drivers/amdgpu/util/block_pool_test.cc:    // batches[2] = only one allocated - release all but the first.
../../drivers/amdgpu/util/block_pool_test.cc:    for (iree_host_size_t i = 0; i < batches[2].blocks.size() - 1; ++i) {
../../drivers/amdgpu/util/block_pool_test.cc:    // batches[3] = none allocated - release all.
../../drivers/amdgpu/util/block_pool_test.cc:  // Trim now - we should only drop one allocation for batches[3] that has
../../drivers/amdgpu/util/block_pool_test.cc:  // Acquire a new block - should use something we have in the pool. This is
../../drivers/amdgpu/util/block_pool_test.cc:  EXPECT_NE(block0->ptr, nullptr);
../../drivers/amdgpu/util/block_pool_test.cc:  EXPECT_EQ(block0->next, nullptr);
../../drivers/amdgpu/util/block_pool_test.cc:  EXPECT_NE(block1->ptr, nullptr);
../../drivers/amdgpu/util/block_pool_test.cc:  EXPECT_EQ(block1->next, nullptr);
../../drivers/amdgpu/util/block_pool_test.cc://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/block_pool_test.cc://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/block_pool_test.cc:  EXPECT_NE(block0->next, nullptr);
../../drivers/amdgpu/util/block_pool_test.cc:  EXPECT_EQ(block0->prev, nullptr);
../../drivers/amdgpu/util/block_pool_test.cc:  iree_hal_amdgpu_block_t* block1 = block0->next;
../../drivers/amdgpu/util/block_pool_test.cc:  EXPECT_NE(block1->next, nullptr);
../../drivers/amdgpu/util/block_pool_test.cc:  EXPECT_EQ(block1->prev, block0);
../../drivers/amdgpu/util/block_pool_test.cc:  iree_hal_amdgpu_block_t* block2 = block1->next;
../../drivers/amdgpu/util/block_pool_test.cc:  EXPECT_EQ(block2->next, nullptr);
../../drivers/amdgpu/util/block_pool_test.cc:  EXPECT_EQ(block2->prev, block1);
../../drivers/amdgpu/util/block_pool_test.cc://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/block_pool_test.cc://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/block_pool_test.cc:  // Fail if the page size is not a power-of-two.
../../drivers/amdgpu/util/block_pool_test.cc:  // Allow no-op frees of NULL pointers (here just testing for segfaults).
../../drivers/amdgpu/util/block_pool_test.cc:  // Trim the block pool - the allocator should have returned the block on the
../../drivers/amdgpu/util/block_pool_test.cc:      &allocator, (allocator.page_count - 1) * allocator.page_size, &ptr0,
../../drivers/amdgpu/util/block_pool_test.cc:      &allocator, (allocator.page_count - 1) * allocator.page_size, &ptr1,
../../drivers/amdgpu/util/libhsa_tables.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/util/libhsa_tables.h:// These declarations come from the ROCR-Runtime public headers:
../../drivers/amdgpu/util/libhsa_tables.h:// https://github.com/ROCm/ROCR-Runtime/tree/amd-staging/runtime/hsa-runtime/inc
../../drivers/amdgpu/util/libhsa_tables.h:// https://github.com/ROCm/ROCR-Runtime/blob/amd-staging/runtime/hsa-runtime/inc/hsa.h
../../drivers/amdgpu/util/libhsa_tables.h:// https://github.com/ROCm/ROCR-Runtime/blob/amd-staging/runtime/hsa-runtime/inc/hsa_ext_amd.h
../../drivers/amdgpu/util/libhsa_tables.h:// https://github.com/ROCm/ROCR-Runtime/blob/amd-staging/runtime/hsa-runtime/inc/hsa_ven_amd_loader.h
../../drivers/amdgpu/util/libhsa_tables.h:// TODO(benvanik): prune this to what we actually use - it's quite exhaustive
../../drivers/amdgpu/util/libhsa_tables.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/libhsa_tables.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/libhsa_tables.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/libhsa_tables.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/libhsa_tables.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/libhsa_tables.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/libhsa_tables.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/libhsa_tables.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/libhsa_tables.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/libhsa_tables.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/libhsa_tables.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/libhsa_tables.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/kfd.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/util/kfd.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/kfd.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/kfd.c:  if (fd == -1) {
../../drivers/amdgpu/util/kfd.c:  } while (ret == -1 && (errno == EINTR || errno == EAGAIN));
../../drivers/amdgpu/util/kfd.c:  return -1;
../../drivers/amdgpu/util/kfd.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/kfd.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/kfd.c:  out_counters->gpu_clock_counter = args.gpu_clock_counter;
../../drivers/amdgpu/util/kfd.c:  out_counters->cpu_clock_counter = args.cpu_clock_counter;
../../drivers/amdgpu/util/kfd.c:  out_counters->system_clock_counter = args.system_clock_counter;
../../drivers/amdgpu/util/kfd.c:  out_counters->system_clock_freq = args.system_clock_freq;
../../drivers/amdgpu/util/info.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/util/info.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/info.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/bitmap_test.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/util/bitmap_test.cc:                "assumes 64-bit words");
../../drivers/amdgpu/util/bitmap_test.cc:  iree_hal_amdgpu_bitmap_set_all(bitmap);           // no-op
../../drivers/amdgpu/util/bitmap_test.cc:  iree_hal_amdgpu_bitmap_reset_all(bitmap);         // no-op
../../drivers/amdgpu/util/bitmap_test.cc:  iree_hal_amdgpu_bitmap_set_span(bitmap, 0, 0);    // no-op
../../drivers/amdgpu/util/bitmap_test.cc:  iree_hal_amdgpu_bitmap_reset_span(bitmap, 0, 0);  // no-op
../../drivers/amdgpu/util/bitmap_test.cc:  EXPECT_EQ(words[1], 1ull << (73 - 64));
../../drivers/amdgpu/util/bitmap_test.cc:  iree_hal_amdgpu_bitmap_set_span(bitmap, 0, 64 + 10 - 1);
../../drivers/amdgpu/util/bitmap_test.cc:  iree_hal_amdgpu_bitmap_set_span(bitmap, 64 + 10 - 1, 1);
../../drivers/amdgpu/util/bitmap_test.cc:  EXPECT_EQ(words[1], 1ull << (73 - 64));
../../drivers/amdgpu/util/bitmap_test.cc:  iree_hal_amdgpu_bitmap_reset_span(bitmap, 0, 64 + 10 - 1);
../../drivers/amdgpu/util/bitmap_test.cc:  iree_hal_amdgpu_bitmap_reset_span(bitmap, 64 + 10 - 1, 1);
../../drivers/amdgpu/util/bitmap_test.cc:                                                         bitmap.bit_count - 10),
../../drivers/amdgpu/util/bitmap_test.cc:                bitmap, bit_index, bitmap.bit_count - bit_index - 1),
../../drivers/amdgpu/util/bitmap_test.cc:                bitmap, bit_index, bitmap.bit_count - bit_index - 1),
../../drivers/amdgpu/util/bitmap_test.cc:                bitmap, bit_index, bitmap.bit_count - bit_index - 1),
../../drivers/amdgpu/util/bitmap_test.cc:                bitmap, bit_index, bitmap.bit_count - bit_index - 1),
../../drivers/amdgpu/util/libhsa_test.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/util/device_library_test.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/util/device_library_test.cc:    // Code range should be non-zero and somewhere in the process address space.
../../drivers/amdgpu/util/error_callback.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/util/error_callback.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/error_callback.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/error_callback.h:// WARNING: this may be called from arbitrary driver threads and any non-const
../../drivers/amdgpu/util/error_callback.h:// disallowed. Implementations should stash the status in a thread-safe manner
../../drivers/vulkan/direct_command_queue.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/util/topology.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/util/topology.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/topology.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/topology.c:  out_topology->gpu_agent_queue_count = 1;
../../drivers/amdgpu/util/topology.c:  for (iree_host_size_t i = 0; i < topology->cpu_agent_count; ++i) {
../../drivers/amdgpu/util/topology.c:    if (topology->cpu_agents[i].handle == cpu_agent.handle) {
../../drivers/amdgpu/util/topology.c:  if (topology->cpu_agent_count + 1 >= IREE_ARRAYSIZE(topology->cpu_agents)) {
../../drivers/amdgpu/util/topology.c:                            IREE_ARRAYSIZE(topology->cpu_agents));
../../drivers/amdgpu/util/topology.c:  iree_host_size_t cpu_agent_index = topology->cpu_agent_count++;
../../drivers/amdgpu/util/topology.c:  topology->cpu_agents[cpu_agent_index] = cpu_agent;
../../drivers/amdgpu/util/topology.c:  topology->all_agents[topology->all_agent_count++] = cpu_agent;
../../drivers/amdgpu/util/topology.c:  for (iree_host_size_t i = 0; i < topology->gpu_agent_count; ++i) {
../../drivers/amdgpu/util/topology.c:    if (topology->gpu_agents[i].handle == gpu_agent.handle) {
../../drivers/amdgpu/util/topology.c:  if (topology->gpu_agent_count + 1 >= IREE_ARRAYSIZE(topology->gpu_agents)) {
../../drivers/amdgpu/util/topology.c:                            IREE_ARRAYSIZE(topology->gpu_agents));
../../drivers/amdgpu/util/topology.c:  iree_host_size_t gpu_agent_index = topology->gpu_agent_count++;
../../drivers/amdgpu/util/topology.c:  topology->gpu_agents[gpu_agent_index] = gpu_agent;
../../drivers/amdgpu/util/topology.c:  topology->all_agents[topology->all_agent_count++] = gpu_agent;
../../drivers/amdgpu/util/topology.c:  // Update the GPU->CPU agent mapping.
../../drivers/amdgpu/util/topology.c:  topology->gpu_cpu_map[gpu_agent_index] = (uint8_t)cpu_agent_index;
../../drivers/amdgpu/util/topology.c:  // Device names must match (same device) - note that they may still be
../../drivers/amdgpu/util/topology.c:  // different revisions as this is just a human-friendly name.
../../drivers/amdgpu/util/topology.c:      if (topology->cpu_agent_count == 0) {
../../drivers/amdgpu/util/topology.c:      return iree_hal_amdgpu_compare_cpu_agents(libhsa, topology->cpu_agents[0],
../../drivers/amdgpu/util/topology.c:      if (topology->gpu_agent_count == 0) {
../../drivers/amdgpu/util/topology.c:      return iree_hal_amdgpu_compare_gpu_agents(libhsa, topology->gpu_agents[0],
../../drivers/amdgpu/util/topology.c:  if (topology->cpu_agent_count == 0 || topology->gpu_agent_count == 0 ||
../../drivers/amdgpu/util/topology.c:      topology->gpu_agent_queue_count == 0) {
../../drivers/amdgpu/util/topology.c:        topology->cpu_agent_count, topology->gpu_agent_count,
../../drivers/amdgpu/util/topology.c:        topology->gpu_agent_queue_count);
../../drivers/amdgpu/util/topology.c:  for (iree_host_size_t i = 1; i < topology->cpu_agent_count; ++i) {
../../drivers/amdgpu/util/topology.c:        libhsa, topology->cpu_agents[0], topology->cpu_agents[i],
../../drivers/amdgpu/util/topology.c:  for (iree_host_size_t i = 1; i < topology->gpu_agent_count; ++i) {
../../drivers/amdgpu/util/topology.c:        libhsa, topology->gpu_agents[0], topology->gpu_agents[i],
../../drivers/amdgpu/util/topology.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/topology.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/topology.c:  if (agents->all_agent_count == IREE_ARRAYSIZE(agents->all_agents)) {
../../drivers/amdgpu/util/topology.c:  agents->all_agents[agents->all_agent_count++] = agent;
../../drivers/amdgpu/util/topology.c:  for (iree_host_size_t i = 0; i < out_agents->all_agent_count; ++i) {
../../drivers/amdgpu/util/topology.c:        iree_hsa_agent_get_info(IREE_LIBHSA(libhsa), out_agents->all_agents[i],
../../drivers/amdgpu/util/topology.c:        if (out_agents->cpu_agent_count ==
../../drivers/amdgpu/util/topology.c:            IREE_ARRAYSIZE(out_agents->cpu_agents)) {
../../drivers/amdgpu/util/topology.c:                                  IREE_ARRAYSIZE(out_agents->cpu_agents));
../../drivers/amdgpu/util/topology.c:        out_agents->cpu_agents[out_agents->cpu_agent_count++] =
../../drivers/amdgpu/util/topology.c:            out_agents->all_agents[i];
../../drivers/amdgpu/util/topology.c:        if (out_agents->gpu_agent_count ==
../../drivers/amdgpu/util/topology.c:            IREE_ARRAYSIZE(out_agents->gpu_agents)) {
../../drivers/amdgpu/util/topology.c:                                  IREE_ARRAYSIZE(out_agents->gpu_agents));
../../drivers/amdgpu/util/topology.c:        out_agents->gpu_agents[out_agents->gpu_agent_count++] =
../../drivers/amdgpu/util/topology.c:            out_agents->all_agents[i];
../../drivers/amdgpu/util/topology.c:// Returns the ordinal of the GPU agent with the given `GPU-XX` "UUID".
../../drivers/amdgpu/util/topology.c:  *out_ordinal = -1;
../../drivers/amdgpu/util/topology.c:  for (iree_host_size_t i = 0; i < agents->gpu_agent_count; ++i) {
../../drivers/amdgpu/util/topology.c:        IREE_LIBHSA(libhsa), agents->gpu_agents[i],
../../drivers/amdgpu/util/topology.c:    if (iree_string_view_starts_with(fragment, IREE_SV("GPU-"))) {
../../drivers/amdgpu/util/topology.c:                             "ordinal (`0`) or a device UUID (`GPU-XX...`)",
../../drivers/amdgpu/buffer_pool.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/buffer_pool.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/buffer_pool.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/buffer_pool.c:// device-visible memory for the device-side library resources.
../../drivers/amdgpu/buffer_pool.c:// Thread-safe; each block has its own lock for free list management.
../../drivers/amdgpu/buffer_pool.c:      capacity * sizeof(block->free_list[0]);
../../drivers/amdgpu/buffer_pool.c:      z0, iree_allocator_malloc(buffer_pool->host_allocator, total_block_size,
../../drivers/amdgpu/buffer_pool.c:  block->buffer_pool = buffer_pool;
../../drivers/amdgpu/buffer_pool.c:  block->prev_block = NULL;
../../drivers/amdgpu/buffer_pool.c:  block->next_block = NULL;
../../drivers/amdgpu/buffer_pool.c:  block->next_free = NULL;
../../drivers/amdgpu/buffer_pool.c:  block->capacity = capacity;
../../drivers/amdgpu/buffer_pool.c:  block->device_allocation_ptr = NULL;
../../drivers/amdgpu/buffer_pool.c:  iree_slim_mutex_initialize(&block->mutex);
../../drivers/amdgpu/buffer_pool.c:      IREE_LIBHSA(buffer_pool->libhsa), buffer_pool->memory_pool,
../../drivers/amdgpu/buffer_pool.c:      (void**)&block->device_allocation_ptr);
../../drivers/amdgpu/buffer_pool.c:        IREE_LIBHSA(buffer_pool->libhsa),
../../drivers/amdgpu/buffer_pool.c:        buffer_pool->topology->all_agent_count,
../../drivers/amdgpu/buffer_pool.c:        buffer_pool->topology->all_agents, /*flags=*/NULL,
../../drivers/amdgpu/buffer_pool.c:        block->device_allocation_ptr);
../../drivers/amdgpu/buffer_pool.c:            block->device_allocation_ptr;
../../drivers/amdgpu/buffer_pool.c:    block->free_count = capacity;
../../drivers/amdgpu/buffer_pool.c:          buffer_pool->placement, handle, release_callback, buffer);
../../drivers/amdgpu/buffer_pool.c:      block->free_list[i] = buffer;
../../drivers/amdgpu/buffer_pool.c:  iree_slim_mutex_lock(&block->mutex);
../../drivers/amdgpu/buffer_pool.c:  IREE_ASSERT_EQ(block->free_count, block->capacity);
../../drivers/amdgpu/buffer_pool.c:  iree_slim_mutex_unlock(&block->mutex);
../../drivers/amdgpu/buffer_pool.c:                                            block->capacity *
../../drivers/amdgpu/buffer_pool.c:                                                sizeof(block->free_list[0]));
../../drivers/amdgpu/buffer_pool.c:  for (iree_host_size_t i = 0; i < block->capacity; ++i) {
../../drivers/amdgpu/buffer_pool.c:  if (block->device_allocation_ptr) {
../../drivers/amdgpu/buffer_pool.c:        IREE_LIBHSA(block->buffer_pool->libhsa), block->device_allocation_ptr));
../../drivers/amdgpu/buffer_pool.c:    block->device_allocation_ptr = NULL;
../../drivers/amdgpu/buffer_pool.c:  iree_slim_mutex_deinitialize(&block->mutex);
../../drivers/amdgpu/buffer_pool.c:  iree_allocator_free(block->buffer_pool->host_allocator, block);
../../drivers/amdgpu/buffer_pool.c:  IREE_ASSERT_REF_COUNT_ZERO(&base_buffer->resource.ref_count);
../../drivers/amdgpu/buffer_pool.c:  iree_slim_mutex_lock(&block->mutex);
../../drivers/amdgpu/buffer_pool.c:  const bool full_to_free = block->free_count == 0;
../../drivers/amdgpu/buffer_pool.c:  block->free_list[block->free_count++] = buffer;
../../drivers/amdgpu/buffer_pool.c:  iree_slim_mutex_unlock(&block->mutex);
../../drivers/amdgpu/buffer_pool.c:  // NOTE: this happens outside of the per-block lock as the pool will hold its
../../drivers/amdgpu/buffer_pool.c:    iree_hal_amdgpu_buffer_pool_link_free_block(block->buffer_pool, block);
../../drivers/amdgpu/buffer_pool.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/buffer_pool.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/buffer_pool.c:  out_buffer_pool->libhsa = libhsa;
../../drivers/amdgpu/buffer_pool.c:  out_buffer_pool->topology = topology;
../../drivers/amdgpu/buffer_pool.c:  out_buffer_pool->placement = placement;
../../drivers/amdgpu/buffer_pool.c:  out_buffer_pool->host_allocator = host_allocator;
../../drivers/amdgpu/buffer_pool.c:  out_buffer_pool->memory_pool = memory_pool;
../../drivers/amdgpu/buffer_pool.c:  out_buffer_pool->pool = 0;
../../drivers/amdgpu/buffer_pool.c:  iree_slim_mutex_initialize(&out_buffer_pool->mutex);
../../drivers/amdgpu/buffer_pool.c:  out_buffer_pool->list_head = NULL;
../../drivers/amdgpu/buffer_pool.c:  out_buffer_pool->free_head = NULL;
../../drivers/amdgpu/buffer_pool.c:  out_buffer_pool->block_capacity = capacity_per_allocation;
../../drivers/amdgpu/buffer_pool.c:  iree_slim_mutex_lock(&buffer_pool->mutex);
../../drivers/amdgpu/buffer_pool.c:  iree_hal_amdgpu_buffer_pool_block_t* block = buffer_pool->list_head;
../../drivers/amdgpu/buffer_pool.c:    iree_hal_amdgpu_buffer_pool_block_t* next_block = block->next_block;
../../drivers/amdgpu/buffer_pool.c:    IREE_ASSERT_EQ(block->free_count, block->capacity);
../../drivers/amdgpu/buffer_pool.c:  buffer_pool->list_head = NULL;
../../drivers/amdgpu/buffer_pool.c:  buffer_pool->free_head = NULL;
../../drivers/amdgpu/buffer_pool.c:  iree_slim_mutex_unlock(&buffer_pool->mutex);
../../drivers/amdgpu/buffer_pool.c:  iree_slim_mutex_deinitialize(&buffer_pool->mutex);
../../drivers/amdgpu/buffer_pool.c:              buffer_pool, buffer_pool->block_capacity, &block));
../../drivers/amdgpu/buffer_pool.c:  block->prev_block = NULL;
../../drivers/amdgpu/buffer_pool.c:  block->next_block = buffer_pool->list_head;
../../drivers/amdgpu/buffer_pool.c:  if (block->next_block) {
../../drivers/amdgpu/buffer_pool.c:    block->next_block->prev_block = block;
../../drivers/amdgpu/buffer_pool.c:  buffer_pool->list_head = block;
../../drivers/amdgpu/buffer_pool.c:  block->next_free = buffer_pool->free_head;
../../drivers/amdgpu/buffer_pool.c:  buffer_pool->free_head = block;
../../drivers/amdgpu/buffer_pool.c:        iree_host_size_ceil_div(count, buffer_pool->block_capacity);
../../drivers/amdgpu/buffer_pool.c:  iree_slim_mutex_lock(&buffer_pool->mutex);
../../drivers/amdgpu/buffer_pool.c:  if (buffer_pool->free_head == NULL) {
../../drivers/amdgpu/buffer_pool.c:    iree_hal_amdgpu_buffer_pool_block_t* block = buffer_pool->free_head;
../../drivers/amdgpu/buffer_pool.c:    buffer = block->free_list[block->free_count - 1];
../../drivers/amdgpu/buffer_pool.c:    block->free_list[block->free_count - 1] = NULL;
../../drivers/amdgpu/buffer_pool.c:    --block->free_count;
../../drivers/amdgpu/buffer_pool.c:    if (block->free_count == 0) {
../../drivers/amdgpu/buffer_pool.c:      buffer_pool->free_head = block->next_free;
../../drivers/amdgpu/buffer_pool.c:      block->next_free = NULL;
../../drivers/amdgpu/buffer_pool.c:  iree_slim_mutex_unlock(&buffer_pool->mutex);
../../drivers/amdgpu/buffer_pool.c:    iree_atomic_ref_count_inc(&buffer->base.resource.ref_count);
../../drivers/amdgpu/buffer_pool.c:    *out_buffer = &buffer->base;
../../drivers/amdgpu/buffer_pool.c:    *out_handle = buffer->handle;
../../drivers/amdgpu/buffer_pool.c:  iree_slim_mutex_lock(&buffer_pool->mutex);
../../drivers/amdgpu/buffer_pool.c:  block->next_free = buffer_pool->free_head;
../../drivers/amdgpu/buffer_pool.c:  buffer_pool->free_head = block;
../../drivers/amdgpu/buffer_pool.c:  iree_slim_mutex_unlock(&buffer_pool->mutex);
../../drivers/amdgpu/buffer_pool.c:  iree_slim_mutex_lock(&buffer_pool->mutex);
../../drivers/amdgpu/buffer_pool.c:  iree_hal_amdgpu_buffer_pool_block_t* block = buffer_pool->free_head;
../../drivers/amdgpu/buffer_pool.c:    iree_hal_amdgpu_buffer_pool_block_t* next_block = block->next_free;
../../drivers/amdgpu/buffer_pool.c:    if (block->free_count != block->capacity) {
../../drivers/amdgpu/buffer_pool.c:      // One or more buffers in use - cannot free the block.
../../drivers/amdgpu/buffer_pool.c:      prev_block->next_free = next_block;
../../drivers/amdgpu/buffer_pool.c:      buffer_pool->free_head = next_block;
../../drivers/amdgpu/buffer_pool.c:    if (block->prev_block != NULL) {
../../drivers/amdgpu/buffer_pool.c:      block->prev_block->next_block = block->next_block;
../../drivers/amdgpu/buffer_pool.c:      buffer_pool->list_head = block->next_block;
../../drivers/amdgpu/buffer_pool.c:    if (block->next_block != NULL) {
../../drivers/amdgpu/buffer_pool.c:      block->next_block->prev_block = block->prev_block;
../../drivers/amdgpu/buffer_pool.c:  iree_slim_mutex_unlock(&buffer_pool->mutex);
../../drivers/amdgpu/device_queue.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/device_queue.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device_queue.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device_queue.c:  IREE_ASSERT_EQ(options->placement, IREE_HAL_AMDGPU_QUEUE_PLACEMENT_DEVICE);
../../drivers/amdgpu/device_queue.c:      IREE_STATUS_UNIMPLEMENTED, "device-side queuing not yet implemented");
../../drivers/amdgpu/device/kernels.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/device/kernels.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/kernels.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/executable.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/executable.c:// TODO(benvanik): replace with include when device-side tracing imported.
../../drivers/amdgpu/executable.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/executable.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/executable.c:  if (isas->count >= IREE_ARRAYSIZE(isas->values)) {
../../drivers/amdgpu/executable.c:  isas->values[isas->count++] = isa;
../../drivers/amdgpu/executable.c:  if (topology->gpu_agent_count == 1) return iree_ok_status();
../../drivers/amdgpu/executable.c:              IREE_LIBHSA(libhsa), topology->gpu_agents[0],
../../drivers/amdgpu/executable.c:  for (iree_host_size_t i = 1; i < topology->gpu_agent_count; ++i) {
../../drivers/amdgpu/executable.c:                IREE_LIBHSA(libhsa), topology->gpu_agents[i],
../../drivers/amdgpu/executable.c:  if (out_isa) out_isa->handle = 0;
../../drivers/amdgpu/executable.c:  // Strip hsa-* prefix.
../../drivers/amdgpu/executable.c:          format, iree_make_cstring_view("amdgcn-amd-amdhsa-"))) {
../../drivers/amdgpu/executable.c:    // Not HSA-like.
../../drivers/amdgpu/executable.c:    // Get the ISA name - it'll be something like `amdgcn-amd-amdhsa--gfx1100`
../../drivers/amdgpu/executable.c:    // doesn't include the NUL terminator but it definitely does - for our
../../drivers/amdgpu/executable.c:        iree_make_string_view(isa_name_buffer, isa_name_length - /*NUL*/ 1);
../../drivers/amdgpu/executable.c:  if (out_isa) out_isa->handle = 0;
../../drivers/amdgpu/executable.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/executable.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/executable.c:                                    &out_limits->max_workgroup_size));
../../drivers/amdgpu/executable.c:                                    &out_limits->max_workgroup_size_per_dim));
../../drivers/amdgpu/executable.c:  // Run flatcc generated verification. This ensures all pointers are in-bounds
../../drivers/amdgpu/executable.c:      if (workgroup_size->x > limits->max_workgroup_size_per_dim[0] ||
../../drivers/amdgpu/executable.c:          workgroup_size->y > limits->max_workgroup_size_per_dim[1] ||
../../drivers/amdgpu/executable.c:          workgroup_size->z > limits->max_workgroup_size_per_dim[2]) {
../../drivers/amdgpu/executable.c:            i, workgroup_size->x, workgroup_size->y, workgroup_size->z,
../../drivers/amdgpu/executable.c:            limits->max_workgroup_size_per_dim[0],
../../drivers/amdgpu/executable.c:            limits->max_workgroup_size_per_dim[1],
../../drivers/amdgpu/executable.c:            limits->max_workgroup_size_per_dim[2]);
../../drivers/amdgpu/executable.c:          workgroup_size->x * workgroup_size->y * workgroup_size->z;
../../drivers/amdgpu/executable.c:      if (total_workgroup_size > limits->max_workgroup_size) {
../../drivers/amdgpu/executable.c:            i, total_workgroup_size, limits->max_workgroup_size);
../../drivers/amdgpu/executable.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/executable.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/executable.c:  if (executable_params->constant_count != 0) {
../../drivers/amdgpu/executable.c:       iree_status_is_ok(status) && i < topology->gpu_agent_count; ++i) {
../../drivers/amdgpu/executable.c:        IREE_LIBHSA(libhsa), handle, topology->gpu_agents[i],
../../drivers/amdgpu/executable.c:  out_kernel_args->setup = 3 << HSA_KERNEL_DISPATCH_PACKET_SETUP_DIMENSIONS;
../../drivers/amdgpu/executable.c:  out_kernel_args->workgroup_size[0] = workgroup_size->x;
../../drivers/amdgpu/executable.c:  out_kernel_args->workgroup_size[1] = workgroup_size->y;
../../drivers/amdgpu/executable.c:  out_kernel_args->workgroup_size[2] = workgroup_size->z;
../../drivers/amdgpu/executable.c:  // NOTE: the object pointer is per-device and we populate that when uploading
../../drivers/amdgpu/executable.c:  out_kernel_args->kernel_object = 0;
../../drivers/amdgpu/executable.c:              &out_kernel_args->private_segment_size));
../../drivers/amdgpu/executable.c:              &out_kernel_args->group_segment_size));
../../drivers/amdgpu/executable.c:              &out_kernel_args->kernarg_size));
../../drivers/amdgpu/executable.c:              &out_kernel_args->kernarg_alignment));
../../drivers/amdgpu/executable.c:  out_kernel_args->binding_count =
../../drivers/amdgpu/executable.c:  out_kernel_args->constant_count =
../../drivers/amdgpu/executable.c:  out_kernel_args->trace_src_loc = (uint64_t)export_loc;
../../drivers/amdgpu/executable.c:    export_loc->name = NULL;  // not needed
../../drivers/amdgpu/executable.c:    export_loc->function = char_buffer;
../../drivers/amdgpu/executable.c:      export_loc->file = char_buffer;
../../drivers/amdgpu/executable.c:      export_loc->line = iree_hal_debug_FileLineLocDef_line_get(loc_def);
../../drivers/amdgpu/executable.c:    export_loc->color = 0;
../../drivers/amdgpu/executable.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/executable.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/executable.c:  // host-side command buffer recording doesn't need to access device memory.
../../drivers/amdgpu/executable.c:  // The kernel object specified in each is invalid as it's agent-specific.
../../drivers/amdgpu/executable.c:  // TODO(benvanik): use executable_params->queue_affinity instead of the raw
../../drivers/amdgpu/executable.c:  // topology - the affinity will tell us exactly which physical devices we need
../../drivers/amdgpu/executable.c:  IREE_ASSERT_GE(topology->gpu_agent_count, 1);
../../drivers/amdgpu/executable.c:  if (IREE_UNLIKELY(topology->gpu_agent_count == 0)) {
../../drivers/amdgpu/executable.c:  hsa_agent_t any_device_agent = topology->gpu_agents[0];
../../drivers/amdgpu/executable.c:              libhsa, any_device_agent, executable_params->executable_format,
../../drivers/amdgpu/executable.c:                             (int)executable_params->executable_format.size,
../../drivers/amdgpu/executable.c:                             executable_params->executable_format.data));
../../drivers/amdgpu/executable.c:              executable_params->executable_data, &limits));
../../drivers/amdgpu/executable.c:          executable_params->executable_data.data);
../../drivers/amdgpu/executable.c:      export_count * sizeof(executable->host_kernel_args[0]) +
../../drivers/amdgpu/executable.c:      topology->gpu_agent_count * sizeof(executable->device_kernel_args[0]);
../../drivers/amdgpu/executable.c:                               &executable->resource);
../../drivers/amdgpu/executable.c:  executable->host_allocator = host_allocator;
../../drivers/amdgpu/executable.c:  executable->libhsa = libhsa;
../../drivers/amdgpu/executable.c:  executable->kernel_count = export_count;
../../drivers/amdgpu/executable.c:  executable->host_kernel_args =
../../drivers/amdgpu/executable.c:  executable->device_count = topology->gpu_agent_count;
../../drivers/amdgpu/executable.c:        &executable->handle);
../../drivers/amdgpu/executable.c:  // kernel_object pointer and we handle that per-device during table upload.
../../drivers/amdgpu/executable.c:       iree_status_is_ok(status) && kernel_ordinal < executable->kernel_count;
../../drivers/amdgpu/executable.c:            libhsa, executable->handle, export_def, export_loc,
../../drivers/amdgpu/executable.c:            any_device_agent, &executable->host_kernel_args[kernel_ordinal]),
../../drivers/amdgpu/executable.c:       iree_status_is_ok(status) && device_ordinal < executable->device_count;
../../drivers/amdgpu/executable.c:        libhsa, executable->handle, export_defs, executable->kernel_count,
../../drivers/amdgpu/executable.c:        executable->host_kernel_args, topology->gpu_agents[device_ordinal],
../../drivers/amdgpu/executable.c:        &executable->device_kernel_args[device_ordinal]);
../../drivers/amdgpu/executable.c:  // accidentally use it instead of the device-specific one.
../../drivers/amdgpu/executable.c:       kernel_ordinal < executable->kernel_count; ++kernel_ordinal) {
../../drivers/amdgpu/executable.c:    executable->host_kernel_args[kernel_ordinal].kernel_object = 0;
../../drivers/amdgpu/executable.c:  iree_allocator_t host_allocator = executable->host_allocator;
../../drivers/amdgpu/executable.c:       device_ordinal < executable->device_count; ++device_ordinal) {
../../drivers/amdgpu/executable.c:    void* kernel_args = (void*)executable->device_kernel_args[device_ordinal];
../../drivers/amdgpu/executable.c:          IREE_LIBHSA(executable->libhsa), kernel_args));
../../drivers/amdgpu/executable.c:  if (executable->handle.handle) {
../../drivers/amdgpu/executable.c:        IREE_LIBHSA(executable->libhsa), executable->handle));
../../drivers/amdgpu/executable.c:  if (IREE_UNLIKELY(entry_point >= executable->kernel_count)) {
../../drivers/amdgpu/executable.c:                            entry_point, executable->kernel_count);
../../drivers/amdgpu/executable.c:  *out_kernel_args = &executable->host_kernel_args[entry_point];
../../drivers/amdgpu/executable.c:  if (IREE_UNLIKELY(entry_point >= executable->kernel_count)) {
../../drivers/amdgpu/executable.c:                            entry_point, executable->kernel_count);
../../drivers/amdgpu/executable.c:  } else if (IREE_UNLIKELY(device_ordinal >= executable->device_count)) {
../../drivers/amdgpu/executable.c:                            device_ordinal, executable->device_count);
../../drivers/amdgpu/executable.c:      &executable->device_kernel_args[device_ordinal][entry_point];
../../drivers/vulkan/native_event.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/native_event.cc:  return VK_RESULT_TO_STATUS(logical_device->syms()->vkCreateEvent(
../../drivers/vulkan/native_event.cc:                                 logical_device->allocator(), out_handle),
../../drivers/vulkan/native_event.cc:  logical_device->syms()->vkDestroyEvent(*logical_device, handle,
../../drivers/vulkan/native_event.cc:                                         logical_device->allocator());
../../drivers/vulkan/native_event.cc:  iree_status_t status = iree_allocator_malloc(logical_device->host_allocator(),
../../drivers/vulkan/native_event.cc:                                 &event->resource);
../../drivers/vulkan/native_event.cc:    event->logical_device = logical_device;
../../drivers/vulkan/native_event.cc:    event->handle = handle;
../../drivers/vulkan/native_event.cc:  iree_allocator_t host_allocator = event->logical_device->host_allocator();
../../drivers/vulkan/native_event.cc:  iree_hal_vulkan_destroy_event(event->logical_device, event->handle);
../../drivers/vulkan/native_event.cc:  return ((const iree_hal_vulkan_native_event_t*)base_event)->handle;
../../drivers/amdgpu/util/block_pool.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/util/block_pool.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/block_pool.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/block_pool.h:// TODO(benvanik): verify that 16 is enough - there are some rules for kernarg
../../drivers/amdgpu/util/block_pool.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/block_pool.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/block_pool.h:  // Next block in a user-defined block list. May be used for any purpose.
../../drivers/amdgpu/util/block_pool.h:  // Previous block in a user-defined block list. May be used for any purpose.
../../drivers/amdgpu/util/block_pool.h:  sizeof(((iree_hal_amdgpu_block_t*)NULL)->user_data)
../../drivers/amdgpu/util/block_pool.h:// A shared pool of equal-sized blocks in device agent memory.
../../drivers/amdgpu/util/block_pool.h:// linked-list pointer walks. Since users of the block pool almost always need a
../../drivers/amdgpu/util/block_pool.h:// Thread-safe; may be used by multiple queues on the same physical device with
../../drivers/amdgpu/util/block_pool.h:// Releases a singly-linked list of blocks back to the pool.
../../drivers/amdgpu/util/block_pool.h:  // Used for small allocations of around ~4-32KB.
../../drivers/amdgpu/util/block_pool.h:  // Used for large page-sized allocations of around ~64kB-512KB.
../../drivers/amdgpu/util/block_pool.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/block_pool.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/block_pool.h:// A lightweight bump-pointer arena allocator using a shared block pool.
../../drivers/amdgpu/util/block_pool.h:// Thread-compatible; the shared block pool is thread-safe and may be used by
../../drivers/amdgpu/util/block_pool.h:  // Fixed-size block pool used to acquire new blocks for the arena.
../../drivers/amdgpu/util/block_pool.h:  // Doubly-linked list of allocated blocks maintained so that reset can release
../../drivers/amdgpu/util/block_pool.h:  // Note that we do not require the double-link, but do so such that
../../drivers/amdgpu/util/block_pool.h:  // iree_hal_amdgpu_block_arena_release_blocks returns a doubly-linked list to
../../drivers/amdgpu/util/block_pool.h:// doubly-linked list. The arena will be reset and ready to allocate new blocks.
../../drivers/amdgpu/util/block_pool.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/block_pool.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/util/block_pool.h:// either touch the device-side memory or allocate additional host-side
../../drivers/amdgpu/util/block_pool.h:// and each block already has 256 bits of host-local user data storage available
../../drivers/amdgpu/util/block_pool.h:// intended usage which is either ~64-128 byte allocations (most scheduler queue
../../drivers/amdgpu/util/block_pool.h:// entries) or ~1024-4096 byte allocations (execution entries with binding
../../drivers/amdgpu/util/block_pool.h:// their size class so as to avoid overallocation/under-utilization: allocating
../../drivers/amdgpu/util/block_pool.h:// would be nearly entirely unused if we didn't do that first-level filtering.
../../drivers/amdgpu/util/block_pool.h:// Thread-safe; allocate/free are guarded within the allocator and the
../../drivers/amdgpu/util/block_pool.h:// underlying block pool is also thread-safe.
../../drivers/amdgpu/util/block_pool.h:  // Power-of-two calculated allocation granularity in bytes. All allocations
../../drivers/amdgpu/util/block_pool.h:  // Power-of-two number of pages within each block.
../../drivers/amdgpu/util/block_pool.h:  // Block pool with fixed-size blocks that the allocator uses for storage.
../../drivers/amdgpu/util/block_pool.h:// |block_pool| and with a fixed power-of-two allocation |min_page_size|.
../../drivers/amdgpu/util/block_pool.h:// be host accessible) and |out_token| is opaque allocation-specific metadata
../../drivers/amdgpu/util/block_pool.h:  // Used for small allocations of around ~64B-256B.
../../drivers/amdgpu/util/block_pool.h:  // Used for large allocations of around ~4096B-256KB.
../../drivers/amdgpu/allocator.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/allocator.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/allocator.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/tracing.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/device/tracing.c:// NOTE: this header in clang only declares the builtins for va_list-related
../../drivers/amdgpu/device/tracing.c:// things - if it becomes an issue we can easily inline them here.
../../drivers/amdgpu/device/tracing.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/tracing.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/tracing.c:  return (ringbuffer->write_index++) &
../../drivers/amdgpu/device/tracing.c:         (IREE_AMDGPU_ARRAYSIZE(ringbuffer->signals) - 1);
../../drivers/amdgpu/device/tracing.c:  uint64_t base_index = ringbuffer->write_index;
../../drivers/amdgpu/device/tracing.c:  ringbuffer->write_index += count;
../../drivers/amdgpu/device/tracing.c:  for (uint32_t i = ringbuffer->read_index; i < ringbuffer->read_index + count;
../../drivers/amdgpu/device/tracing.c:             ->signals[i & (IREE_AMDGPU_ARRAYSIZE(ringbuffer->signals) - 1)];
../../drivers/amdgpu/device/tracing.c:    signal->value = 1;
../../drivers/amdgpu/device/tracing.c:    signal->start_ts = 0;
../../drivers/amdgpu/device/tracing.c:    signal->end_ts = 0;
../../drivers/amdgpu/device/tracing.c:  ringbuffer->read_index += count;
../../drivers/amdgpu/device/tracing.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/tracing.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/tracing.c:// The ringbuffer memory must be zero-initialized by the allocator.
../../drivers/amdgpu/device/tracing.c:    trace_buffer->read_commit_offset = 0;
../../drivers/amdgpu/device/tracing.c:    trace_buffer->write_reserve_offset = 0;
../../drivers/amdgpu/device/tracing.c:    trace_buffer->write_commit_offset = 0;
../../drivers/amdgpu/device/tracing.c:    trace_buffer->query_ringbuffer.read_index = 0;
../../drivers/amdgpu/device/tracing.c:    trace_buffer->query_ringbuffer.write_index = 0;
../../drivers/amdgpu/device/tracing.c:  iree_amd_signal_t* signal = &trace_buffer->query_ringbuffer.signals[i];
../../drivers/amdgpu/device/tracing.c:  signal->kind = IREE_AMD_SIGNAL_KIND_USER;
../../drivers/amdgpu/device/tracing.c:  signal->value = 1;
../../drivers/amdgpu/device/tracing.c:  signal->event_mailbox_ptr = 0;
../../drivers/amdgpu/device/tracing.c:  signal->event_id = 0;
../../drivers/amdgpu/device/tracing.c:  signal->reserved1 = 0;
../../drivers/amdgpu/device/tracing.c:  signal->start_ts = 0;
../../drivers/amdgpu/device/tracing.c:  signal->end_ts = 0;
../../drivers/amdgpu/device/tracing.c:  signal->queue_ptr = 0;
../../drivers/amdgpu/device/tracing.c:  signal->reserved3[0] = 0;
../../drivers/amdgpu/device/tracing.c:  signal->reserved3[1] = 0;
../../drivers/amdgpu/device/tracing.c:      &trace_buffer->write_reserve_offset, length,
../../drivers/amdgpu/device/tracing.c:  if (write_offset + length -
../../drivers/amdgpu/device/tracing.c:          iree_amdgpu_scoped_atomic_load(&trace_buffer->read_commit_offset,
../../drivers/amdgpu/device/tracing.c:      trace_buffer->ringbuffer_capacity) {
../../drivers/amdgpu/device/tracing.c:      (uint8_t*)trace_buffer->ringbuffer_base +
../../drivers/amdgpu/device/tracing.c:      &trace_buffer->write_reserve_offset, iree_amdgpu_memory_order_acquire,
../../drivers/amdgpu/device/tracing.c:      &trace_buffer->write_commit_offset, last_reserve_offset,
../../drivers/amdgpu/device/tracing.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/tracing.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/tracing.c:  packet->event_type = IREE_HAL_AMDGPU_TRACE_EVENT_ZONE_BEGIN;
../../drivers/amdgpu/device/tracing.c:  packet->timestamp = iree_amdgpu_device_timestamp();
../../drivers/amdgpu/device/tracing.c:  packet->src_loc = src_loc;
../../drivers/amdgpu/device/tracing.c:  packet->event_type = IREE_HAL_AMDGPU_TRACE_EVENT_ZONE_END;
../../drivers/amdgpu/device/tracing.c:  packet->timestamp = iree_amdgpu_device_timestamp();
../../drivers/amdgpu/device/tracing.c:  packet->event_type = IREE_HAL_AMDGPU_TRACE_EVENT_ZONE_VALUE_I64;
../../drivers/amdgpu/device/tracing.c:  packet->value = value;
../../drivers/amdgpu/device/tracing.c:  packet->event_type = IREE_HAL_AMDGPU_TRACE_EVENT_ZONE_VALUE_TEXT_LITERAL;
../../drivers/amdgpu/device/tracing.c:  packet->value = value_literal;
../../drivers/amdgpu/device/tracing.c:  packet->event_type = IREE_HAL_AMDGPU_TRACE_EVENT_ZONE_VALUE_TEXT_DYNAMIC;
../../drivers/amdgpu/device/tracing.c:  packet->length = (uint32_t)value_length;
../../drivers/amdgpu/device/tracing.c:  iree_amdgpu_memcpy(packet->value, value, value_length);
../../drivers/amdgpu/device/tracing.c:  packet->event_type = IREE_HAL_AMDGPU_TRACE_EVENT_PLOT_CONFIG;
../../drivers/amdgpu/device/tracing.c:  packet->plot_type = type;
../../drivers/amdgpu/device/tracing.c:  packet->plot_flags = flags;
../../drivers/amdgpu/device/tracing.c:  packet->color = color;
../../drivers/amdgpu/device/tracing.c:  packet->name = name_literal;
../../drivers/amdgpu/device/tracing.c:  packet->event_type = IREE_HAL_AMDGPU_TRACE_EVENT_PLOT_VALUE_I64;
../../drivers/amdgpu/device/tracing.c:  packet->plot_name = name_literal;
../../drivers/amdgpu/device/tracing.c:  packet->timestamp = iree_amdgpu_device_timestamp();
../../drivers/amdgpu/device/tracing.c:  packet->value = value;
../../drivers/amdgpu/device/tracing.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/tracing.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/tracing.c:  packet->event_type = IREE_HAL_AMDGPU_TRACE_EVENT_EXECUTION_ZONE_BEGIN;
../../drivers/amdgpu/device/tracing.c:  packet->executor_id = trace_buffer->executor_id;
../../drivers/amdgpu/device/tracing.c:  packet->execution_query_id = execution_query_id;
../../drivers/amdgpu/device/tracing.c:  packet->issue_timestamp = iree_amdgpu_device_timestamp();
../../drivers/amdgpu/device/tracing.c:  packet->src_loc = src_loc;
../../drivers/amdgpu/device/tracing.c:      &trace_buffer->query_ringbuffer, execution_query_id);
../../drivers/amdgpu/device/tracing.c:  packet->event_type = IREE_HAL_AMDGPU_TRACE_EVENT_EXECUTION_ZONE_END;
../../drivers/amdgpu/device/tracing.c:  packet->executor_id = trace_buffer->executor_id;
../../drivers/amdgpu/device/tracing.c:  packet->execution_query_id = execution_query_id;
../../drivers/amdgpu/device/tracing.c:  packet->issue_timestamp = iree_amdgpu_device_timestamp();
../../drivers/amdgpu/device/tracing.c:      &trace_buffer->query_ringbuffer, execution_query_id);
../../drivers/amdgpu/device/tracing.c:  packet->event_type = IREE_HAL_AMDGPU_TRACE_EVENT_EXECUTION_ZONE_NOTIFY_BATCH;
../../drivers/amdgpu/device/tracing.c:  packet->executor_id = trace_buffer->executor_id;
../../drivers/amdgpu/device/tracing.c:  packet->execution_query_id_base = execution_query_id_base;
../../drivers/amdgpu/device/tracing.c:  packet->execution_query_count = execution_query_count;
../../drivers/amdgpu/device/tracing.c:  return &packet->execution_time_ranges[0];
../../drivers/amdgpu/device/tracing.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/tracing.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/tracing.c:  packet->event_type = IREE_HAL_AMDGPU_TRACE_EVENT_EXECUTION_ZONE_DISPATCH;
../../drivers/amdgpu/device/tracing.c:  packet->zone_type = zone_type;
../../drivers/amdgpu/device/tracing.c:  packet->executor_id = trace_buffer->executor_id;
../../drivers/amdgpu/device/tracing.c:  packet->execution_query_id = execution_query_id;
../../drivers/amdgpu/device/tracing.c:  packet->export_loc = export_loc;
../../drivers/amdgpu/device/tracing.c:  packet->issue_timestamp = iree_amdgpu_device_timestamp();
../../drivers/amdgpu/device/tracing.c:      &trace_buffer->query_ringbuffer, execution_query_id);
../../drivers/amdgpu/device/tracing.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/tracing.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/tracing.c:  packet->event_type = IREE_HAL_AMDGPU_TRACE_EVENT_MEMORY_ALLOC;
../../drivers/amdgpu/device/tracing.c:  packet->pool = name_literal;
../../drivers/amdgpu/device/tracing.c:  packet->timestamp = iree_amdgpu_device_timestamp();
../../drivers/amdgpu/device/tracing.c:  packet->ptr = ptr;
../../drivers/amdgpu/device/tracing.c:  packet->size = size;
../../drivers/amdgpu/device/tracing.c:  packet->event_type = IREE_HAL_AMDGPU_TRACE_EVENT_MEMORY_FREE;
../../drivers/amdgpu/device/tracing.c:  packet->timestamp = iree_amdgpu_device_timestamp();
../../drivers/amdgpu/device/tracing.c:  packet->ptr = ptr;
../../drivers/amdgpu/device/tracing.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/tracing.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/tracing.c:  packet->event_type = IREE_HAL_AMDGPU_TRACE_EVENT_MESSAGE_LITERAL;
../../drivers/amdgpu/device/tracing.c:  packet->timestamp = iree_amdgpu_device_timestamp();
../../drivers/amdgpu/device/tracing.c:  packet->value = value_literal;
../../drivers/amdgpu/device/tracing.c:  packet->event_type = IREE_HAL_AMDGPU_TRACE_EVENT_MESSAGE_DYNAMIC;
../../drivers/amdgpu/device/tracing.c:  packet->length = (uint32_t)value_length;
../../drivers/amdgpu/device/tracing.c:  packet->timestamp = iree_amdgpu_device_timestamp();
../../drivers/amdgpu/device/tracing.c:  iree_amdgpu_memcpy(packet->value, value, value_length);
../../drivers/amdgpu/device/tracing.c:        buffer[length] = digit + (digit < 10 ? '0' : base_hex_char - 10);
../../drivers/amdgpu/device/tracing.c:  // NOTE: we capture the timestamp before doing our string processing - not
../../drivers/amdgpu/device/tracing.c:  packet->event_type = IREE_HAL_AMDGPU_TRACE_EVENT_MESSAGE_DYNAMIC;
../../drivers/amdgpu/device/tracing.c:  packet->length = (uint32_t)required_length;
../../drivers/amdgpu/device/tracing.c:  packet->timestamp = timestamp;
../../drivers/amdgpu/device/tracing.c:  iree_hal_amdgpu_vsprintf(packet->value, format, vlist1);
../../drivers/amdgpu/buffer_pool_test.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/buffer_pool_test.cc:  // No-op since nothing has been allocated.
../../drivers/amdgpu/buffer_pool_test.cc:  // No-op since nothing has been allocated yet.
../../drivers/amdgpu/buffer_pool_test.cc:  // No-op preallocation (can happen if we blindly pass options/flags of 0).
../../drivers/amdgpu/buffer_pool_test.cc:  EXPECT_EQ(handle->ptr, nullptr);
../../drivers/amdgpu/buffer_pool_test.cc:  // Release the buffer back to the pool - we're the last reference and it
../../drivers/amdgpu/buffer_pool_test.cc:    EXPECT_EQ(handles[i]->ptr, nullptr);
../../drivers/amdgpu/buffer_pool_test.cc:  EXPECT_EQ(growth_handle->ptr, nullptr);
../../drivers/amdgpu/buffer_pool_test.cc:  EXPECT_EQ(growth_handle->ptr, nullptr);
../../drivers/amdgpu/buffer_pool_test.cc:  EXPECT_EQ(growth_handle->ptr, nullptr);
../../drivers/vulkan/dynamic_symbol_tables.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/dynamic_symbol_tables.h:// choice (includes both common and enabled platform-specific functions).
../../drivers/vulkan/dynamic_symbol_tables.h:// Table macros are designed to take two macros: one for each instance-specific
../../drivers/vulkan/dynamic_symbol_tables.h:// function and one for each device-specific function. These macros are also
../../drivers/vulkan/dynamic_symbol_tables.h:// passed a requirement flag that enables compile-time exclusion of methods that
../../drivers/vulkan/dynamic_symbol_tables.h:// Define to get instance-specific functions:
../../drivers/vulkan/dynamic_symbol_tables.h:// Define to get device-specific functions:
../../drivers/vulkan/descriptor_set_arena.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/descriptor_set_arena.cc:  arena->Reset();
../../drivers/vulkan/descriptor_set_arena.cc:      arena->AllocateSpan<VkDescriptorBufferInfo>(binding_count);
../../drivers/vulkan/descriptor_set_arena.cc:  auto write_infos = arena->AllocateSpan<VkWriteDescriptorSet>(binding_count);
../../drivers/vulkan/descriptor_set_arena.cc:      // Round up to a multiple of 32-bit. 32-bit is the defacto native bitwidth
../../drivers/vulkan/descriptor_set_arena.cc:      // to match the ABI and provide the buffer as 32-bit aligned, otherwise
../../drivers/vulkan/descriptor_set_arena.cc:      // https://github.com/iree-org/iree/issues/2022#issuecomment-640617234 for
../../drivers/vulkan/descriptor_set_arena.cc:          std::min(binding.length, iree_hal_buffer_byte_length(binding.buffer) -
../../drivers/vulkan/descriptor_set_arena.cc:    : logical_device_(descriptor_pool_cache->logical_device()),
../../drivers/vulkan/descriptor_set_arena.cc:        descriptor_pool_cache_->ReleaseDescriptorPools(used_descriptor_pools_));
../../drivers/vulkan/descriptor_set_arena.cc:  if (logical_device_->enabled_extensions().push_descriptors) {
../../drivers/vulkan/descriptor_set_arena.cc:    IREE_RETURN_IF_ERROR(descriptor_pool_cache_->AcquireDescriptorPool(
../../drivers/vulkan/descriptor_set_arena.cc:    IREE_RETURN_IF_ERROR(descriptor_pool_cache_->AcquireDescriptorPool(
../../drivers/amdgpu/device_queue.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/device_queue.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device_queue.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device_queue.h:// Initializes |out_queue| in-place based on |options|.
../../drivers/amdgpu/semaphore_pool_test.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/semaphore_pool_test.cc:  // No-op since nothing has been allocated.
../../drivers/amdgpu/semaphore_pool_test.cc:  // No-op since nothing has been allocated yet.
../../drivers/amdgpu/semaphore_pool_test.cc:  // No-op preallocation (can happen if we blindly pass options/flags of 0).
../../drivers/amdgpu/semaphore_pool_test.cc:  // Ensure the device-visible handle is initialized.
../../drivers/amdgpu/semaphore_pool_test.cc:  ASSERT_EQ(handle->host_semaphore, (uint64_t)semaphore);
../../drivers/amdgpu/semaphore_pool_test.cc:  // Release the semaphore back to the pool - we're the last reference and it
../../drivers/amdgpu/buffer.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/buffer.c:      placement, &buffer->base, allocation_size, byte_offset, byte_length,
../../drivers/amdgpu/buffer.c:      &iree_hal_amdgpu_external_buffer_vtable, &buffer->base);
../../drivers/amdgpu/buffer.c:  buffer->host_allocator = host_allocator;
../../drivers/amdgpu/buffer.c:  buffer->release_callback = release_callback;
../../drivers/amdgpu/buffer.c:  buffer->device_ptr = device_ptr;
../../drivers/amdgpu/buffer.c:  *out_buffer = &buffer->base;
../../drivers/amdgpu/buffer.c:  iree_allocator_t host_allocator = buffer->host_allocator;
../../drivers/amdgpu/buffer.c:  if (buffer->release_callback.fn) {
../../drivers/amdgpu/buffer.c:    buffer->release_callback.fn(buffer->release_callback.user_data,
../../drivers/amdgpu/buffer.c:  mapping->contents = iree_make_byte_span(
../../drivers/amdgpu/buffer.c:      (IREE_AMDGPU_DEVICE_PTR void*)buffer->device_ptr, local_byte_length);
../../drivers/amdgpu/buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/buffer.c:      placement, &out_buffer->base,
../../drivers/amdgpu/buffer.c:      &iree_hal_amdgpu_transient_buffer_vtable, &out_buffer->base);
../../drivers/amdgpu/buffer.c:  out_buffer->handle = handle;
../../drivers/amdgpu/buffer.c:  out_buffer->release_callback = release_callback;
../../drivers/amdgpu/buffer.c:  iree_atomic_ref_count_init_value(&out_buffer->base.resource.ref_count, 0);
../../drivers/amdgpu/buffer.c:  // No-op.
../../drivers/amdgpu/buffer.c:  IREE_ASSERT(buffer->release_callback.fn);
../../drivers/amdgpu/buffer.c:  if (buffer->release_callback.fn) {
../../drivers/amdgpu/buffer.c:    buffer->release_callback.fn(buffer->release_callback.user_data,
../../drivers/amdgpu/buffer.c:  buffer->base.memory_type = params.type;
../../drivers/amdgpu/buffer.c:  buffer->base.allowed_access = params.access;
../../drivers/amdgpu/buffer.c:  buffer->base.allowed_usage = params.usage;
../../drivers/amdgpu/buffer.c:  buffer->base.allocation_size = allocation_size;
../../drivers/amdgpu/buffer.c:  buffer->base.byte_offset = byte_offset;
../../drivers/amdgpu/buffer.c:  buffer->base.byte_length = byte_length;
../../drivers/amdgpu/buffer.c:  buffer->base.placement.queue_affinity = params.queue_affinity
../../drivers/amdgpu/buffer.c:                "only 64-bit pointers are supported");
../../drivers/amdgpu/buffer.c:      (iree_atomic_uint64_t*)&buffer->handle->ptr, iree_memory_order_acquire);
../../drivers/amdgpu/buffer.c:  mapping->contents = iree_make_byte_span(ptr, local_byte_length);
../../drivers/amdgpu/buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/buffer.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/buffer.c:        (uint64_t)((iree_hal_amdgpu_transient_buffer_t*)base_buffer)->handle;
../../drivers/amdgpu/buffer.c:        (uint64_t)((iree_hal_amdgpu_external_buffer_t*)base_buffer)->device_ptr;
../../drivers/amdgpu/buffer.c:  *out_handle = buffer->handle;
../../drivers/vulkan/builtin_executables.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/builtin_executables.h:    return logical_device_->syms();
../../drivers/amdgpu/host_queue.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/host_queue.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/host_queue.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/host_queue.c:  IREE_ASSERT_EQ(virtual_queue->vtable, &iree_hal_amdgpu_host_queue_vtable);
../../drivers/amdgpu/host_queue.c:  IREE_ASSERT_EQ(options->placement, IREE_HAL_AMDGPU_QUEUE_PLACEMENT_HOST);
../../drivers/amdgpu/host_queue.c:  queue->base.vtable = &iree_hal_amdgpu_host_queue_vtable;
../../drivers/amdgpu/host_queue.c:  queue->error_callback = error_callback;
../../drivers/amdgpu/host_queue.c:      IREE_STATUS_UNIMPLEMENTED, "host-side queuing not yet implemented");
../../drivers/vulkan/sparse_buffer.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/sparse_buffer.h:// clang-format off: must be included before all other headers.
../../drivers/vulkan/sparse_buffer.h:// clang-format on
../../drivers/vulkan/native_semaphore.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/native_semaphore.cc:      z0, VK_RESULT_TO_STATUS(logical_device->syms()->vkCreateSemaphore(
../../drivers/vulkan/native_semaphore.cc:                                  logical_device->allocator(), &handle),
../../drivers/vulkan/native_semaphore.cc:      logical_device->host_allocator(), sizeof(*semaphore), (void**)&semaphore);
../../drivers/vulkan/native_semaphore.cc:                                  &semaphore->base);
../../drivers/vulkan/native_semaphore.cc:    semaphore->logical_device = logical_device;
../../drivers/vulkan/native_semaphore.cc:    semaphore->handle = handle;
../../drivers/vulkan/native_semaphore.cc:    iree_atomic_store(&semaphore->failure_status, 0, iree_memory_order_release);
../../drivers/vulkan/native_semaphore.cc:    *out_semaphore = &semaphore->base;
../../drivers/vulkan/native_semaphore.cc:    logical_device->syms()->vkDestroySemaphore(*logical_device, handle,
../../drivers/vulkan/native_semaphore.cc:                                               logical_device->allocator());
../../drivers/vulkan/native_semaphore.cc:  iree_allocator_t host_allocator = semaphore->logical_device->host_allocator();
../../drivers/vulkan/native_semaphore.cc:      &semaphore->failure_status, iree_memory_order_acquire));
../../drivers/vulkan/native_semaphore.cc:  semaphore->logical_device->syms()->vkDestroySemaphore(
../../drivers/vulkan/native_semaphore.cc:      *semaphore->logical_device, semaphore->handle,
../../drivers/vulkan/native_semaphore.cc:      semaphore->logical_device->allocator());
../../drivers/vulkan/native_semaphore.cc:  iree_hal_semaphore_deinitialize(&semaphore->base);
../../drivers/vulkan/native_semaphore.cc:  return iree_hal_resource_is(&semaphore->resource,
../../drivers/vulkan/native_semaphore.cc:  return semaphore->handle;
../../drivers/vulkan/native_semaphore.cc:  // Query from Vulkan source-of-truth.
../../drivers/vulkan/native_semaphore.cc:      semaphore->logical_device->syms()->vkGetSemaphoreCounterValue(
../../drivers/vulkan/native_semaphore.cc:          *semaphore->logical_device, semaphore->handle, &value),
../../drivers/vulkan/native_semaphore.cc:        &semaphore->failure_status, iree_memory_order_acquire);
../../drivers/vulkan/native_semaphore.cc:    iree_hal_semaphore_notify(&semaphore->base, value,
../../drivers/vulkan/native_semaphore.cc:  // device-side signal occurs. This helps us keep latencies lower by flushing
../../drivers/vulkan/native_semaphore.cc:  iree_hal_semaphore_notify(&semaphore->base, value, IREE_STATUS_OK);
../../drivers/vulkan/native_semaphore.cc:  signal_info.semaphore = semaphore->handle;
../../drivers/vulkan/native_semaphore.cc:      VK_RESULT_TO_STATUS(semaphore->logical_device->syms()->vkSignalSemaphore(
../../drivers/vulkan/native_semaphore.cc:                              *semaphore->logical_device, &signal_info),
../../drivers/vulkan/native_semaphore.cc:  iree_hal_semaphore_notify(&semaphore->base, new_value,
../../drivers/vulkan/native_semaphore.cc:  // Try to set our local status - we only preserve the first failure so only
../../drivers/vulkan/native_semaphore.cc:          &semaphore->failure_status, (intptr_t*)&old_status, (intptr_t)status,
../../drivers/vulkan/native_semaphore.cc:  signal_info.semaphore = semaphore->handle;
../../drivers/vulkan/native_semaphore.cc:  semaphore->logical_device->syms()->vkSignalSemaphore(
../../drivers/vulkan/native_semaphore.cc:      *semaphore->logical_device, &signal_info);
../../drivers/vulkan/native_semaphore.cc:  iree_hal_semaphore_notify(&semaphore->base, signal_info.value, status_code);
../../drivers/vulkan/native_semaphore.cc:  if (semaphore_list->count == 0) return iree_ok_status();
../../drivers/vulkan/native_semaphore.cc:    timeout_ns = deadline_ns < now_ns ? 0 : (uint64_t)(deadline_ns - now_ns);
../../drivers/vulkan/native_semaphore.cc:      (VkSemaphore*)iree_alloca(semaphore_list->count * sizeof(VkSemaphore));
../../drivers/vulkan/native_semaphore.cc:  for (iree_host_size_t i = 0; i < semaphore_list->count; ++i) {
../../drivers/vulkan/native_semaphore.cc:        iree_hal_vulkan_native_semaphore_handle(semaphore_list->semaphores[i]);
../../drivers/vulkan/native_semaphore.cc:  wait_info.semaphoreCount = semaphore_list->count;
../../drivers/vulkan/native_semaphore.cc:  wait_info.pValues = semaphore_list->payload_values;
../../drivers/vulkan/native_semaphore.cc:      sizeof(wait_info.pValues[0]) == sizeof(semaphore_list->payload_values[0]),
../../drivers/vulkan/native_semaphore.cc:  VkResult result = logical_device->syms()->vkWaitSemaphores(
../../drivers/vulkan/native_semaphore.cc:  // We aren't notified of device-side signals by Vulkan and need to check to
../../drivers/vulkan/native_semaphore.cc:  for (iree_host_size_t i = 0; i < semaphore_list->count; ++i) {
../../drivers/vulkan/native_semaphore.cc:        semaphore_list->semaphores[i], &value));
../../drivers/vulkan/native_semaphore.cc:      semaphore->logical_device, &semaphore_list, timeout, 0);
../../drivers/vulkan/native_semaphore.cc:  *out_handle = semaphore->handle;
../../drivers/amdgpu/device/semaphore.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/device/semaphore.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/device/semaphore.c://===----------------------------------------------------------------------===//
../../drivers/vulkan/native_buffer.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/native_buffer.cc:        placement, &buffer->base.base, allocation_size, byte_offset,
../../drivers/vulkan/native_buffer.cc:        &iree_hal_vulkan_native_buffer_vtable, &buffer->base.base);
../../drivers/vulkan/native_buffer.cc:    buffer->base.host_allocator = host_allocator;
../../drivers/vulkan/native_buffer.cc:    buffer->base.device_memory = device_memory;
../../drivers/vulkan/native_buffer.cc:    buffer->base.handle = handle;
../../drivers/vulkan/native_buffer.cc:    buffer->logical_device = logical_device;
../../drivers/vulkan/native_buffer.cc:    buffer->internal_release_callback = internal_release_callback;
../../drivers/vulkan/native_buffer.cc:    buffer->user_release_callback = user_release_callback;
../../drivers/vulkan/native_buffer.cc:    *out_buffer = &buffer->base.base;
../../drivers/vulkan/native_buffer.cc:  iree_allocator_t host_allocator = buffer->base.host_allocator;
../../drivers/vulkan/native_buffer.cc:  if (buffer->internal_release_callback.fn) {
../../drivers/vulkan/native_buffer.cc:    buffer->internal_release_callback.fn(
../../drivers/vulkan/native_buffer.cc:        buffer->internal_release_callback.user_data, buffer->logical_device,
../../drivers/vulkan/native_buffer.cc:        buffer->base.device_memory, buffer->base.handle);
../../drivers/vulkan/native_buffer.cc:  if (buffer->user_release_callback.fn) {
../../drivers/vulkan/native_buffer.cc:    buffer->user_release_callback.fn(buffer->user_release_callback.user_data,
../../drivers/vulkan/native_buffer.cc:                                     &buffer->base.base);
../../drivers/vulkan/native_buffer.cc:  if (IREE_UNLIKELY(!buffer->base.device_memory)) {
../../drivers/vulkan/native_buffer.cc:  auto* logical_device = buffer->logical_device;
../../drivers/vulkan/native_buffer.cc:  VK_RETURN_IF_ERROR(logical_device->syms()->vkMapMemory(
../../drivers/vulkan/native_buffer.cc:                         *logical_device, buffer->base.device_memory,
../../drivers/vulkan/native_buffer.cc:  mapping->contents = iree_make_byte_span(data_ptr, local_byte_length);
../../drivers/vulkan/native_buffer.cc:    memset(mapping->contents.data, 0xCD, local_byte_length);
../../drivers/vulkan/native_buffer.cc:  if (IREE_UNLIKELY(!buffer->base.device_memory)) {
../../drivers/vulkan/native_buffer.cc:  auto* logical_device = buffer->logical_device;
../../drivers/vulkan/native_buffer.cc:  logical_device->syms()->vkUnmapMemory(*logical_device,
../../drivers/vulkan/native_buffer.cc:                                        buffer->base.device_memory);
../../drivers/vulkan/native_buffer.cc:  if (IREE_UNLIKELY(!buffer->base.device_memory)) {
../../drivers/vulkan/native_buffer.cc:  auto* logical_device = buffer->logical_device;
../../drivers/vulkan/native_buffer.cc:  range.memory = buffer->base.device_memory;
../../drivers/vulkan/native_buffer.cc:  VK_RETURN_IF_ERROR(logical_device->syms()->vkInvalidateMappedMemoryRanges(
../../drivers/vulkan/native_buffer.cc:  if (IREE_UNLIKELY(!buffer->base.device_memory)) {
../../drivers/vulkan/native_buffer.cc:  auto* logical_device = buffer->logical_device;
../../drivers/vulkan/native_buffer.cc:  range.memory = buffer->base.device_memory;
../../drivers/vulkan/native_buffer.cc:  VK_RETURN_IF_ERROR(logical_device->syms()->vkFlushMappedMemoryRanges(
../../drivers/amdgpu/registration/driver_module.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/registration/driver_module.c:               "Search path (directory or file) for the ROCR-Runtime library "
../../drivers/amdgpu/registration/driver_module.c:               "(`libhsa-runtime64.so`, etc).");
../../drivers/amdgpu/registration/driver_module.c:          "Enables dispatch-level tracing (if device instrumentation is "
../../drivers/amdgpu/registration/driver_module.c:          "aggressively scheduling queue entries out-of-order.");
../../drivers/amdgpu/registration/driver_module.c:    device_options->host_block_pools.small.block_size =
../../drivers/amdgpu/registration/driver_module.c:    device_options->host_block_pools.large.block_size =
../../drivers/amdgpu/registration/driver_module.c:    device_options->device_block_pools.small.block_size =
../../drivers/amdgpu/registration/driver_module.c:    device_options->device_block_pools.small.initial_capacity =
../../drivers/amdgpu/registration/driver_module.c:    device_options->device_block_pools.large.block_size =
../../drivers/amdgpu/registration/driver_module.c:    device_options->device_block_pools.large.initial_capacity =
../../drivers/amdgpu/registration/driver_module.c:    device_options->queue_placement = IREE_HAL_AMDGPU_QUEUE_PLACEMENT_ANY;
../../drivers/amdgpu/registration/driver_module.c:    device_options->queue_placement = IREE_HAL_AMDGPU_QUEUE_PLACEMENT_HOST;
../../drivers/amdgpu/registration/driver_module.c:    device_options->queue_placement = IREE_HAL_AMDGPU_QUEUE_PLACEMENT_DEVICE;
../../drivers/amdgpu/registration/driver_module.c:  device_options->preallocate_pools = FLAG_amdgpu_preallocate_pools;
../../drivers/amdgpu/registration/driver_module.c:  device_options->trace_execution = FLAG_amdgpu_trace_execution;
../../drivers/amdgpu/registration/driver_module.c:  device_options->exclusive_execution = FLAG_amdgpu_exclusive_execution;
../../drivers/amdgpu/registration/driver_module.c:  device_options->wait_active_for_ns = FLAG_amdgpu_wait_active_for_ns;
../../drivers/amdgpu/registration/BUILD.bazel:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/registration/driver_module.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/descriptor_pool_cache.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/descriptor_pool_cache.cc:        descriptor_pool_cache_->ReleaseDescriptorPools(descriptor_pools_));
../../drivers/vulkan/descriptor_pool_cache.cc:                         logical_device_->allocator(), &descriptor_pool.handle),
../../drivers/vulkan/descriptor_pool_cache.cc:    // throw if there are in-flight command buffers using the sets in the pool.
../../drivers/vulkan/descriptor_pool_cache.cc:                                   logical_device_->allocator());
../../drivers/amdgpu/host_service.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/host_service.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/host_service.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/host_service.h:// high core-count systems or locate the worker closer to the devices it manages
../../drivers/amdgpu/host_service.h:// Thread-safe.
../../drivers/amdgpu/host_service.h:// threads and must not re-enter the host service API or make any stateful HSA
../../drivers/vulkan/builtin_executables.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/builtin_executables.cc:    logical_device_->syms()->vkDestroyPipeline(*logical_device_, pipeline_,
../../drivers/vulkan/builtin_executables.cc:                                               logical_device_->allocator());
../../drivers/vulkan/builtin_executables.cc:    status = VK_RESULT_TO_STATUS(logical_device_->syms()->vkCreateShaderModule(
../../drivers/vulkan/builtin_executables.cc:        *logical_device_, &shader_create_info, logical_device_->allocator(),
../../drivers/vulkan/builtin_executables.cc:    stage_create_info->sType =
../../drivers/vulkan/builtin_executables.cc:    stage_create_info->pNext = NULL;
../../drivers/vulkan/builtin_executables.cc:    stage_create_info->flags = 0;
../../drivers/vulkan/builtin_executables.cc:    stage_create_info->stage = VK_SHADER_STAGE_COMPUTE_BIT;
../../drivers/vulkan/builtin_executables.cc:    stage_create_info->module = fill_unaligned_shader;
../../drivers/vulkan/builtin_executables.cc:    stage_create_info->pName = "main";
../../drivers/vulkan/builtin_executables.cc:    stage_create_info->pSpecializationInfo = NULL;
../../drivers/vulkan/builtin_executables.cc:        VK_RESULT_TO_STATUS(logical_device_->syms()->vkCreateComputePipelines(
../../drivers/vulkan/builtin_executables.cc:            logical_device_->allocator(), &pipeline_));
../../drivers/vulkan/builtin_executables.cc:    logical_device_->syms()->vkDestroyShaderModule(
../../drivers/vulkan/builtin_executables.cc:        *logical_device_, fill_unaligned_shader, logical_device_->allocator());
../../drivers/vulkan/builtin_executables.cc:  IREE_RETURN_IF_ERROR(descriptor_set_arena->BindDescriptorSet(
../../drivers/vulkan/builtin_executables.cc:  logical_device_->syms()->vkCmdBindPipeline(
../../drivers/vulkan/builtin_executables.cc:  logical_device_->syms()->vkCmdPushConstants(
../../drivers/vulkan/builtin_executables.cc:  // TODO(scotttodd): insert memory barrier if we need to do dispatch<->dispatch
../../drivers/vulkan/builtin_executables.cc:  //   transfer<->dispatch.
../../drivers/vulkan/builtin_executables.cc:  logical_device_->syms()->vkCmdDispatch(command_buffer, 1, 1, 1);
../../drivers/vulkan/native_executable.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/native_executable.h:// clang-format off: must be included before all other headers.
../../drivers/vulkan/native_executable.h:// clang-format on
../../drivers/amdgpu/buffer.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/buffer.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/buffer.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/buffer.h:// Wraps an external device-accessible |device_ptr| allocation in an
../../drivers/amdgpu/buffer.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/buffer.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/buffer.h:  // Device-side allocation handle in a memory pool accessible to all agents.
../../drivers/amdgpu/buffer.h:// Initializes a transient buffer in-place with a 0 ref count.
../../drivers/amdgpu/buffer.h:// Deinitializes a transient buffer in-place assuming it has a 0 ref count.
../../drivers/amdgpu/buffer.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/buffer.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/buffer.h:// Resolves a HAL buffer to a device-side type and pointer/handle.
../../drivers/amdgpu/buffer.h:// Returns success if the buffer is of a type that can be used toll-free on any
../../drivers/amdgpu/host_queue.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/host_queue.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/host_queue.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/host_queue.h:// Initializes |out_queue| in-place based on |options|.
../../drivers/amdgpu/system.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/system.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/system.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/system.c:// local for-loops.
../../drivers/amdgpu/system.c:  if (pool_list->count + 1 >= IREE_ARRAYSIZE(pool_list->values)) {
../../drivers/amdgpu/system.c:  pool_list->values[pool_list->count++] = memory_pool;
../../drivers/amdgpu/system.c:    // Only care about accessible-by-all.
../../drivers/amdgpu/system.c:    // matches the other flags. Workgroup-private pools won't have this set.
../../drivers/amdgpu/system.c:    // Only want fine-grained so we can use atomics.
../../drivers/amdgpu/system.c:      if (!host_memory_pools->fine_pool.handle) {  // first only
../../drivers/amdgpu/system.c:        host_memory_pools->fine_pool = pool;
../../drivers/amdgpu/system.c:  if (!host_memory_pools->fine_pool.handle) {
../../drivers/amdgpu/system.c:                              "no accessible-by-all + fine-grained shared "
../../drivers/amdgpu/system.c:// local for-loops.
../../drivers/amdgpu/system.c:  if (pool_list->count + 1 >= IREE_ARRAYSIZE(pool_list->values)) {
../../drivers/amdgpu/system.c:  pool_list->values[pool_list->count++] = region;
../../drivers/amdgpu/system.c:    // matches the other flags. Workgroup-private pools won't have this set.
../../drivers/amdgpu/system.c:    // Only want fine-grained so we can use atomics.
../../drivers/amdgpu/system.c:      if (!host_memory_pools->fine_region.handle) {  // first only
../../drivers/amdgpu/system.c:        host_memory_pools->fine_region = region;
../../drivers/amdgpu/system.c:  if (!host_memory_pools->fine_region.handle) {
../../drivers/amdgpu/system.c:                              "no accessible-by-all + fine-grained shared "
../../drivers/amdgpu/system.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/system.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/system.c:  out_system->host_allocator = host_allocator;
../../drivers/amdgpu/system.c:      z0, iree_hal_amdgpu_system_info_query(libhsa, &out_system->info));
../../drivers/amdgpu/system.c:      z0, iree_hal_amdgpu_kfd_open(&out_system->kfd_fd));
../../drivers/amdgpu/system.c:      z0, iree_hal_amdgpu_libhsa_copy(libhsa, &out_system->libhsa));
../../drivers/amdgpu/system.c:  // Copy the topology - today it's a plain-old-data struct and we can just
../../drivers/amdgpu/system.c:  memcpy(&out_system->topology, topology, sizeof(out_system->topology));
../../drivers/amdgpu/system.c:  out_system->options = options;
../../drivers/amdgpu/system.c:      &out_system->libhsa, topology, host_allocator,
../../drivers/amdgpu/system.c:      &out_system->device_library);
../../drivers/amdgpu/system.c:         host_ordinal < topology->cpu_agent_count; ++host_ordinal) {
../../drivers/amdgpu/system.c:          &out_system->host_memory_pools[host_ordinal];
../../drivers/amdgpu/system.c:          libhsa, topology->cpu_agents[host_ordinal], host_memory_pools);
../../drivers/amdgpu/system.c:          &out_system->libhsa, topology->cpu_agents[host_ordinal],
../../drivers/amdgpu/system.c:  // Unload the device library - no references to it should remain.
../../drivers/amdgpu/system.c:  iree_hal_amdgpu_device_library_deinitialize(&system->device_library);
../../drivers/amdgpu/system.c:  iree_hal_amdgpu_kfd_close(system->kfd_fd);
../../drivers/amdgpu/system.c:  iree_hal_amdgpu_libhsa_deinitialize(&system->libhsa);
../../drivers/amdgpu/system.c:              sizeof(*system) + topology->cpu_agent_count *
../../drivers/amdgpu/system.c:                                    sizeof(system->host_memory_pools[0]),
../../drivers/amdgpu/system.c:  iree_allocator_t host_allocator = system->host_allocator;
../../drivers/vulkan/direct_command_queue.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/direct_command_queue.cc:  // TODO(benvanik): see if we can go to finer-grained stages.
../../drivers/vulkan/direct_command_queue.cc:  // the pseudo-stage of VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT.
../../drivers/vulkan/direct_command_queue.cc:      arena->AllocateSpan<VkSemaphore>(batch->wait_semaphores.count);
../../drivers/vulkan/direct_command_queue.cc:      arena->AllocateSpan<uint64_t>(batch->wait_semaphores.count);
../../drivers/vulkan/direct_command_queue.cc:      arena->AllocateSpan<VkPipelineStageFlags>(batch->wait_semaphores.count);
../../drivers/vulkan/direct_command_queue.cc:  for (iree_host_size_t i = 0; i < batch->wait_semaphores.count; ++i) {
../../drivers/vulkan/direct_command_queue.cc:        batch->wait_semaphores.semaphores[i]);
../../drivers/vulkan/direct_command_queue.cc:    wait_semaphore_values[i] = batch->wait_semaphores.payload_values[i];
../../drivers/vulkan/direct_command_queue.cc:      arena->AllocateSpan<VkSemaphore>(batch->signal_semaphores.count);
../../drivers/vulkan/direct_command_queue.cc:      arena->AllocateSpan<uint64_t>(batch->signal_semaphores.count);
../../drivers/vulkan/direct_command_queue.cc:  for (iree_host_size_t i = 0; i < batch->signal_semaphores.count; ++i) {
../../drivers/vulkan/direct_command_queue.cc:        batch->signal_semaphores.semaphores[i]);
../../drivers/vulkan/direct_command_queue.cc:    signal_semaphore_values[i] = batch->signal_semaphores.payload_values[i];
../../drivers/vulkan/direct_command_queue.cc:      arena->AllocateSpan<VkCommandBuffer>(batch->command_buffer_count);
../../drivers/vulkan/direct_command_queue.cc:  for (iree_host_size_t i = 0; i < batch->command_buffer_count; ++i) {
../../drivers/vulkan/direct_command_queue.cc:        iree_hal_vulkan_direct_command_buffer_handle(batch->command_buffers[i]);
../../drivers/vulkan/direct_command_queue.cc:  submit_info->sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
../../drivers/vulkan/direct_command_queue.cc:  submit_info->pNext = timeline_submit_info;
../../drivers/vulkan/direct_command_queue.cc:  submit_info->waitSemaphoreCount =
../../drivers/vulkan/direct_command_queue.cc:  submit_info->pWaitSemaphores = wait_semaphore_handles.data();
../../drivers/vulkan/direct_command_queue.cc:  submit_info->pWaitDstStageMask = wait_dst_stage_masks.data();
../../drivers/vulkan/direct_command_queue.cc:  submit_info->commandBufferCount =
../../drivers/vulkan/direct_command_queue.cc:  submit_info->pCommandBuffers = command_buffer_handles.data();
../../drivers/vulkan/direct_command_queue.cc:  submit_info->signalSemaphoreCount =
../../drivers/vulkan/direct_command_queue.cc:  submit_info->pSignalSemaphores = signal_semaphore_handles.data();
../../drivers/vulkan/direct_command_queue.cc:  timeline_submit_info->sType =
../../drivers/vulkan/direct_command_queue.cc:  timeline_submit_info->pNext = nullptr;
../../drivers/vulkan/direct_command_queue.cc:  timeline_submit_info->waitSemaphoreValueCount =
../../drivers/vulkan/direct_command_queue.cc:  timeline_submit_info->pWaitSemaphoreValues = wait_semaphore_values.data();
../../drivers/vulkan/direct_command_queue.cc:  timeline_submit_info->signalSemaphoreValueCount =
../../drivers/vulkan/direct_command_queue.cc:  timeline_submit_info->pSignalSemaphoreValues = signal_semaphore_values.data();
../../drivers/vulkan/direct_command_queue.cc:      syms()->vkQueueSubmit(queue_, static_cast<uint32_t>(submit_infos.size()),
../../drivers/vulkan/direct_command_queue.cc:        VK_RESULT_TO_STATUS(syms()->vkQueueWaitIdle(queue_), "vkQueueWaitIdle");
../../drivers/vulkan/direct_command_queue.cc:  // Create a new fence just for this wait. This keeps us thread-safe as the
../../drivers/vulkan/direct_command_queue.cc:      syms()->vkCreateFence(*logical_device_, &create_info,
../../drivers/vulkan/direct_command_queue.cc:                            logical_device_->allocator(), &fence),
../../drivers/vulkan/direct_command_queue.cc:    timeout_ns = (uint64_t)(deadline_ns - now_ns);
../../drivers/vulkan/direct_command_queue.cc:      syms()->vkQueueSubmit(queue_, 0, nullptr, fence), "vkQueueSubmit");
../../drivers/vulkan/direct_command_queue.cc:    VkResult result = syms()->vkWaitForFences(*logical_device_, 1, &fence,
../../drivers/vulkan/direct_command_queue.cc:  syms()->vkDestroyFence(*logical_device_, fence, logical_device_->allocator());
../../drivers/amdgpu/registration/CMakeLists.txt:# CMake-only content.                                                          #
../../drivers/vulkan/vulkan_driver.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/vulkan_driver.cc:  // different function pointers for device-specific functions that change
../../drivers/vulkan/vulkan_driver.cc:  out_options->api_version = VK_API_VERSION_1_2;
../../drivers/vulkan/vulkan_driver.cc:  out_options->requested_features = 0;
../../drivers/vulkan/vulkan_driver.cc:  out_options->debug_verbosity = 0;
../../drivers/vulkan/vulkan_driver.cc:  iree_hal_vulkan_device_options_initialize(&out_options->device_options);
../../drivers/vulkan/vulkan_driver.cc:// We may allow hosting applications to override this via weak-linkage if it's
../../drivers/vulkan/vulkan_driver.cc:  out_app_info->sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
../../drivers/vulkan/vulkan_driver.cc:  out_app_info->pNext = NULL;
../../drivers/vulkan/vulkan_driver.cc:  out_app_info->pApplicationName = "IREE-ML";
../../drivers/vulkan/vulkan_driver.cc:  out_app_info->applicationVersion = 0;
../../drivers/vulkan/vulkan_driver.cc:  out_app_info->pEngineName = "IREE";
../../drivers/vulkan/vulkan_driver.cc:  out_app_info->engineVersion = 0;
../../drivers/vulkan/vulkan_driver.cc:  out_app_info->apiVersion = options->api_version;
../../drivers/vulkan/vulkan_driver.cc:  // TODO(benvanik): strip in min-size release builds.
../../drivers/vulkan/vulkan_driver.cc:        instance, instance_syms, options->debug_verbosity,
../../drivers/vulkan/vulkan_driver.cc:                               &driver->resource);
../../drivers/vulkan/vulkan_driver.cc:  driver->host_allocator = host_allocator;
../../drivers/vulkan/vulkan_driver.cc:      identifier, &driver->identifier,
../../drivers/vulkan/vulkan_driver.cc:      (char*)driver + total_size - identifier.size);
../../drivers/vulkan/vulkan_driver.cc:  memcpy(&driver->device_options, &options->device_options,
../../drivers/vulkan/vulkan_driver.cc:         sizeof(driver->device_options));
../../drivers/vulkan/vulkan_driver.cc:  driver->enabled_features = options->requested_features;
../../drivers/vulkan/vulkan_driver.cc:  driver->syms = iree::add_ref(instance_syms);
../../drivers/vulkan/vulkan_driver.cc:  driver->instance = instance;
../../drivers/vulkan/vulkan_driver.cc:  driver->owns_instance = owns_instance;
../../drivers/vulkan/vulkan_driver.cc:  driver->debug_reporter = debug_reporter;
../../drivers/vulkan/vulkan_driver.cc:  iree_allocator_t host_allocator = driver->host_allocator;
../../drivers/vulkan/vulkan_driver.cc:  iree_hal_vulkan_debug_reporter_free(driver->debug_reporter);
../../drivers/vulkan/vulkan_driver.cc:  if (driver->owns_instance) {
../../drivers/vulkan/vulkan_driver.cc:    driver->syms->vkDestroyInstance(driver->instance, /*pAllocator=*/NULL);
../../drivers/vulkan/vulkan_driver.cc:  driver->syms.reset();
../../drivers/vulkan/vulkan_driver.cc:      requested_features, set, 0, &out_string_list->count, NULL));
../../drivers/vulkan/vulkan_driver.cc:  out_string_list->values = (const char**)arena->AllocateBytes(
../../drivers/vulkan/vulkan_driver.cc:      out_string_list->count * sizeof(out_string_list->values[0]));
../../drivers/vulkan/vulkan_driver.cc:      requested_features, set, out_string_list->count, &out_string_list->count,
../../drivers/vulkan/vulkan_driver.cc:      out_string_list->values));
../../drivers/vulkan/vulkan_driver.cc:          instance_syms, options->requested_features, &arena, &enabled_layers,
../../drivers/vulkan/vulkan_driver.cc:  VK_RETURN_IF_ERROR(instance_syms->vkCreateInstance(
../../drivers/vulkan/vulkan_driver.cc:  iree_status_t status = instance_syms->LoadFromInstance(instance);
../../drivers/vulkan/vulkan_driver.cc:    instance_syms->vkDestroyInstance(instance, /*pAllocator=*/NULL);
../../drivers/vulkan/vulkan_driver.cc:                            "a non-NULL VkInstance must be provided");
../../drivers/vulkan/vulkan_driver.cc:  // May be a no-op but don't rely on that so we can be sure we have the right
../../drivers/vulkan/vulkan_driver.cc:  IREE_RETURN_IF_ERROR(instance_syms->LoadFromInstance(instance));
../../drivers/vulkan/vulkan_driver.cc:  // extensions or even query if they are really enabled - we just have to trust
../../drivers/vulkan/vulkan_driver.cc:          instance_syms, options->requested_features, &arena, &enabled_layers,
../../drivers/vulkan/vulkan_driver.cc:  VK_RETURN_IF_ERROR(instance_syms->vkEnumeratePhysicalDevices(
../../drivers/vulkan/vulkan_driver.cc:      instance_syms->vkEnumeratePhysicalDevices(
../../drivers/vulkan/vulkan_driver.cc:  syms->vkGetPhysicalDeviceProperties(physical_device,
../../drivers/vulkan/vulkan_driver.cc:  // syms->vkGetPhysicalDeviceFeatures(physical_device,
../../drivers/vulkan/vulkan_driver.cc:  // - physical_device_features.robustBufferAccess
../../drivers/vulkan/vulkan_driver.cc:  // - physical_device_features.shaderInt16
../../drivers/vulkan/vulkan_driver.cc:  // - physical_device_features.shaderInt64
../../drivers/vulkan/vulkan_driver.cc:  // - physical_device_features.shaderFloat64
../../drivers/vulkan/vulkan_driver.cc:  if (strstr(physical_device_properties->deviceName, "llvmpipe") ==
../../drivers/vulkan/vulkan_driver.cc:      physical_device_properties->deviceName) {
../../drivers/vulkan/vulkan_driver.cc:  syms->vkGetPhysicalDeviceFeatures(physical_device, &physical_device_features);
../../drivers/vulkan/vulkan_driver.cc:  syms->vkGetPhysicalDeviceProperties2(physical_device, &device_props2);
../../drivers/vulkan/vulkan_driver.cc:  out_device_info->device_id = (iree_hal_device_id_t)physical_device;
../../drivers/vulkan/vulkan_driver.cc:  // Use the deviceUUID - which is _mostly_ persistent - as the primary path.
../../drivers/vulkan/vulkan_driver.cc:           "%02x%02x%02x%02x-"
../../drivers/vulkan/vulkan_driver.cc:           "%02x%02x-"
../../drivers/vulkan/vulkan_driver.cc:           "%02x%02x-"
../../drivers/vulkan/vulkan_driver.cc:           "%02x%02x-"
../../drivers/vulkan/vulkan_driver.cc:      device_path_str, IREE_ARRAYSIZE(device_path_str) - 1);
../../drivers/vulkan/vulkan_driver.cc:      device_path, &out_device_info->path, (char*)buffer_ptr);
../../drivers/vulkan/vulkan_driver.cc:      device_name, &out_device_info->name, (char*)buffer_ptr);
../../drivers/vulkan/vulkan_driver.cc:      driver->syms.get(), driver->instance, host_allocator,
../../drivers/vulkan/vulkan_driver.cc:        physical_devices[i], driver->syms.get());
../../drivers/vulkan/vulkan_driver.cc:          physical_devices[i], driver->syms.get(), buffer_ptr,
../../drivers/vulkan/vulkan_driver.cc:              driver->syms.get(), driver->instance, host_allocator,
../../drivers/vulkan/vulkan_driver.cc:      driver->syms.get()->vkGetPhysicalDeviceFeatures(
../../drivers/vulkan/vulkan_driver.cc:      driver->syms.get()->vkGetPhysicalDeviceProperties(
../../drivers/vulkan/vulkan_driver.cc:      probe_device_index -= 1;
../../drivers/vulkan/vulkan_driver.cc:  // driver->syms->vkGetPhysicalDeviceProperties(physical_device,
../../drivers/vulkan/vulkan_driver.cc:      base_driver, device_name, driver->enabled_features,
../../drivers/vulkan/vulkan_driver.cc:      &driver->device_options, (iree_hal_vulkan_syms_t*)driver->syms.get(),
../../drivers/vulkan/vulkan_driver.cc:      driver->instance, physical_device, host_allocator, out_device);
../../drivers/vulkan/vulkan_driver.cc:              driver->syms.get(), driver->instance, host_allocator,
../../drivers/vulkan/vulkan_driver.cc:    driver->syms->vkGetPhysicalDeviceProperties2(physical_devices[i],
../../drivers/vulkan/vulkan_driver.cc:        "%02x%02x%02x%02x-"
../../drivers/vulkan/vulkan_driver.cc:        "%02x%02x-"
../../drivers/vulkan/vulkan_driver.cc:        "%02x%02x-"
../../drivers/vulkan/vulkan_driver.cc:        "%02x%02x-"
../../drivers/vulkan/vulkan_driver.cc:  // TODO(benvanik): add more ways of addressing devices - maybe vendor:device?
../../drivers/amdgpu/semaphore_pool.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/semaphore_pool.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/semaphore_pool.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/semaphore_pool.h:// on-demand and contain a fixed-size set of HAL semaphores allocated inline.
../../drivers/amdgpu/semaphore_pool.h:// Thread-safe; multiple host threads may share the same pool.
../../drivers/amdgpu/semaphore_pool.h:  // A doubly-linked list of all allocated blocks.
../../drivers/amdgpu/semaphore_pool.h:  // A singly-linked list of blocks that have one or more free semaphore.
../../drivers/amdgpu/semaphore_pool.h:// The device |memory_pool| will be used for device-visible allocations.
../../drivers/vulkan/direct_command_buffer.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/direct_command_buffer.cc:  // TODO(benvanik): may grow large - should try to reclaim or reuse.
../../drivers/vulkan/direct_command_buffer.cc:  // This must remain valid until all in-flight submissions of the command
../../drivers/vulkan/direct_command_buffer.cc:      z0, command_pool->Allocate(&allocate_info, &handle));
../../drivers/vulkan/direct_command_buffer.cc:      logical_device->host_allocator(),
../../drivers/vulkan/direct_command_buffer.cc:        &iree_hal_vulkan_direct_command_buffer_vtable, &command_buffer->base);
../../drivers/vulkan/direct_command_buffer.cc:    command_buffer->logical_device = logical_device;
../../drivers/vulkan/direct_command_buffer.cc:    command_buffer->tracing_context = tracing_context;
../../drivers/vulkan/direct_command_buffer.cc:    command_buffer->block_pool = block_pool;
../../drivers/vulkan/direct_command_buffer.cc:    command_buffer->command_pool = command_pool;
../../drivers/vulkan/direct_command_buffer.cc:    command_buffer->handle = handle;
../../drivers/vulkan/direct_command_buffer.cc:    command_buffer->syms = logical_device->syms().get();
../../drivers/vulkan/direct_command_buffer.cc:    new (&command_buffer->descriptor_set_arena)
../../drivers/vulkan/direct_command_buffer.cc:    new (&command_buffer->descriptor_set_group) DescriptorSetGroup();
../../drivers/vulkan/direct_command_buffer.cc:    command_buffer->builtin_executables = builtin_executables;
../../drivers/vulkan/direct_command_buffer.cc:                                            &command_buffer->resource_set);
../../drivers/vulkan/direct_command_buffer.cc:    *out_command_buffer = &command_buffer->base;
../../drivers/vulkan/direct_command_buffer.cc:    command_pool->Free(handle);
../../drivers/vulkan/direct_command_buffer.cc:  return iree_hal_resource_is(&command_buffer->resource,
../../drivers/vulkan/direct_command_buffer.cc:      command_buffer->logical_device->host_allocator();
../../drivers/vulkan/direct_command_buffer.cc:  command_buffer->command_pool->Free(command_buffer->handle);
../../drivers/vulkan/direct_command_buffer.cc:  IREE_IGNORE_ERROR(command_buffer->descriptor_set_group.Reset());
../../drivers/vulkan/direct_command_buffer.cc:  command_buffer->descriptor_set_group.~DescriptorSetGroup();
../../drivers/vulkan/direct_command_buffer.cc:  command_buffer->descriptor_set_arena.~DescriptorSetArena();
../../drivers/vulkan/direct_command_buffer.cc:  iree_hal_resource_set_free(command_buffer->resource_set);
../../drivers/vulkan/direct_command_buffer.cc:  return command_buffer->handle;
../../drivers/vulkan/direct_command_buffer.cc:  begin_info.flags = iree_all_bits_set(command_buffer->base.mode,
../../drivers/vulkan/direct_command_buffer.cc:  VK_RETURN_IF_ERROR(command_buffer->syms->vkBeginCommandBuffer(
../../drivers/vulkan/direct_command_buffer.cc:                         command_buffer->handle, &begin_info),
../../drivers/vulkan/direct_command_buffer.cc:      command_buffer->tracing_context, command_buffer->handle,
../../drivers/vulkan/direct_command_buffer.cc:  IREE_VULKAN_TRACE_ZONE_END(command_buffer->tracing_context,
../../drivers/vulkan/direct_command_buffer.cc:                             command_buffer->handle);
../../drivers/vulkan/direct_command_buffer.cc:      command_buffer->syms->vkEndCommandBuffer(command_buffer->handle),
../../drivers/vulkan/direct_command_buffer.cc:  command_buffer->descriptor_set_group =
../../drivers/vulkan/direct_command_buffer.cc:      command_buffer->descriptor_set_arena.Flush();
../../drivers/vulkan/direct_command_buffer.cc:  iree_hal_resource_set_freeze(command_buffer->resource_set);
../../drivers/vulkan/direct_command_buffer.cc:      command_buffer->tracing_context, command_buffer->handle,
../../drivers/vulkan/direct_command_buffer.cc:      location ? location->file.data : NULL, location ? location->file.size : 0,
../../drivers/vulkan/direct_command_buffer.cc:      location ? location->line : 0, /*func_name=*/NULL, 0, label.data,
../../drivers/vulkan/direct_command_buffer.cc:  if (command_buffer->syms->vkCmdBeginDebugUtilsLabelEXT) {
../../drivers/vulkan/direct_command_buffer.cc:    command_buffer->syms->vkCmdBeginDebugUtilsLabelEXT(command_buffer->handle,
../../drivers/vulkan/direct_command_buffer.cc:  if (command_buffer->syms->vkCmdEndDebugUtilsLabelEXT) {
../../drivers/vulkan/direct_command_buffer.cc:    command_buffer->syms->vkCmdEndDebugUtilsLabelEXT(command_buffer->handle);
../../drivers/vulkan/direct_command_buffer.cc:  IREE_VULKAN_TRACE_ZONE_END(command_buffer->tracing_context,
../../drivers/vulkan/direct_command_buffer.cc:                             command_buffer->handle);
../../drivers/vulkan/direct_command_buffer.cc:      command_buffer->logical_device->host_allocator();
../../drivers/vulkan/direct_command_buffer.cc:    info->sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER;
../../drivers/vulkan/direct_command_buffer.cc:    info->pNext = NULL;
../../drivers/vulkan/direct_command_buffer.cc:    info->srcAccessMask =
../../drivers/vulkan/direct_command_buffer.cc:    info->dstAccessMask =
../../drivers/vulkan/direct_command_buffer.cc:    info->sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER;
../../drivers/vulkan/direct_command_buffer.cc:    info->pNext = NULL;
../../drivers/vulkan/direct_command_buffer.cc:    info->srcAccessMask =
../../drivers/vulkan/direct_command_buffer.cc:    info->dstAccessMask =
../../drivers/vulkan/direct_command_buffer.cc:    info->srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
../../drivers/vulkan/direct_command_buffer.cc:    info->dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
../../drivers/vulkan/direct_command_buffer.cc:    info->buffer =
../../drivers/vulkan/direct_command_buffer.cc:    info->offset = buffer_barrier.buffer_ref.offset;
../../drivers/vulkan/direct_command_buffer.cc:    info->size = buffer_barrier.buffer_ref.length;
../../drivers/vulkan/direct_command_buffer.cc:  command_buffer->syms->vkCmdPipelineBarrier(
../../drivers/vulkan/direct_command_buffer.cc:      command_buffer->handle,
../../drivers/vulkan/direct_command_buffer.cc:      iree_hal_resource_set_insert(command_buffer->resource_set, 1, &event));
../../drivers/vulkan/direct_command_buffer.cc:  command_buffer->syms->vkCmdSetEvent(
../../drivers/vulkan/direct_command_buffer.cc:      command_buffer->handle, iree_hal_vulkan_native_event_handle(event),
../../drivers/vulkan/direct_command_buffer.cc:      iree_hal_resource_set_insert(command_buffer->resource_set, 1, &event));
../../drivers/vulkan/direct_command_buffer.cc:  command_buffer->syms->vkCmdResetEvent(
../../drivers/vulkan/direct_command_buffer.cc:      command_buffer->handle, iree_hal_vulkan_native_event_handle(event),
../../drivers/vulkan/direct_command_buffer.cc:      command_buffer->logical_device->host_allocator();
../../drivers/vulkan/direct_command_buffer.cc:      command_buffer->resource_set, event_count, events));
../../drivers/vulkan/direct_command_buffer.cc:    info->sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER;
../../drivers/vulkan/direct_command_buffer.cc:    info->pNext = NULL;
../../drivers/vulkan/direct_command_buffer.cc:    info->srcAccessMask =
../../drivers/vulkan/direct_command_buffer.cc:    info->dstAccessMask =
../../drivers/vulkan/direct_command_buffer.cc:    info->sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER;
../../drivers/vulkan/direct_command_buffer.cc:    info->pNext = NULL;
../../drivers/vulkan/direct_command_buffer.cc:    info->srcAccessMask =
../../drivers/vulkan/direct_command_buffer.cc:    info->dstAccessMask =
../../drivers/vulkan/direct_command_buffer.cc:    info->srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
../../drivers/vulkan/direct_command_buffer.cc:    info->dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
../../drivers/vulkan/direct_command_buffer.cc:    info->buffer =
../../drivers/vulkan/direct_command_buffer.cc:    info->offset = buffer_barrier.buffer_ref.offset;
../../drivers/vulkan/direct_command_buffer.cc:    info->size = buffer_barrier.buffer_ref.length;
../../drivers/vulkan/direct_command_buffer.cc:  command_buffer->syms->vkCmdWaitEvents(
../../drivers/vulkan/direct_command_buffer.cc:      command_buffer->handle, (uint32_t)event_count,
../../drivers/vulkan/direct_command_buffer.cc:  IREE_VULKAN_TRACE_ZONE_BEGIN(command_buffer->tracing_context,
../../drivers/vulkan/direct_command_buffer.cc:                               command_buffer->handle);
../../drivers/vulkan/direct_command_buffer.cc:      command_buffer->resource_set, 1, &target_ref.buffer));
../../drivers/vulkan/direct_command_buffer.cc:        command_buffer->builtin_executables->FillBufferUnaligned(
../../drivers/vulkan/direct_command_buffer.cc:            command_buffer->handle, &(command_buffer->descriptor_set_arena),
../../drivers/vulkan/direct_command_buffer.cc:    //            <-------> <---------------------> <------->
../../drivers/vulkan/direct_command_buffer.cc:    length -= (aligned_target_offset - target_ref.offset) +
../../drivers/vulkan/direct_command_buffer.cc:              (target_end - rounded_down_target_end);
../../drivers/vulkan/direct_command_buffer.cc:    // Note that vkCmdFillBuffer only accepts 4-byte aligned values so we need
../../drivers/vulkan/direct_command_buffer.cc:    // to splat out our variable-length pattern.
../../drivers/vulkan/direct_command_buffer.cc:    command_buffer->syms->vkCmdFillBuffer(command_buffer->handle,
../../drivers/vulkan/direct_command_buffer.cc:  IREE_VULKAN_TRACE_ZONE_END(command_buffer->tracing_context,
../../drivers/vulkan/direct_command_buffer.cc:                             command_buffer->handle);
../../drivers/vulkan/direct_command_buffer.cc:  IREE_VULKAN_TRACE_ZONE_BEGIN(command_buffer->tracing_context,
../../drivers/vulkan/direct_command_buffer.cc:                               command_buffer->handle);
../../drivers/vulkan/direct_command_buffer.cc:      command_buffer->resource_set, 1, &target_ref.buffer));
../../drivers/vulkan/direct_command_buffer.cc:  // may be slower than just using write-through mapped memory). The
../../drivers/vulkan/direct_command_buffer.cc:    command_buffer->syms->vkCmdUpdateBuffer(command_buffer->handle,
../../drivers/vulkan/direct_command_buffer.cc:    length -= chunk_length;
../../drivers/vulkan/direct_command_buffer.cc:  IREE_VULKAN_TRACE_ZONE_END(command_buffer->tracing_context,
../../drivers/vulkan/direct_command_buffer.cc:                             command_buffer->handle);
../../drivers/vulkan/direct_command_buffer.cc:  IREE_VULKAN_TRACE_ZONE_BEGIN(command_buffer->tracing_context,
../../drivers/vulkan/direct_command_buffer.cc:                               command_buffer->handle);
../../drivers/vulkan/direct_command_buffer.cc:      iree_hal_resource_set_insert(command_buffer->resource_set, 2, buffers));
../../drivers/vulkan/direct_command_buffer.cc:  command_buffer->syms->vkCmdCopyBuffer(command_buffer->handle,
../../drivers/vulkan/direct_command_buffer.cc:  IREE_VULKAN_TRACE_ZONE_END(command_buffer->tracing_context,
../../drivers/vulkan/direct_command_buffer.cc:                             command_buffer->handle);
../../drivers/vulkan/direct_command_buffer.cc:  iree_hal_vulkan_source_location_t source_location = pipeline->source_location;
../../drivers/vulkan/direct_command_buffer.cc:      command_buffer->tracing_context, command_buffer->handle,
../../drivers/vulkan/direct_command_buffer.cc:      command_buffer->resource_set, 1, &executable));
../../drivers/vulkan/direct_command_buffer.cc:      command_buffer->resource_set, resource_count, resources));
../../drivers/vulkan/direct_command_buffer.cc:        iree_hal_vulkan_pipeline_layout_handle(pipeline->layout);
../../drivers/vulkan/direct_command_buffer.cc:    command_buffer->syms->vkCmdPushConstants(
../../drivers/vulkan/direct_command_buffer.cc:        command_buffer->handle, pipeline_layout_handle,
../../drivers/vulkan/direct_command_buffer.cc:      command_buffer->resource_set, bindings.count, bindings.values,
../../drivers/vulkan/direct_command_buffer.cc:  IREE_RETURN_IF_ERROR(command_buffer->descriptor_set_arena.BindDescriptorSet(
../../drivers/vulkan/direct_command_buffer.cc:      command_buffer->handle, pipeline->layout, 0, bindings.count,
../../drivers/vulkan/direct_command_buffer.cc:  command_buffer->syms->vkCmdBindPipeline(
../../drivers/vulkan/direct_command_buffer.cc:      command_buffer->handle, VK_PIPELINE_BIND_POINT_COMPUTE, pipeline->handle);
../../drivers/vulkan/direct_command_buffer.cc:    command_buffer->syms->vkCmdDispatchIndirect(
../../drivers/vulkan/direct_command_buffer.cc:        command_buffer->handle, workgroup_count_buffer, workgroup_count_offset);
../../drivers/vulkan/direct_command_buffer.cc:    command_buffer->syms->vkCmdDispatch(
../../drivers/vulkan/direct_command_buffer.cc:        command_buffer->handle, config.workgroup_count[0],
../../drivers/vulkan/direct_command_buffer.cc:  IREE_VULKAN_TRACE_ZONE_END(command_buffer->tracing_context,
../../drivers/vulkan/direct_command_buffer.cc:                             command_buffer->handle);
../../drivers/amdgpu/system.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/system.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/system.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/system.h:  // Enable dispatch-level tracing (if device instrumentation is compiled in).
../../drivers/amdgpu/system.h:  // aggressively scheduling queue entries out-of-order.
../../drivers/amdgpu/system.h:  // Memory pool used for various system-level resources.
../../drivers/amdgpu/system.h:  // pool will be used cross-agent with atomics. This is likely to be located
../../drivers/amdgpu/system.h:  // Memory region used for various system-level resources.
../../drivers/amdgpu/system.h:// Thread-safe; systems are immutable once initialized.
../../drivers/amdgpu/semaphore_pool.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/semaphore_pool.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/semaphore_pool.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/semaphore_pool.c:// device-visible memory for the device-side library resources.
../../drivers/amdgpu/semaphore_pool.c:// Thread-safe; each block has its own lock for free list management.
../../drivers/amdgpu/semaphore_pool.c:  const iree_hal_amdgpu_libhsa_t* libhsa = semaphore_pool->libhsa;
../../drivers/amdgpu/semaphore_pool.c:      capacity * sizeof(block->free_list[0]);
../../drivers/amdgpu/semaphore_pool.c:      z0, iree_allocator_malloc(semaphore_pool->host_allocator,
../../drivers/amdgpu/semaphore_pool.c:  block->semaphore_pool = semaphore_pool;
../../drivers/amdgpu/semaphore_pool.c:  block->prev_block = NULL;
../../drivers/amdgpu/semaphore_pool.c:  block->next_block = NULL;
../../drivers/amdgpu/semaphore_pool.c:  block->next_free = NULL;
../../drivers/amdgpu/semaphore_pool.c:  block->capacity = capacity;
../../drivers/amdgpu/semaphore_pool.c:  block->device_allocation_ptr = NULL;
../../drivers/amdgpu/semaphore_pool.c:  iree_slim_mutex_initialize(&block->mutex);
../../drivers/amdgpu/semaphore_pool.c:      IREE_LIBHSA(libhsa), semaphore_pool->memory_pool, total_device_size,
../../drivers/amdgpu/semaphore_pool.c:      HSA_AMD_MEMORY_POOL_STANDARD_FLAG, (void**)&block->device_allocation_ptr);
../../drivers/amdgpu/semaphore_pool.c:    const iree_hal_amdgpu_topology_t* topology = semaphore_pool->topology;
../../drivers/amdgpu/semaphore_pool.c:        IREE_LIBHSA(libhsa), topology->all_agent_count, topology->all_agents,
../../drivers/amdgpu/semaphore_pool.c:        /*flags=*/NULL, block->device_allocation_ptr);
../../drivers/amdgpu/semaphore_pool.c:        (iree_hal_amdgpu_device_semaphore_t*)block->device_allocation_ptr;
../../drivers/amdgpu/semaphore_pool.c:    block->free_count = capacity;
../../drivers/amdgpu/semaphore_pool.c:          semaphore_pool->libhsa, semaphore_pool->options, flags,
../../drivers/amdgpu/semaphore_pool.c:      block->free_list[i] = semaphore;
../../drivers/amdgpu/semaphore_pool.c:  iree_slim_mutex_lock(&block->mutex);
../../drivers/amdgpu/semaphore_pool.c:  IREE_ASSERT_EQ(block->free_count, block->capacity);
../../drivers/amdgpu/semaphore_pool.c:  iree_slim_mutex_unlock(&block->mutex);
../../drivers/amdgpu/semaphore_pool.c:      block->capacity * sizeof(block->free_list[0]);
../../drivers/amdgpu/semaphore_pool.c:  for (iree_host_size_t i = 0; i < block->capacity; ++i) {
../../drivers/amdgpu/semaphore_pool.c:  if (block->device_allocation_ptr) {
../../drivers/amdgpu/semaphore_pool.c:        IREE_LIBHSA(block->semaphore_pool->libhsa),
../../drivers/amdgpu/semaphore_pool.c:        block->device_allocation_ptr));
../../drivers/amdgpu/semaphore_pool.c:    block->device_allocation_ptr = NULL;
../../drivers/amdgpu/semaphore_pool.c:  iree_slim_mutex_deinitialize(&block->mutex);
../../drivers/amdgpu/semaphore_pool.c:  iree_allocator_free(block->semaphore_pool->host_allocator, block);
../../drivers/amdgpu/semaphore_pool.c:  IREE_ASSERT_REF_COUNT_ZERO(&semaphore->resource.ref_count);
../../drivers/amdgpu/semaphore_pool.c:  iree_slim_mutex_lock(&block->mutex);
../../drivers/amdgpu/semaphore_pool.c:  const bool full_to_free = block->free_count == 0;
../../drivers/amdgpu/semaphore_pool.c:  block->free_list[block->free_count++] = semaphore;
../../drivers/amdgpu/semaphore_pool.c:  iree_slim_mutex_unlock(&block->mutex);
../../drivers/amdgpu/semaphore_pool.c:  // NOTE: this happens outside of the per-block lock as the pool will hold its
../../drivers/amdgpu/semaphore_pool.c:    iree_hal_amdgpu_semaphore_pool_link_free_block(block->semaphore_pool,
../../drivers/amdgpu/semaphore_pool.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/semaphore_pool.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/semaphore_pool.c:  out_semaphore_pool->libhsa = libhsa;
../../drivers/amdgpu/semaphore_pool.c:  out_semaphore_pool->topology = topology;
../../drivers/amdgpu/semaphore_pool.c:  out_semaphore_pool->options = options;
../../drivers/amdgpu/semaphore_pool.c:  out_semaphore_pool->host_allocator = host_allocator;
../../drivers/amdgpu/semaphore_pool.c:  out_semaphore_pool->memory_pool = memory_pool;
../../drivers/amdgpu/semaphore_pool.c:  out_semaphore_pool->flags = flags;
../../drivers/amdgpu/semaphore_pool.c:  iree_slim_mutex_initialize(&out_semaphore_pool->mutex);
../../drivers/amdgpu/semaphore_pool.c:  out_semaphore_pool->list_head = NULL;
../../drivers/amdgpu/semaphore_pool.c:  out_semaphore_pool->free_head = NULL;
../../drivers/amdgpu/semaphore_pool.c:  out_semaphore_pool->block_capacity = capacity_per_allocation;
../../drivers/amdgpu/semaphore_pool.c:  iree_slim_mutex_lock(&semaphore_pool->mutex);
../../drivers/amdgpu/semaphore_pool.c:  iree_hal_amdgpu_semaphore_pool_block_t* block = semaphore_pool->list_head;
../../drivers/amdgpu/semaphore_pool.c:    iree_hal_amdgpu_semaphore_pool_block_t* next_block = block->next_block;
../../drivers/amdgpu/semaphore_pool.c:    IREE_ASSERT_EQ(block->free_count, block->capacity);
../../drivers/amdgpu/semaphore_pool.c:  semaphore_pool->list_head = NULL;
../../drivers/amdgpu/semaphore_pool.c:  semaphore_pool->free_head = NULL;
../../drivers/amdgpu/semaphore_pool.c:  iree_slim_mutex_unlock(&semaphore_pool->mutex);
../../drivers/amdgpu/semaphore_pool.c:  iree_slim_mutex_deinitialize(&semaphore_pool->mutex);
../../drivers/amdgpu/semaphore_pool.c:              semaphore_pool, semaphore_pool->block_capacity,
../../drivers/amdgpu/semaphore_pool.c:              semaphore_pool->flags, &block));
../../drivers/amdgpu/semaphore_pool.c:  block->prev_block = NULL;
../../drivers/amdgpu/semaphore_pool.c:  block->next_block = semaphore_pool->list_head;
../../drivers/amdgpu/semaphore_pool.c:  if (block->next_block) {
../../drivers/amdgpu/semaphore_pool.c:    block->next_block->prev_block = block;
../../drivers/amdgpu/semaphore_pool.c:  semaphore_pool->list_head = block;
../../drivers/amdgpu/semaphore_pool.c:  block->next_free = semaphore_pool->free_head;
../../drivers/amdgpu/semaphore_pool.c:  semaphore_pool->free_head = block;
../../drivers/amdgpu/semaphore_pool.c:      iree_host_size_ceil_div(count, semaphore_pool->block_capacity);
../../drivers/amdgpu/semaphore_pool.c:  iree_slim_mutex_lock(&semaphore_pool->mutex);
../../drivers/amdgpu/semaphore_pool.c:  if (semaphore_pool->free_head == NULL) {
../../drivers/amdgpu/semaphore_pool.c:    iree_hal_amdgpu_semaphore_pool_block_t* block = semaphore_pool->free_head;
../../drivers/amdgpu/semaphore_pool.c:    iree_slim_mutex_lock(&block->mutex);
../../drivers/amdgpu/semaphore_pool.c:    semaphore = block->free_list[block->free_count - 1];
../../drivers/amdgpu/semaphore_pool.c:    block->free_list[block->free_count - 1] = NULL;
../../drivers/amdgpu/semaphore_pool.c:    --block->free_count;
../../drivers/amdgpu/semaphore_pool.c:    if (block->free_count == 0) {
../../drivers/amdgpu/semaphore_pool.c:      semaphore_pool->free_head = block->next_free;
../../drivers/amdgpu/semaphore_pool.c:      block->next_free = NULL;
../../drivers/amdgpu/semaphore_pool.c:    iree_slim_mutex_unlock(&block->mutex);
../../drivers/amdgpu/semaphore_pool.c:  iree_slim_mutex_unlock(&semaphore_pool->mutex);
../../drivers/amdgpu/semaphore_pool.c:    iree_atomic_ref_count_inc(&semaphore->resource.ref_count);
../../drivers/amdgpu/semaphore_pool.c:  iree_slim_mutex_lock(&semaphore_pool->mutex);
../../drivers/amdgpu/semaphore_pool.c:  block->next_free = semaphore_pool->free_head;
../../drivers/amdgpu/semaphore_pool.c:  semaphore_pool->free_head = block;
../../drivers/amdgpu/semaphore_pool.c:  iree_slim_mutex_unlock(&semaphore_pool->mutex);
../../drivers/amdgpu/semaphore_pool.c:  iree_slim_mutex_lock(&semaphore_pool->mutex);
../../drivers/amdgpu/semaphore_pool.c:  iree_hal_amdgpu_semaphore_pool_block_t* block = semaphore_pool->free_head;
../../drivers/amdgpu/semaphore_pool.c:    iree_hal_amdgpu_semaphore_pool_block_t* next_block = block->next_free;
../../drivers/amdgpu/semaphore_pool.c:    if (block->free_count != block->capacity) {
../../drivers/amdgpu/semaphore_pool.c:      // One or more semaphores in use - cannot free the block.
../../drivers/amdgpu/semaphore_pool.c:      prev_block->next_free = next_block;
../../drivers/amdgpu/semaphore_pool.c:      semaphore_pool->free_head = next_block;
../../drivers/amdgpu/semaphore_pool.c:    if (block->prev_block != NULL) {
../../drivers/amdgpu/semaphore_pool.c:      block->prev_block->next_block = block->next_block;
../../drivers/amdgpu/semaphore_pool.c:      semaphore_pool->list_head = block->next_block;
../../drivers/amdgpu/semaphore_pool.c:    if (block->next_block != NULL) {
../../drivers/amdgpu/semaphore_pool.c:      block->next_block->prev_block = block->prev_block;
../../drivers/amdgpu/semaphore_pool.c:  iree_slim_mutex_unlock(&semaphore_pool->mutex);
../../drivers/vulkan/vulkan_device.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/vulkan/vulkan_device.cc://===----------------------------------------------------------------------===//
../../drivers/vulkan/vulkan_device.cc://===----------------------------------------------------------------------===//
../../drivers/vulkan/vulkan_device.cc:// Configure cmake with -DIREE_ENABLE_RENDERDOC_PROFILING=ON in order to
../../drivers/vulkan/vulkan_device.cc:// When compiled in the API will no-op itself if not running under a RenderDoc
../../drivers/vulkan/vulkan_device.cc:  // NOTE: RenderDoc only supports hooking so we can't use LoadLibrary - if
../../drivers/vulkan/vulkan_device.cc:  // dlopen/dlsym on posix-like systems. Note that each platform has its own
../../drivers/vulkan/vulkan_device.cc:  if (!RENDERDOC_GetAPI) return NULL;  // not found, no-op
../../drivers/vulkan/vulkan_device.cc:    // Failed to initialize API (old version, etc). No-op.
../../drivers/vulkan/vulkan_device.cc:  if (options->file_path) {
../../drivers/vulkan/vulkan_device.cc:    renderdoc_api->SetCaptureFilePathTemplate(options->file_path);
../../drivers/vulkan/vulkan_device.cc:  renderdoc_api->StartFrameCapture(
../../drivers/vulkan/vulkan_device.cc:  if (renderdoc_api->IsFrameCapturing()) {
../../drivers/vulkan/vulkan_device.cc:    renderdoc_api->EndFrameCapture(
../../drivers/vulkan/vulkan_device.cc://===----------------------------------------------------------------------===//
../../drivers/vulkan/vulkan_device.cc://===----------------------------------------------------------------------===//
../../drivers/vulkan/vulkan_device.cc:  //===--------------------------------------------------------------------===//
../../drivers/vulkan/vulkan_device.cc:  //===--------------------------------------------------------------------===//
../../drivers/vulkan/vulkan_device.cc:  // It exposes this extension to allow a non-conformant Vulkan implementation
../../drivers/vulkan/vulkan_device.cc:  // to be built on top of another non-Vulkan graphics API. This extension must
../../drivers/vulkan/vulkan_device.cc:  // Our generated SPIR-V kernels use storage buffers for all their data access.
../../drivers/vulkan/vulkan_device.cc:  //===--------------------------------------------------------------------===//
../../drivers/vulkan/vulkan_device.cc:  // Vulkan forward-compatibility shims
../../drivers/vulkan/vulkan_device.cc:  //===--------------------------------------------------------------------===//
../../drivers/vulkan/vulkan_device.cc:  // polyfill layer - enable if present. Ignored if timeline semaphores are
../../drivers/vulkan/vulkan_device.cc:  //===--------------------------------------------------------------------===//
../../drivers/vulkan/vulkan_device.cc:  //===--------------------------------------------------------------------===//
../../drivers/vulkan/vulkan_device.cc:  // This extension allows use of 8-bit types in uniform and storage buffers,
../../drivers/vulkan/vulkan_device.cc:  // This extension allows use of 16-bit floating-point types and 8-bit integer
../../drivers/vulkan/vulkan_device.cc:  // This extension exposes SIMD matrix-matrix multiply accumulate operations.
../../drivers/vulkan/vulkan_device.cc:  //===--------------------------------------------------------------------===//
../../drivers/vulkan/vulkan_device.cc:  //===--------------------------------------------------------------------===//
../../drivers/vulkan/vulkan_device.cc:  // our logging sinks. Note that this adds a non-trivial runtime overhead and
../../drivers/vulkan/vulkan_device.cc:    // itself and have some per-run variance in the skew (up to many
../../drivers/vulkan/vulkan_device.cc://===----------------------------------------------------------------------===//
../../drivers/vulkan/vulkan_device.cc://===----------------------------------------------------------------------===//
../../drivers/vulkan/vulkan_device.cc:#define IREE_HAL_VULKAN_INVALID_QUEUE_FAMILY_INDEX (-1)
../../drivers/vulkan/vulkan_device.cc:// driver-preferred) that has all of the |required_queue_flags| and none of
../../drivers/vulkan/vulkan_device.cc:    if (iree_all_bits_set(properties->queueFlags, required_queue_flags) &&
../../drivers/vulkan/vulkan_device.cc:        !iree_any_bit_set(properties->queueFlags, excluded_queue_flags)) {
../../drivers/vulkan/vulkan_device.cc:  syms->vkGetPhysicalDeviceQueueFamilyProperties(physical_device,
../../drivers/vulkan/vulkan_device.cc:  syms->vkGetPhysicalDeviceQueueFamilyProperties(
../../drivers/vulkan/vulkan_device.cc:  out_family_info->dispatch_index = IREE_HAL_VULKAN_INVALID_QUEUE_FAMILY_INDEX;
../../drivers/vulkan/vulkan_device.cc:  out_family_info->dispatch_queue_count = 0;
../../drivers/vulkan/vulkan_device.cc:  out_family_info->transfer_index = IREE_HAL_VULKAN_INVALID_QUEUE_FAMILY_INDEX;
../../drivers/vulkan/vulkan_device.cc:  out_family_info->transfer_queue_count = 0;
../../drivers/vulkan/vulkan_device.cc:  // compute-only queue such that we can run async with the rest of their
../../drivers/vulkan/vulkan_device.cc:  if (iree_all_bits_set(options->flags,
../../drivers/vulkan/vulkan_device.cc:    out_family_info->dispatch_index =
../../drivers/vulkan/vulkan_device.cc:  if (out_family_info->dispatch_index ==
../../drivers/vulkan/vulkan_device.cc:    out_family_info->dispatch_index =
../../drivers/vulkan/vulkan_device.cc:  if (out_family_info->dispatch_index ==
../../drivers/vulkan/vulkan_device.cc:  out_family_info->dispatch_queue_count =
../../drivers/vulkan/vulkan_device.cc:      queue_family_properties[out_family_info->dispatch_index].queueCount;
../../drivers/vulkan/vulkan_device.cc:  out_family_info->transfer_index =
../../drivers/vulkan/vulkan_device.cc:  if (out_family_info->transfer_index ==
../../drivers/vulkan/vulkan_device.cc:    out_family_info->transfer_index =
../../drivers/vulkan/vulkan_device.cc:  if (out_family_info->transfer_index ==
../../drivers/vulkan/vulkan_device.cc:    out_family_info->transfer_index =
../../drivers/vulkan/vulkan_device.cc:  if (out_family_info->transfer_index !=
../../drivers/vulkan/vulkan_device.cc:    out_family_info->transfer_queue_count =
../../drivers/vulkan/vulkan_device.cc:        queue_family_properties[out_family_info->transfer_index].queueCount;
../../drivers/vulkan/vulkan_device.cc:  if (out_family_info->dispatch_index == out_family_info->transfer_index) {
../../drivers/vulkan/vulkan_device.cc:    out_family_info->transfer_queue_count = iree_min(
../../drivers/vulkan/vulkan_device.cc:        queue_family_properties[out_family_info->dispatch_index].queueCount -
../../drivers/vulkan/vulkan_device.cc:            out_family_info->dispatch_queue_count,
../../drivers/vulkan/vulkan_device.cc:        out_family_info->transfer_queue_count);
../../drivers/vulkan/vulkan_device.cc:  out_family_info->dispatch_queue_count =
../../drivers/vulkan/vulkan_device.cc:      iree_min(2u, out_family_info->dispatch_queue_count);
../../drivers/vulkan/vulkan_device.cc:  out_family_info->transfer_queue_count =
../../drivers/vulkan/vulkan_device.cc:      iree_min(1u, out_family_info->transfer_queue_count);
../../drivers/vulkan/vulkan_device.cc:  out_compute_queue_set->queue_family_index = queue_family_info.dispatch_index;
../../drivers/vulkan/vulkan_device.cc:    out_compute_queue_set->queue_indices |= 1ull << i;
../../drivers/vulkan/vulkan_device.cc:  out_transfer_queue_set->queue_family_index = queue_family_info.transfer_index;
../../drivers/vulkan/vulkan_device.cc:    out_transfer_queue_set->queue_indices |= 1ull << (i + base_queue_index);
../../drivers/vulkan/vulkan_device.cc://===----------------------------------------------------------------------===//
../../drivers/vulkan/vulkan_device.cc://===----------------------------------------------------------------------===//
../../drivers/vulkan/vulkan_device.cc:  out_options->flags = 0;
../../drivers/vulkan/vulkan_device.cc:      logical_device->syms()->vkCreateCommandPool(
../../drivers/vulkan/vulkan_device.cc:          *logical_device, &create_info, logical_device->allocator(),
../../drivers/vulkan/vulkan_device.cc:          command_pool->mutable_value()),
../../drivers/vulkan/vulkan_device.cc:  logical_device->syms()->vkGetDeviceQueue(*logical_device, queue_family_index,
../../drivers/vulkan/vulkan_device.cc:  device->queue_count = 0;
../../drivers/vulkan/vulkan_device.cc:  device->dispatch_queue_count = 0;
../../drivers/vulkan/vulkan_device.cc:  device->transfer_queue_count = 0;
../../drivers/vulkan/vulkan_device.cc:      iree_math_count_ones_u64(compute_queue_set->queue_indices);
../../drivers/vulkan/vulkan_device.cc:      iree_math_count_ones_u64(transfer_queue_set->queue_indices);
../../drivers/vulkan/vulkan_device.cc:    if (!(compute_queue_set->queue_indices & (1ull << i))) continue;
../../drivers/vulkan/vulkan_device.cc:                 "Vulkan[%c:%d]", 'D', (int)device->dispatch_queue_count);
../../drivers/vulkan/vulkan_device.cc:        device->logical_device, IREE_HAL_COMMAND_CATEGORY_ANY,
../../drivers/vulkan/vulkan_device.cc:        compute_queue_set->queue_family_index, i);
../../drivers/vulkan/vulkan_device.cc:    iree_host_size_t queue_index = device->queue_count++;
../../drivers/vulkan/vulkan_device.cc:    device->queues[queue_index] = queue;
../../drivers/vulkan/vulkan_device.cc:    device->dispatch_queues[device->dispatch_queue_count++] = queue;
../../drivers/vulkan/vulkan_device.cc:      device->transfer_queues[device->transfer_queue_count++] = queue;
../../drivers/vulkan/vulkan_device.cc:      maintenance_dispatch_queue = queue->handle();
../../drivers/vulkan/vulkan_device.cc:          device->physical_device, device->logical_device, queue->handle(),
../../drivers/vulkan/vulkan_device.cc:          queue_name, maintenance_dispatch_queue, device->dispatch_command_pool,
../../drivers/vulkan/vulkan_device.cc:          device->host_allocator,
../../drivers/vulkan/vulkan_device.cc:          &device->queue_tracing_contexts[queue_index]));
../../drivers/vulkan/vulkan_device.cc:      queue->set_tracing_context(device->queue_tracing_contexts[queue_index]);
../../drivers/vulkan/vulkan_device.cc:    if (!(transfer_queue_set->queue_indices & (1ull << i))) continue;
../../drivers/vulkan/vulkan_device.cc:                 "Vulkan[%c:%d]", 'T', (int)device->transfer_queue_count);
../../drivers/vulkan/vulkan_device.cc:        device->logical_device, IREE_HAL_COMMAND_CATEGORY_TRANSFER,
../../drivers/vulkan/vulkan_device.cc:        transfer_queue_set->queue_family_index, i);
../../drivers/vulkan/vulkan_device.cc:    iree_host_size_t queue_index = device->queue_count++;
../../drivers/vulkan/vulkan_device.cc:    device->queues[queue_index] = queue;
../../drivers/vulkan/vulkan_device.cc:    device->transfer_queues[device->transfer_queue_count++] = queue;
../../drivers/vulkan/vulkan_device.cc:          device->physical_device, device->logical_device, queue->handle(),
../../drivers/vulkan/vulkan_device.cc:          queue_name, maintenance_dispatch_queue, device->dispatch_command_pool,
../../drivers/vulkan/vulkan_device.cc:          device->host_allocator,
../../drivers/vulkan/vulkan_device.cc:          &device->queue_tracing_contexts[queue_index]));
../../drivers/vulkan/vulkan_device.cc:      queue->set_tracing_context(device->queue_tracing_contexts[queue_index]);
../../drivers/vulkan/vulkan_device.cc:      iree_math_count_ones_u64(compute_queue_set->queue_indices);
../../drivers/vulkan/vulkan_device.cc:      iree_math_count_ones_u64(transfer_queue_set->queue_indices);
../../drivers/vulkan/vulkan_device.cc:      total_queue_count * sizeof(device->queues[0]) +
../../drivers/vulkan/vulkan_device.cc:      total_queue_count * sizeof(device->dispatch_queues[0]) +
../../drivers/vulkan/vulkan_device.cc:      total_queue_count * sizeof(device->transfer_queues[0]) +
../../drivers/vulkan/vulkan_device.cc:      total_queue_count * sizeof(device->queue_tracing_contexts[0]);
../../drivers/vulkan/vulkan_device.cc:                               &device->resource);
../../drivers/vulkan/vulkan_device.cc:  device->host_allocator = host_allocator;
../../drivers/vulkan/vulkan_device.cc:  device->driver = driver;
../../drivers/vulkan/vulkan_device.cc:  iree_hal_driver_retain(device->driver);
../../drivers/vulkan/vulkan_device.cc:      identifier, &device->identifier, (char*)buffer_ptr);
../../drivers/vulkan/vulkan_device.cc:  device->flags = options->flags;
../../drivers/vulkan/vulkan_device.cc:  device->device_extensions = *device_extensions;
../../drivers/vulkan/vulkan_device.cc:  device->device_properties = *device_properties;
../../drivers/vulkan/vulkan_device.cc:  device->instance = instance;
../../drivers/vulkan/vulkan_device.cc:  device->physical_device = physical_device;
../../drivers/vulkan/vulkan_device.cc:  device->logical_device = logical_device;
../../drivers/vulkan/vulkan_device.cc:  device->logical_device->AddReference();
../../drivers/vulkan/vulkan_device.cc:  device->renderdoc_api = iree_hal_vulkan_query_renderdoc_api(instance);
../../drivers/vulkan/vulkan_device.cc:                                   &device->block_pool);
../../drivers/vulkan/vulkan_device.cc:  device->queues = (CommandQueue**)buffer_ptr;
../../drivers/vulkan/vulkan_device.cc:  buffer_ptr += total_queue_count * sizeof(device->queues[0]);
../../drivers/vulkan/vulkan_device.cc:  device->dispatch_queues = (CommandQueue**)buffer_ptr;
../../drivers/vulkan/vulkan_device.cc:  buffer_ptr += total_queue_count * sizeof(device->dispatch_queues[0]);
../../drivers/vulkan/vulkan_device.cc:  device->transfer_queues = (CommandQueue**)buffer_ptr;
../../drivers/vulkan/vulkan_device.cc:  buffer_ptr += total_queue_count * sizeof(device->transfer_queues[0]);
../../drivers/vulkan/vulkan_device.cc:  device->queue_tracing_contexts =
../../drivers/vulkan/vulkan_device.cc:  buffer_ptr += total_queue_count * sizeof(device->queue_tracing_contexts[0]);
../../drivers/vulkan/vulkan_device.cc:  device->descriptor_pool_cache =
../../drivers/vulkan/vulkan_device.cc:      new DescriptorPoolCache(device->logical_device);
../../drivers/vulkan/vulkan_device.cc:      logical_device, &device->device_allocator);
../../drivers/vulkan/vulkan_device.cc:        device->logical_device, compute_queue_set->queue_family_index,
../../drivers/vulkan/vulkan_device.cc:        &device->dispatch_command_pool);
../../drivers/vulkan/vulkan_device.cc:  if (transfer_queue_set->queue_indices != 0 && iree_status_is_ok(status)) {
../../drivers/vulkan/vulkan_device.cc:        device->logical_device, transfer_queue_set->queue_family_index,
../../drivers/vulkan/vulkan_device.cc:        &device->transfer_command_pool);
../../drivers/vulkan/vulkan_device.cc:    device->builtin_executables =
../../drivers/vulkan/vulkan_device.cc:        new BuiltinExecutables(device->logical_device);
../../drivers/vulkan/vulkan_device.cc:    status = device->builtin_executables->InitializeExecutables();
../../drivers/vulkan/vulkan_device.cc:  for (iree_host_size_t i = 0; i < device->queue_count; ++i) {
../../drivers/vulkan/vulkan_device.cc:    delete device->queues[i];
../../drivers/vulkan/vulkan_device.cc:    iree_hal_vulkan_tracing_context_free(device->queue_tracing_contexts[i]);
../../drivers/vulkan/vulkan_device.cc:  delete device->dispatch_command_pool;
../../drivers/vulkan/vulkan_device.cc:  delete device->transfer_command_pool;
../../drivers/vulkan/vulkan_device.cc:  delete device->builtin_executables;
../../drivers/vulkan/vulkan_device.cc:  delete device->descriptor_pool_cache;
../../drivers/vulkan/vulkan_device.cc:  iree_hal_allocator_release(device->device_allocator);
../../drivers/vulkan/vulkan_device.cc:  iree_hal_channel_provider_release(device->channel_provider);
../../drivers/vulkan/vulkan_device.cc:  iree_arena_block_pool_deinitialize(&device->block_pool);
../../drivers/vulkan/vulkan_device.cc:  device->logical_device->ReleaseReference();
../../drivers/vulkan/vulkan_device.cc:  iree_hal_driver_release(device->driver);
../../drivers/vulkan/vulkan_device.cc:      requested_features, set, 0, &out_string_list->count, NULL));
../../drivers/vulkan/vulkan_device.cc:  out_string_list->values = (const char**)arena->AllocateBytes(
../../drivers/vulkan/vulkan_device.cc:      out_string_list->count * sizeof(out_string_list->values[0]));
../../drivers/vulkan/vulkan_device.cc:      requested_features, set, out_string_list->count, &out_string_list->count,
../../drivers/vulkan/vulkan_device.cc:      out_string_list->values));
../../drivers/vulkan/vulkan_device.cc:  instance_syms->vkGetPhysicalDeviceFeatures2(physical_device,
../../drivers/vulkan/vulkan_device.cc:  instance_syms->vkGetPhysicalDeviceProperties2(physical_device,
../../drivers/vulkan/vulkan_device.cc:    out_properties->compute_float |= 0x1u;
../../drivers/vulkan/vulkan_device.cc:    out_properties->compute_float |= 0x2u;
../../drivers/vulkan/vulkan_device.cc:    out_properties->compute_int |= 0x1u;
../../drivers/vulkan/vulkan_device.cc:    out_properties->compute_int |= 0x2u;
../../drivers/vulkan/vulkan_device.cc:    out_properties->compute_int |= 0x4u;
../../drivers/vulkan/vulkan_device.cc:    out_properties->storage |= 0x1u;
../../drivers/vulkan/vulkan_device.cc:    out_properties->storage |= 0x2u;
../../drivers/vulkan/vulkan_device.cc:    out_properties->subgroup |= 0x1u;
../../drivers/vulkan/vulkan_device.cc:    out_properties->subgroup |= 0x2u;
../../drivers/vulkan/vulkan_device.cc:    out_properties->dot_product |= 0x1u;
../../drivers/vulkan/vulkan_device.cc:      instance_syms->vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR) {
../../drivers/vulkan/vulkan_device.cc:        instance_syms->vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR(
../../drivers/vulkan/vulkan_device.cc:        instance_syms->vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR(
../../drivers/vulkan/vulkan_device.cc:      if (p->AType == VK_COMPONENT_TYPE_FLOAT16_KHR &&
../../drivers/vulkan/vulkan_device.cc:          p->BType == VK_COMPONENT_TYPE_FLOAT16_KHR) {
../../drivers/vulkan/vulkan_device.cc:        if (p->CType == VK_COMPONENT_TYPE_FLOAT16_KHR) {
../../drivers/vulkan/vulkan_device.cc:          if (p->MSize == 16 && p->NSize == 16 && p->KSize == 16) {
../../drivers/vulkan/vulkan_device.cc:            out_properties->cooperative_matrix |= 0x1u;
../../drivers/vulkan/vulkan_device.cc:    out_properties->address |= 0x1u;
../../drivers/vulkan/vulkan_device.cc:  out_properties->limits.max_push_constants_size =
../../drivers/vulkan/vulkan_device.cc:  out_properties->limits.max_per_stage_descriptor_uniform_buffers =
../../drivers/vulkan/vulkan_device.cc:  out_properties->limits.max_per_stage_descriptor_storage_buffers =
../../drivers/vulkan/vulkan_device.cc:  instance_syms->vkGetPhysicalDeviceFeatures2(physical_device,
../../drivers/vulkan/vulkan_device.cc:  if (available_features->shaderInt64) {
../../drivers/vulkan/vulkan_device.cc:  if (available_features->shaderInt16) {
../../drivers/vulkan/vulkan_device.cc:      available_features->sparseBinding) {
../../drivers/vulkan/vulkan_device.cc:      available_features->sparseResidencyBuffer &&
../../drivers/vulkan/vulkan_device.cc:      available_features->sparseResidencyAliased) {
../../drivers/vulkan/vulkan_device.cc:    if (available_features->robustBufferAccess != VK_TRUE) {
../../drivers/vulkan/vulkan_device.cc:  // Enable all available 16- or 8-bit integer/floating-point features.
../../drivers/vulkan/vulkan_device.cc:      instance_syms->vkCreateDevice(physical_device, &device_create_info,
../../drivers/vulkan/vulkan_device.cc:                                    logical_device->allocator(),
../../drivers/vulkan/vulkan_device.cc:                                    logical_device->mutable_value()),
../../drivers/vulkan/vulkan_device.cc:    status = logical_device->syms()->LoadFromDevice(instance,
../../drivers/vulkan/vulkan_device.cc:                                                    logical_device->value());
../../drivers/vulkan/vulkan_device.cc:        options, physical_device, logical_device->syms().get(),
../../drivers/vulkan/vulkan_device.cc:  logical_device->ReleaseReference();
../../drivers/vulkan/vulkan_device.cc:  if (iree_math_count_ones_u64(compute_queue_set->queue_indices) == 0) {
../../drivers/vulkan/vulkan_device.cc:  device_syms->vkGetInstanceProcAddr =
../../drivers/vulkan/vulkan_device.cc:      ((const DynamicSymbols*)instance_syms)->vkGetInstanceProcAddr;
../../drivers/vulkan/vulkan_device.cc:  IREE_RETURN_IF_ERROR(device_syms->LoadFromDevice(instance, logical_device));
../../drivers/vulkan/vulkan_device.cc:  // extensions or query if they are really enabled - we just have to trust
../../drivers/vulkan/vulkan_device.cc:  *logical_device_handle->mutable_value() = logical_device;
../../drivers/vulkan/vulkan_device.cc:  logical_device_handle->ReleaseReference();
../../drivers/vulkan/vulkan_device.cc:  return device->identifier;
../../drivers/vulkan/vulkan_device.cc:  return device->host_allocator;
../../drivers/vulkan/vulkan_device.cc:  return device->device_allocator;
../../drivers/vulkan/vulkan_device.cc:  iree_hal_allocator_release(device->device_allocator);
../../drivers/vulkan/vulkan_device.cc:  device->device_allocator = new_allocator;
../../drivers/vulkan/vulkan_device.cc:  iree_hal_channel_provider_release(device->channel_provider);
../../drivers/vulkan/vulkan_device.cc:  device->channel_provider = new_provider;
../../drivers/vulkan/vulkan_device.cc:  iree_arena_block_pool_trim(&device->block_pool);
../../drivers/vulkan/vulkan_device.cc:  return iree_hal_allocator_trim(device->device_allocator);
../../drivers/vulkan/vulkan_device.cc:        iree_string_view_match_pattern(device->identifier, key) ? 1 : 0;
../../drivers/vulkan/vulkan_device.cc:    if (iree_string_view_equal(key, IREE_SV("vulkan-spirv-fb"))) {
../../drivers/vulkan/vulkan_device.cc:      // Base SPIR-V always supported.
../../drivers/vulkan/vulkan_device.cc:    if (iree_string_view_equal(key, IREE_SV("vulkan-spirv-fb-ptr"))) {
../../drivers/vulkan/vulkan_device.cc:      // SPIR-V with device addresses is optionally supported based on whether
../../drivers/vulkan/vulkan_device.cc:                       device->logical_device->enabled_features(),
../../drivers/vulkan/vulkan_device.cc:      *out_value = device->logical_device->supported_properties().compute_float;
../../drivers/vulkan/vulkan_device.cc:      *out_value = device->logical_device->supported_properties().compute_int;
../../drivers/vulkan/vulkan_device.cc:      *out_value = device->logical_device->supported_properties().storage;
../../drivers/vulkan/vulkan_device.cc:      *out_value = device->logical_device->supported_properties().subgroup;
../../drivers/vulkan/vulkan_device.cc:      *out_value = device->logical_device->supported_properties().dot_product;
../../drivers/vulkan/vulkan_device.cc:          device->logical_device->supported_properties().cooperative_matrix;
../../drivers/vulkan/vulkan_device.cc:      *out_value = device->logical_device->supported_properties().address;
../../drivers/vulkan/vulkan_device.cc:        ->transfer_queues[queue_affinity % device->transfer_queue_count];
../../drivers/vulkan/vulkan_device.cc:  return device->dispatch_queues[queue_affinity % device->dispatch_queue_count];
../../drivers/vulkan/vulkan_device.cc:  // TODO(indirect-cmd): until implemented through the whole stack we use a
../../drivers/vulkan/vulkan_device.cc:        queue_affinity, binding_capacity, &device->block_pool,
../../drivers/vulkan/vulkan_device.cc:  if (device->transfer_command_pool &&
../../drivers/vulkan/vulkan_device.cc:    command_pool = device->transfer_command_pool;
../../drivers/vulkan/vulkan_device.cc:    command_pool = device->dispatch_command_pool;
../../drivers/vulkan/vulkan_device.cc:      iree_hal_device_allocator(base_device), device->logical_device,
../../drivers/vulkan/vulkan_device.cc:      queue->tracing_context(), device->descriptor_pool_cache,
../../drivers/vulkan/vulkan_device.cc:      device->builtin_executables, &device->block_pool, out_command_buffer);
../../drivers/vulkan/vulkan_device.cc:  return iree_hal_vulkan_native_event_create(device->logical_device,
../../drivers/vulkan/vulkan_device.cc:      device->logical_device, identifier, out_executable_cache);
../../drivers/vulkan/vulkan_device.cc:  return iree_hal_vulkan_native_semaphore_create(device->logical_device,
../../drivers/vulkan/vulkan_device.cc:    // Fast-path for semaphores related to this device.
../../drivers/vulkan/vulkan_device.cc:  // TODO(benvanik): queue-ordered allocations.
../../drivers/vulkan/vulkan_device.cc:  // TODO(benvanik): queue-ordered allocations.
../../drivers/vulkan/vulkan_device.cc:  // TODO(indirect-cmd): today we are using deferred command buffers to emulate
../../drivers/vulkan/vulkan_device.cc:  // indirect command buffers - this requires that we materialize real command
../../drivers/vulkan/vulkan_device.cc:    status = queue->Submit(1, &batch);
../../drivers/vulkan/vulkan_device.cc:  // TODO(indirect-cmd): when async these need to be retained until the
../../drivers/vulkan/vulkan_device.cc:      device->logical_device, &semaphore_list, timeout, wait_flags);
../../drivers/vulkan/vulkan_device.cc:  if (iree_all_bits_set(options->mode,
../../drivers/vulkan/vulkan_device.cc:    // AMD-specific - we could snoop the device to only do this for the vendor
../../drivers/vulkan/vulkan_device.cc:    auto& syms = device->logical_device->syms();
../../drivers/vulkan/vulkan_device.cc:    if (syms->vkQueueInsertDebugUtilsLabelEXT) {
../../drivers/vulkan/vulkan_device.cc:      device->logical_device->syms()->vkQueueInsertDebugUtilsLabelEXT(
../../drivers/vulkan/vulkan_device.cc:          device->dispatch_queues[0]->handle(), &begin_label);
../../drivers/vulkan/vulkan_device.cc:    // https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_performance_query.html
../../drivers/vulkan/vulkan_device.cc:    // Since RenderDoc is fairly simple, cross-platform, and cross-vendor we
../../drivers/vulkan/vulkan_device.cc:    iree_hal_vulkan_begin_renderdoc_capture(device->renderdoc_api,
../../drivers/vulkan/vulkan_device.cc:                                            device->instance, options);
../../drivers/vulkan/vulkan_device.cc:  if (iree_all_bits_set(device->logical_device->enabled_features(),
../../drivers/vulkan/vulkan_device.cc:    for (iree_host_size_t i = 0; i < device->queue_count; ++i) {
../../drivers/vulkan/vulkan_device.cc:          device->queues[i]->tracing_context();
../../drivers/vulkan/vulkan_device.cc:  iree_hal_vulkan_end_renderdoc_capture(device->renderdoc_api,
../../drivers/vulkan/vulkan_device.cc:                                        device->instance);
../../drivers/vulkan/vulkan_device.cc:  // AMD-specific.
../../drivers/vulkan/vulkan_device.cc:  auto& syms = device->logical_device->syms();
../../drivers/vulkan/vulkan_device.cc:  if (syms->vkQueueInsertDebugUtilsLabelEXT) {
../../drivers/vulkan/vulkan_device.cc:    device->logical_device->syms()->vkQueueInsertDebugUtilsLabelEXT(
../../drivers/vulkan/vulkan_device.cc:        device->dispatch_queues[0]->handle(), &end_label);
../../drivers/amdgpu/executable_cache.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/executable_cache.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/executable_cache.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/executable_cache.c:  IREE_ASSERT_GE(topology->gpu_agent_count, 1);
../../drivers/amdgpu/executable_cache.c:  if (IREE_UNLIKELY(topology->gpu_agent_count == 0)) {
../../drivers/amdgpu/executable_cache.c:                               &executable_cache->resource);
../../drivers/amdgpu/executable_cache.c:  executable_cache->host_allocator = host_allocator;
../../drivers/amdgpu/executable_cache.c:  executable_cache->libhsa = libhsa;
../../drivers/amdgpu/executable_cache.c:  executable_cache->topology = topology;
../../drivers/amdgpu/executable_cache.c:  iree_allocator_t host_allocator = executable_cache->host_allocator;
../../drivers/amdgpu/executable_cache.c:      executable_cache->libhsa, executable_cache->topology->gpu_agents[0],
../../drivers/amdgpu/executable_cache.c:      executable_cache->libhsa, executable_cache->topology, executable_params,
../../drivers/amdgpu/executable_cache.c:      executable_cache->host_allocator, out_executable);
../../drivers/amdgpu/virtual_queue.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/virtual_queue.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/virtual_queue.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/virtual_queue.c:  out_options->placement = IREE_HAL_AMDGPU_QUEUE_PLACEMENT_HOST;
../../drivers/amdgpu/virtual_queue.c:  out_options->flags = IREE_HAL_AMDGPU_QUEUE_FLAG_NONE;
../../drivers/amdgpu/virtual_queue.c:  out_options->mode = IREE_HAL_AMDGPU_QUEUE_SCHEDULING_MODE_DEFAULT;
../../drivers/amdgpu/virtual_queue.c:  out_options->control_queue_capacity =
../../drivers/amdgpu/virtual_queue.c:  out_options->execution_queue_count =
../../drivers/amdgpu/virtual_queue.c:  out_options->execution_queue_capacity =
../../drivers/amdgpu/virtual_queue.c:  out_options->kernarg_ringbuffer_capacity =
../../drivers/amdgpu/virtual_queue.c:  out_options->trace_buffer_capacity =
../../drivers/amdgpu/virtual_queue.c:// requirements and a power-of-two.
../../drivers/amdgpu/virtual_queue.c:  // All queues must be a power-of-two due to ringbuffer masking.
../../drivers/amdgpu/virtual_queue.c:  if (options->placement == IREE_HAL_AMDGPU_QUEUE_PLACEMENT_DEVICE) {
../../drivers/amdgpu/virtual_queue.c:    if (possible_placement != options->placement) {
../../drivers/amdgpu/virtual_queue.c:          "device-side queue placement requested but the device does not meet "
../../drivers/amdgpu/virtual_queue.c:      IREE_SV("control"), options->control_queue_capacity, queue_min_size,
../../drivers/amdgpu/virtual_queue.c:      IREE_SV("execution"), options->execution_queue_capacity, queue_min_size,
../../drivers/amdgpu/virtual_queue.c:  if (!iree_device_size_is_power_of_two(options->kernarg_ringbuffer_capacity)) {
../../drivers/amdgpu/virtual_queue.c:        options->kernarg_ringbuffer_capacity);
../../drivers/amdgpu/virtual_queue.c:  if (options->trace_buffer_capacity &&
../../drivers/amdgpu/virtual_queue.c:      !iree_device_size_is_power_of_two(options->trace_buffer_capacity)) {
../../drivers/amdgpu/virtual_queue.c:        options->trace_buffer_capacity);
../../drivers/amdgpu/channel.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/channel.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/channel.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/channel.c:                               &channel->resource);
../../drivers/amdgpu/channel.c:  channel->host_allocator = host_allocator;
../../drivers/amdgpu/channel.c:  iree_allocator_t host_allocator = channel->host_allocator;
../../drivers/amdgpu/channel.c:  iree_hal_channel_release(channel->parent_channel);
../../drivers/amdgpu/channel.c:        iree_allocator_malloc(channel->host_allocator, sizeof(*split_channel),
../../drivers/amdgpu/channel.c:                                 &split_channel->resource);
../../drivers/amdgpu/channel.c:    split_channel->host_allocator = channel->host_allocator;
../../drivers/amdgpu/channel.c:    split_channel->parent_channel = base_channel;
../../drivers/amdgpu/README.md:-DIREE_BUILD_COMPILER=ON
../../drivers/amdgpu/README.md:-DIREE_TARGET_BACKEND_ROCM=ON
../../drivers/amdgpu/README.md:-DIREE_HAL_DRIVER_AMDGPU=ON
../../drivers/amdgpu/README.md:-DIREE_HAL_AMDGPU_DEVICE_LIBRARY_TARGETS=gfx1100
../../drivers/amdgpu/README.md:-DIREE_HIP_TEST_TARGET_CHIP=gfx1100
../../drivers/amdgpu/README.md:iree-run-module --device=amdgpu
../../drivers/amdgpu/README.md:iree-run-module --device=amdgpu:0
../../drivers/amdgpu/README.md:iree-run-module --device=amdgpu://GPU-0e12865a3bf5b7ab
../../drivers/amdgpu/README.md:iree-run-module --device=amdgpu://GPU-0e12865a3bf5b7ab,GPU-89e8bdf59a10cf6d
../../drivers/amdgpu/README.md:ROCR_VISIBLE_DEVICES=2,3 iree-run-module --device=amdgpu
../../drivers/amdgpu/README.md:iree-run-module --device=amdgpu://0,1 --device=amdgpu://2,3
../../drivers/amdgpu/README.md:iree-compile --iree-hal-target-device=amdgpu ...
../../drivers/amdgpu/README.md:We maintain a fork of the HSA headers required for compilation as [third_party/hsa-runtime-headers/](https://github.com/iree-org/hsa-runtime-headers). This fork may also contain tweaks not yet upstreamed required to use the headers in our build.
../../drivers/amdgpu/README.md:We require that at runtime a dynamic library with the name `libhsa-runtime64.so` exists on the path. This can be overridden programmatically when constructing the driver, via the `--amdgpu_libhsa_search_path=` flag if using the command line tools, via the `IREE_HAL_AMDGPU_LIBHSA_PATH` environment variable, or by just adding a directory containing the file to `PATH`.
../../drivers/amdgpu/README.md:It's recommended that developers check out a copy of the [ROCR-Runtime](https://github.com/ROCm/ROCR-Runtime) and build it locally in whatever configuration they are using (debug/release/ASAN/etc). This allows for easier debugging and profiling as symbols are present and may be required to get recent features not available in platform installs. Eventually IREE will ship its own copy of the library (directly or indirectly) as part of the install packages such that only a relatively recent AMDGPU driver is required.
../../drivers/amdgpu/README.md:See [HSA/ROCR Library](#hsarocr-library) for more information on our usage.
../../drivers/amdgpu/README.md:**Required CMake Options**: `-DIREE_BUILD_COMPILER=ON -DIREE_TARGET_BACKEND_ROCM=ON`
../../drivers/amdgpu/README.md:**Top-level Build Target**: `iree_hal_drivers_amdgpu_device_binaries`
../../drivers/amdgpu/README.md:Currently IREE's CMake configuration must have the compiler enabled in order to build the runtime including the AMDGPU HAL implementation. This will be made better in the future (allowing for just building what we need instead of the full MLIR stack, using an existing ROCM install, etc). See [Device Library](#device-library) for more information.
../../drivers/amdgpu/driver.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/driver.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/driver.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/driver.c:      &out_options->default_device_options);
../../drivers/amdgpu/driver.c:  if (!params.count) return iree_ok_status();  // no-op
../../drivers/amdgpu/driver.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/driver.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/driver.c:  const iree_host_size_t length = new_offset - old_offset;
../../drivers/amdgpu/driver.c:    default_info->device_id = IREE_HAL_AMDGPU_DEVICE_ID_DEFAULT;
../../drivers/amdgpu/driver.c:    default_info->path = iree_string_view_empty();
../../drivers/amdgpu/driver.c:  if (topology->gpu_agent_count == 1) {
../../drivers/amdgpu/driver.c:        topology->gpu_agent_count));
../../drivers/amdgpu/driver.c:  for (iree_host_size_t i = 0; i < topology->gpu_agent_count; ++i) {
../../drivers/amdgpu/driver.c:                                                 topology->gpu_agents[i],
../../drivers/amdgpu/driver.c:                             default_info ? &default_info->name : NULL);
../../drivers/amdgpu/driver.c:    device_info->device_id = (iree_hal_device_id_t)device_id;
../../drivers/amdgpu/driver.c:  // Path is the device string ("GPU-0e12865a3bf5b7ab").
../../drivers/amdgpu/driver.c:  // We could support a form without the GPU- but the ROCR tools display it
../../drivers/amdgpu/driver.c:                             device_info ? &device_info->path : NULL);
../../drivers/amdgpu/driver.c:                             device_info ? &device_info->name : NULL);
../../drivers/amdgpu/driver.c:    for (iree_host_size_t i = 0; i < topology->gpu_agent_count; ++i) {
../../drivers/amdgpu/driver.c:          libhsa, topology->gpu_agents[i], i,
../../drivers/amdgpu/driver.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/driver.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/driver.c:      libhsa_flags, options->libhsa_search_paths, host_allocator, out_libhsa);
../../drivers/amdgpu/driver.c:                               &driver->resource);
../../drivers/amdgpu/driver.c:  driver->host_allocator = host_allocator;
../../drivers/amdgpu/driver.c:      identifier, &driver->identifier,
../../drivers/amdgpu/driver.c:      (char*)driver + total_size - identifier.size);
../../drivers/amdgpu/driver.c:  memcpy(&driver->options, options, sizeof(*options));
../../drivers/amdgpu/driver.c:      &driver->options, host_allocator, &driver->libhsa);
../../drivers/amdgpu/driver.c:  iree_allocator_t host_allocator = driver->host_allocator;
../../drivers/amdgpu/driver.c:  iree_hal_amdgpu_libhsa_deinitialize(&driver->libhsa);
../../drivers/amdgpu/driver.c:      &driver->libhsa, &topology));
../../drivers/amdgpu/driver.c:      &driver->libhsa, &topology, &device_info_count, NULL, &builder);
../../drivers/amdgpu/driver.c:  // Build the full set of device infos and populate the string table in-place.
../../drivers/amdgpu/driver.c:        &driver->libhsa, &topology, &device_info_count, device_infos, &builder);
../../drivers/amdgpu/driver.c:  // device_library.h for something like `[amdgcn-blah-blah,
../../drivers/amdgpu/driver.c:  // **amdgcn-blah-blah**, ...]`.
../../drivers/amdgpu/driver.c:  // The format of the params is implementation-defined. The params strings can
../../drivers/amdgpu/driver.c:      driver->options.default_device_options;
../../drivers/amdgpu/driver.c:          &driver->libhsa, (uint64_t)device_id, &topology);
../../drivers/amdgpu/driver.c:    status = iree_hal_amdgpu_logical_device_create(driver->identifier, &options,
../../drivers/amdgpu/driver.c:                                                   &driver->libhsa, &topology,
../../drivers/amdgpu/driver.c:  // The format of the params is implementation-defined. The params strings can
../../drivers/amdgpu/driver.c:      driver->options.default_device_options;
../../drivers/amdgpu/driver.c:      &driver->options, host_allocator, &libhsa));
../../drivers/amdgpu/driver.c:    status = iree_hal_amdgpu_logical_device_create(driver->identifier, &options,
../../drivers/amdgpu/event.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/event.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/event.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/event.c:  iree_hal_resource_initialize(&iree_hal_amdgpu_event_vtable, &event->resource);
../../drivers/amdgpu/event.c:  event->host_allocator = host_allocator;
../../drivers/amdgpu/event.c:  // TODO(benvanik): WIP API; this is a no-op today.
../../drivers/amdgpu/event.c:  iree_allocator_t host_allocator = event->host_allocator;
../../allocator.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../allocator.h://===----------------------------------------------------------------------===//
../../allocator.h://===----------------------------------------------------------------------===//
../../allocator.h:// that covers all memory types and usage while in an out-of-process/sandboxed
../../allocator.h:  // usage will fail. This will happen if the buffer is device-local to another
../../allocator.h:// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_memory.html
../../allocator.h:  // A driver/device-specific POSIX file descriptor handle.
../../allocator.h:  // A driver/device-specific Win32 HANDLE.
../../allocator.h:// This is a non-owning reference and the underlying allocation must remain
../../allocator.h:      // always treated as a 64-bit integer here.
../../allocator.h://===----------------------------------------------------------------------===//
../../allocator.h://===----------------------------------------------------------------------===//
../../allocator.h:// Formats allocator statistics as a pretty-printed multi-line string.
../../allocator.h://===----------------------------------------------------------------------===//
../../allocator.h://===----------------------------------------------------------------------===//
../../allocator.h:// Thread-safe; statistics are captured at the time the call is made.
../../allocator.h:// No-op if statistics are not enabled (IREE_STATISTICS_ENABLE).
../../allocator.h:// will always be non-NONE. For buffers that originate from another allocator
../../allocator.h:// there may be limited support for cross-device usage.
../../allocator.h:// Imports an externally-owned |external_buffer| to a buffer handle.
../../allocator.h:// Exports an allocator-owned |buffer| to an external buffer handle.
../../allocator.h://===----------------------------------------------------------------------===//
../../allocator.h://===----------------------------------------------------------------------===//
../../allocator.h:// Creates a host-local heap allocator that can be used when buffers are
../../allocator.h://===----------------------------------------------------------------------===//
../../allocator.h://===----------------------------------------------------------------------===//
../../allocator.h:    statistics->host_bytes_allocated += allocation_size;
../../allocator.h:    statistics->host_bytes_peak =
../../allocator.h:        iree_max(statistics->host_bytes_peak, statistics->host_bytes_allocated -
../../allocator.h:                                                  statistics->host_bytes_freed);
../../allocator.h:    statistics->device_bytes_allocated += allocation_size;
../../allocator.h:    statistics->device_bytes_peak = iree_max(
../../allocator.h:        statistics->device_bytes_peak,
../../allocator.h:        statistics->device_bytes_allocated - statistics->device_bytes_freed);
../../allocator.h:    statistics->host_bytes_freed += allocation_size;
../../allocator.h:    statistics->device_bytes_freed += allocation_size;
../../string_util.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../string_util.c:                 buffer ? buffer_capacity - buffer_length : 0,
../../string_util.c:                 (i < shape_rank - 1) ? "%" PRIdim "x" : "%" PRIdim, shape[i]);
../../string_util.c:    } else if (buffer && n >= buffer_capacity - buffer_length) {
../../string_util.c:        string_builder, (i < shape_rank - 1) ? "%" PRIdim "x" : "%" PRIdim,
../../string_util.c:  /* clang-format off */
../../string_util.c:  /* clang-format on */
../../string_util.c:        token_start = src_i - 1;
../../string_util.c:                              src_i - 2 - token_start + 1),
../../string_util.c:                              data_str.size - token_start),
../../string_util.c:      if (buffer_length < buffer_capacity - 1) { \
../../string_util.c:          subdata, shape_rank - 1, shape + 1, element_type, max_element_count,
../../string_util.c:          buffer ? buffer_capacity - buffer_length : 0,
../../string_util.c:    *max_element_count -= max_count;
../../string_util.c:          subdata, element_type, buffer ? buffer_capacity - buffer_length : 0,
../../drivers/amdgpu/cts/CMakeLists.txt:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/cts/CMakeLists.txt:  "--iree-hip-target=${IREE_HIP_TEST_TARGET_CHIP}"
../../drivers/amdgpu/cts/CMakeLists.txt:    "\"amdgcn-amd-amdhsa--${IREE_HIP_TEST_TARGET_CHIP}\""
../../drivers/amdgpu/cts/CMakeLists.txt:  #   "--..."
../../drivers/amdgpu/cts/CMakeLists.txt:    requires-gpu-amd
../../buffer_view.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../buffer_view.c:  // Note that we have the dynamically-sized shape dimensions on the end.
../../buffer_view.c:    iree_atomic_ref_count_init(&buffer_view->ref_count);
../../buffer_view.c:    buffer_view->host_allocator = host_allocator;
../../buffer_view.c:    buffer_view->buffer = buffer;
../../buffer_view.c:    iree_hal_buffer_retain(buffer_view->buffer);
../../buffer_view.c:    buffer_view->element_type = element_type;
../../buffer_view.c:    buffer_view->encoding_type = encoding_type;
../../buffer_view.c:    buffer_view->byte_length =
../../buffer_view.c:        iree_hal_element_dense_byte_count(buffer_view->element_type);
../../buffer_view.c:    buffer_view->shape_rank = shape_rank;
../../buffer_view.c:      buffer_view->shape[i] = shape[i];
../../buffer_view.c:      buffer_view->byte_length *= shape[i];
../../buffer_view.c:    iree_atomic_ref_count_inc(&buffer_view->ref_count);
../../buffer_view.c:      iree_atomic_ref_count_dec(&buffer_view->ref_count) == 1) {
../../buffer_view.c:  iree_allocator_t host_allocator = buffer_view->host_allocator;
../../buffer_view.c:  iree_hal_buffer_release(buffer_view->buffer);
../../buffer_view.c:  return buffer_view->buffer;
../../buffer_view.c:  return buffer_view->shape_rank;
../../buffer_view.c:  return buffer_view->shape;
../../buffer_view.c:  if (IREE_UNLIKELY(index > buffer_view->shape_rank)) {
../../buffer_view.c:  return buffer_view->shape[index];
../../buffer_view.c:  for (iree_host_size_t i = 0; i < buffer_view->shape_rank; ++i) {
../../buffer_view.c:    element_count *= buffer_view->shape[i];
../../buffer_view.c:    *out_shape_rank = buffer_view->shape_rank;
../../buffer_view.c:  if (rank_capacity < buffer_view->shape_rank) {
../../buffer_view.c:  IREE_ASSERT(buffer_view->shape_rank == 0 || out_shape);
../../buffer_view.c:  for (iree_host_size_t i = 0; i < buffer_view->shape_rank; ++i) {
../../buffer_view.c:    out_shape[i] = buffer_view->shape[i];
../../buffer_view.c:  if (shape_rank != buffer_view->shape_rank) {
../../buffer_view.c:                            shape_rank, buffer_view->shape_rank);
../../buffer_view.c:    buffer_view->shape[i] = shape[i];
../../buffer_view.c:  return buffer_view->element_type;
../../buffer_view.c:  return iree_hal_element_dense_byte_count(buffer_view->element_type);
../../buffer_view.c:  return buffer_view->encoding_type;
../../buffer_view.c:  return buffer_view->byte_length;
../../buffer_view.c:      buffer_view->shape_rank, buffer_view->shape, buffer_view->element_type,
../../buffer_view.c:      buffer_view->encoding_type, indices_count, indices, out_offset);
../../buffer_view.c:      buffer_view->shape_rank, buffer_view->shape, buffer_view->element_type,
../../buffer_view.c:      buffer_view->encoding_type, indices_count, start_indices, lengths_count,
../../drivers/amdgpu/virtual_queue.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/virtual_queue.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/virtual_queue.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/virtual_queue.h:// Power-of-two number of hardware execution queues per HAL queue.
../../drivers/amdgpu/virtual_queue.h:// Power-of-two size of the scheduler control queue in entries.
../../drivers/amdgpu/virtual_queue.h:// outstanding control kernel launches - usually 1 to 100.
../../drivers/amdgpu/virtual_queue.h:// Power-of-two size of the scheduler/command buffer execution queue in entries.
../../drivers/amdgpu/virtual_queue.h:// Power-of-two size of the kernarg ringbuffer used by each queue.
../../drivers/amdgpu/virtual_queue.h:// Power-of-two size for the per-queue trace ringbuffer in bytes.
../../drivers/amdgpu/virtual_queue.h:// for a device->host flush.
../../drivers/amdgpu/virtual_queue.h:  // Attempt to schedule entries out-of-order to fill available resources.
../../drivers/amdgpu/virtual_queue.h:  // are outstanding - or may make things worse as large entries may come in
../../drivers/amdgpu/virtual_queue.h:  // https://en.wikipedia.org/wiki/Work-conserving_scheduler
../../drivers/amdgpu/virtual_queue.h:  // Power-of-two total size of the control queue in entries.
../../drivers/amdgpu/virtual_queue.h:  // Power-of-two number of hardware execution queues per HAL queue.
../../drivers/amdgpu/virtual_queue.h:  // Power-of-two total size of the execution queue in entries.
../../drivers/amdgpu/virtual_queue.h:  // Power-of-two total size of the kernarg ringbuffer in bytes.
../../drivers/amdgpu/virtual_queue.h:  // Power-of-two total size of the trace buffer, in bytes, if tracing is
../../drivers/amdgpu/virtual_queue.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/virtual_queue.h://===----------------------------------------------------------------------===//
../../drivers/amdgpu/virtual_queue.h:// initialize the queue in-place. Deinitialization happens explicitly when the
../../command_buffer_validation.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../command_buffer_validation.h:// support the given min/max byte offsets as in-range.
../../drivers/amdgpu/BUILD.bazel:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/BUILD.bazel:    group = "iree-hal-drivers-amdgpu-tests",
../../drivers/amdgpu/BUILD.bazel:    group = "iree-hal-drivers-amdgpu-tests",
../../drivers/amdgpu/BUILD.bazel:    group = "iree-hal-drivers-amdgpu-tests",
../../drivers/amdgpu/BUILD.bazel:    group = "iree-hal-drivers-amdgpu-tests",
../../drivers/amdgpu/host_service.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/host_service.c:#define IREE_HAL_AMDGPU_INVALID_SIGNAL_VALUE ((hsa_signal_value_t) - 2)
../../drivers/amdgpu/host_service.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/host_service.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/host_service.c:  // NOTE: this will wake if all signals ever passes through 0 - it's possible
../../drivers/amdgpu/host_service.c:  // for it to be non-zero upon return if something else modifies it (but we
../../drivers/amdgpu/host_service.c:  static_assert(IREE_ARRAYSIZE(packet->dep_signal) == 5, "expecting 5 signals");
../../drivers/amdgpu/host_service.c:      IREE_LIBHSA(libhsa), IREE_ARRAYSIZE(packet->dep_signal),
../../drivers/amdgpu/host_service.c:      (hsa_signal_t*)packet->dep_signal, conds, values, UINT64_MAX,
../../drivers/amdgpu/host_service.c:    for (uint32_t i = satisfying_index; i < IREE_ARRAYSIZE(packet->dep_signal);
../../drivers/amdgpu/host_service.c:      if (packet->dep_signal[i].handle) {
../../drivers/amdgpu/host_service.c:                                       packet->dep_signal[i]);
../../drivers/amdgpu/host_service.c:  if (iree_status_is_ok(status) && packet->completion_signal.handle != 0) {
../../drivers/amdgpu/host_service.c:                                       packet->completion_signal, 1);
../../drivers/amdgpu/host_service.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/host_service.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/host_service.c:  // NOTE: this will wake if the signal ever passes through 0 - it's possible
../../drivers/amdgpu/host_service.c:  // for it to be non-zero upon return if something else modifies it (but we
../../drivers/amdgpu/host_service.c:  static_assert(IREE_ARRAYSIZE(packet->dep_signal) == 5, "expecting 5 signals");
../../drivers/amdgpu/host_service.c:      IREE_LIBHSA(libhsa), IREE_ARRAYSIZE(packet->dep_signal),
../../drivers/amdgpu/host_service.c:      (hsa_signal_t*)packet->dep_signal, conds, values, UINT64_MAX,
../../drivers/amdgpu/host_service.c:                                   packet->dep_signal[satisfying_index]);
../../drivers/amdgpu/host_service.c:  if (iree_status_is_ok(status) && packet->completion_signal.handle != 0) {
../../drivers/amdgpu/host_service.c:                                       packet->completion_signal, 1);
../../drivers/amdgpu/host_service.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/host_service.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/host_service.c:  if (IREE_LIKELY(packet->mask == UINT64_MAX)) {
../../drivers/amdgpu/host_service.c:    // NOTE: this will wake if the signal ever meets the condition - it's
../../drivers/amdgpu/host_service.c:    iree_hsa_signal_wait_scacquire(IREE_LIBHSA(libhsa), packet->signal,
../../drivers/amdgpu/host_service.c:                                   packet->cond, packet->value, UINT64_MAX,
../../drivers/amdgpu/host_service.c:        iree_hsa_signal_load_scacquire(IREE_LIBHSA(libhsa), packet->signal);
../../drivers/amdgpu/host_service.c:    while (!iree_hsa_condition_is_met(packet->cond, value & packet->mask,
../../drivers/amdgpu/host_service.c:                                      packet->value)) {
../../drivers/amdgpu/host_service.c:          IREE_LIBHSA(libhsa), packet->signal, HSA_SIGNAL_CONDITION_NE, value,
../../drivers/amdgpu/host_service.c:  if (packet->completion_signal.handle != 0) {
../../drivers/amdgpu/host_service.c:                                       packet->completion_signal, 1);
../../drivers/amdgpu/host_service.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/host_service.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/host_service.c:// If the operation is asynchronous then the service->outstanding_signal must be
../../drivers/amdgpu/host_service.c:  switch (packet->type) {
../../drivers/amdgpu/host_service.c:          service, (iree_hal_semaphore_t*)packet->arg[0], packet->arg[1]);
../../drivers/amdgpu/host_service.c:          service, IREE_ARRAYSIZE(packet->arg),
../../drivers/amdgpu/host_service.c:          (iree_hal_resource_t**)packet->arg);
../../drivers/amdgpu/host_service.c:                                packet->type);
../../drivers/amdgpu/host_service.c:  if (iree_status_is_ok(status) && packet->completion_signal.handle != 0) {
../../drivers/amdgpu/host_service.c:                                       packet->completion_signal, 1);
../../drivers/amdgpu/host_service.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/host_service.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/host_service.c:      IREE_LIBHSA(libhsa), service->outstanding_signal, HSA_SIGNAL_CONDITION_LT,
../../drivers/amdgpu/host_service.c:  const iree_hal_amdgpu_libhsa_t* libhsa = service->libhsa;
../../drivers/amdgpu/host_service.c:  const uint64_t queue_mask = service->queue->size - 1;
../../drivers/amdgpu/host_service.c:        IREE_LIBHSA(libhsa), service->doorbell, HSA_SIGNAL_CONDITION_NE,
../../drivers/amdgpu/host_service.c:                             IREE_LIBHSA(libhsa), service->queue)) {
../../drivers/amdgpu/host_service.c:          (hsa_agent_dispatch_packet_t*)service->queue->base_address +
../../drivers/amdgpu/host_service.c:                      ((1 << HSA_PACKET_HEADER_WIDTH_TYPE) - 1);
../../drivers/amdgpu/host_service.c:                                                service->queue, ++read_index);
../../drivers/amdgpu/host_service.c:  out_service->libhsa = libhsa;
../../drivers/amdgpu/host_service.c:  out_service->error_callback = error_callback;
../../drivers/amdgpu/host_service.c:  out_service->failure_code = IREE_ATOMIC_VAR_INIT(0);
../../drivers/amdgpu/host_service.c:      /*attributes=*/0, &out_service->outstanding_signal);
../../drivers/amdgpu/host_service.c:        /*attributes=*/0, &out_service->doorbell);
../../drivers/amdgpu/host_service.c:        HSA_QUEUE_FEATURE_AGENT_DISPATCH, out_service->doorbell,
../../drivers/amdgpu/host_service.c:        &out_service->queue);
../../drivers/amdgpu/host_service.c:             "iree-amdgpu-host-%" PRIhsz "-%" PRIhsz, host_ordinal,
../../drivers/amdgpu/host_service.c:                           thread_params, host_allocator, &out_service->thread);
../../drivers/amdgpu/host_service.c:  const iree_hal_amdgpu_libhsa_t* libhsa = service->libhsa;
../../drivers/amdgpu/host_service.c:  // Mark the queue as inactive. This is likely a no-op for our soft queue from
../../drivers/amdgpu/host_service.c:  if (service->queue) {
../../drivers/amdgpu/host_service.c:        iree_hsa_queue_inactivate(IREE_LIBHSA(libhsa), service->queue));
../../drivers/amdgpu/host_service.c:  if (service->doorbell.handle) {
../../drivers/amdgpu/host_service.c:    iree_hsa_signal_store_screlease(IREE_LIBHSA(libhsa), service->doorbell,
../../drivers/amdgpu/host_service.c:  if (service->thread) {
../../drivers/amdgpu/host_service.c:    iree_thread_join(service->thread);
../../drivers/amdgpu/host_service.c:    iree_thread_release(service->thread);
../../drivers/amdgpu/host_service.c:    service->thread = NULL;
../../drivers/amdgpu/host_service.c:  if (service->queue) {
../../drivers/amdgpu/host_service.c:        iree_hsa_queue_destroy(IREE_LIBHSA(libhsa), service->queue));
../../drivers/amdgpu/host_service.c:  if (service->doorbell.handle) {
../../drivers/amdgpu/host_service.c:        iree_hsa_signal_destroy(IREE_LIBHSA(libhsa), service->doorbell));
../../drivers/amdgpu/host_service.c:  if (service->outstanding_signal.handle) {
../../drivers/amdgpu/host_service.c:                                              service->outstanding_signal));
../../drivers/amdgpu/host_service.c:  // Try to set our local status - we only preserve the first failure so only
../../drivers/amdgpu/host_service.c:      &service->failure_code, &old_status_code, new_status_code,
../../drivers/amdgpu/host_service.c:  if (first_failure && service->error_callback.fn) {
../../drivers/amdgpu/host_service.c:    // Notify user-provided function; ownership of the status is transferred to
../../drivers/amdgpu/host_service.c:    service->error_callback.fn(service->error_callback.user_data, status);
../../drivers/amdgpu/host_service.c:  if (service->doorbell.handle) {
../../drivers/amdgpu/host_service.c:    iree_hsa_signal_store_screlease(IREE_LIBHSA(service->libhsa),
../../drivers/amdgpu/host_service.c:                                    service->doorbell, UINT64_MAX);
../../drivers/amdgpu/host_service.c:  iree_hsa_signal_subtract_screlease(IREE_LIBHSA(service->libhsa),
../../drivers/amdgpu/host_service.c:                                     service->outstanding_signal, 1);
../../BUILD.bazel:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../BUILD.bazel:#===------------------------------------------------------------------------===#
../../BUILD.bazel:#===------------------------------------------------------------------------===#
../../drivers/amdgpu/allocator.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../drivers/amdgpu/allocator.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/allocator.c://===----------------------------------------------------------------------===//
../../drivers/amdgpu/allocator.c:// TODO(benvanik): use one ID per address space or pool - each shows as a
../../drivers/amdgpu/allocator.c:                               &allocator->resource);
../../drivers/amdgpu/allocator.c:  allocator->host_allocator = host_allocator;
../../drivers/amdgpu/allocator.c:  allocator->libhsa = libhsa;
../../drivers/amdgpu/allocator.c:  allocator->topology = topology;
../../drivers/amdgpu/allocator.c:  // request-specific so preparing here will help keep the errors more
../../drivers/amdgpu/allocator.c:  iree_allocator_free(allocator->host_allocator, allocator);
../../drivers/amdgpu/allocator.c:  return allocator->host_allocator;
../../drivers/amdgpu/allocator.c:  // low-memory situations or when IREE is not going to be used for awhile (low
../../drivers/amdgpu/allocator.c:    memcpy(out_statistics, &allocator->statistics, sizeof(*out_statistics));
../../drivers/amdgpu/allocator.c:  params->type &= ~IREE_HAL_MEMORY_TYPE_OPTIMAL;
../../drivers/amdgpu/allocator.c:  // application is unlikely to do anything when requesting a 0-byte buffer; but
../../drivers/amdgpu/allocator.c:        iree_hal_memory_type_format(params->type, &temp0);
../../drivers/amdgpu/allocator.c:        iree_hal_buffer_usage_format(params->usage, &temp1);
../../drivers/amdgpu/allocator.c:        &allocator->statistics, compat_params.type, allocation_size));
../../drivers/amdgpu/allocator.c:        &allocator->statistics, iree_hal_buffer_memory_type(base_buffer),
../../drivers/amdgpu/allocator.c:  iree_device_size_t allocation_size = external_buffer->size;
../../drivers/amdgpu/allocator.c:        iree_hal_memory_type_format(params->type, &temp0);
../../drivers/amdgpu/allocator.c:        iree_hal_buffer_usage_format(params->usage, &temp1);
../../drivers/amdgpu/allocator.c:  // TODO(benvanik): switch on external_buffer->type and import the buffer. See
../../buffer_view.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../buffer_view.h://===----------------------------------------------------------------------===//
../../buffer_view.h://===----------------------------------------------------------------------===//
../../buffer_view.h:  // Opaque or unknown - bytes cannot be interpreted. Indexing is still allowed
../../buffer_view.h:  // Signless integer-like.
../../buffer_view.h:  // Float-like.
../../buffer_view.h:  // IEEE754-compatible floating point semantics.
../../buffer_view.h:  // Paired (real, imag) complex number in floating-point format.
../../buffer_view.h:  // Ad-hoc entries for the zoo of low-bit-depth float types. They are special
../../buffer_view.h:// Returns true if the element is byte-aligned.
../../buffer_view.h:// Sub-byte aligned types such as i4 require user handling of the packing.
../../buffer_view.h:// This is only valid when the encoding type is dense as sub-byte bit widths
../../buffer_view.h:  ((iree_hal_element_bit_count(element_type) + 8 - 1) / 8)
../../buffer_view.h:// Composed as a 32-bit bitfield to allow for opaque data types. Use
../../buffer_view.h://   MSB ----------------------------------------------- LSB
../../buffer_view.h:// clang-format off
../../buffer_view.h:// clang-format on
../../buffer_view.h:  // Encoding is a densely-packed numpy/C-style row-major format.
../../buffer_view.h://===----------------------------------------------------------------------===//
../../buffer_view.h://===----------------------------------------------------------------------===//
../../buffer_view.h:// Performs a **metadata update-only** reshape.
../../buffer_view.h://===----------------------------------------------------------------------===//
../../buffer_view.h://===----------------------------------------------------------------------===//
../../fence.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../fence.c://===----------------------------------------------------------------------===//
../../fence.c://===----------------------------------------------------------------------===//
../../fence.c:  iree_atomic_ref_count_init(&fence->ref_count);
../../fence.c:  fence->host_allocator = host_allocator;
../../fence.c:  fence->capacity = (uint16_t)capacity;
../../fence.c:  fence->count = 0;
../../fence.c:// can hold the worst-case sum of all fence timepoints and then insert but it
../../fence.c:    if (fences[i]) total_count += fences[i]->count;
../../fence.c:  // Empty list -> NULL.
../../fence.c:  IREE_ASSERT_REF_COUNT_ZERO(&fence->ref_count);
../../fence.c:  iree_allocator_t host_allocator = fence->host_allocator;
../../fence.c:    iree_atomic_ref_count_inc(&fence->ref_count);
../../fence.c:  if (IREE_LIKELY(fence) && iree_atomic_ref_count_dec(&fence->ref_count) == 1) {
../../fence.c:      semaphore_base + fence->capacity * sizeof(iree_hal_semaphore_t*),
../../fence.c:      .count = fence->count,
../../fence.c:  return fence->count;
../../fence.c:  if (list.count >= fence->capacity) {
../../fence.c:                            fence->capacity);
../../fence.c:  ++fence->count;
../../fence.c:  if (!fence || !fence->count) return iree_ok_status();
../../fence.c:          ((const iree_wait_source_wait_params_t*)params)->timeout;
../../fence.c:          ((const iree_wait_source_export_params_t*)params)->target_type;
../../executable_cache.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../executable_cache.c:  out_executable_params->queue_affinity = IREE_HAL_QUEUE_AFFINITY_ANY;
../../executable_cache.c:  out_executable_params->caching_mode =
../../cts/allocator_test.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../cts/driver_test.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../buffer_heap.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../buffer_heap.c:  // Allocated as split [metadata] and an externally-owned [data].
../../buffer_heap.c:  // A user-provided buffer release callback is notified that the buffer is no
../../buffer_heap.c:// This results in an additional host allocation but allows for user-overridden
../../buffer_heap.c:  out_data->data_length = allocation_size;
../../buffer_heap.c:  out_data->data = data_ptr;
../../buffer_heap.c:    iree_allocator_free_aligned(data_allocator, out_data->data);
../../buffer_heap.c:        iree_hal_buffer_placement_undefined(), &buffer->base, allocation_size,
../../buffer_heap.c:        0, allocation_size, params->type, params->access, params->usage,
../../buffer_heap.c:        &iree_hal_heap_buffer_vtable, &buffer->base);
../../buffer_heap.c:    buffer->host_allocator = host_allocator;
../../buffer_heap.c:    buffer->data = data;
../../buffer_heap.c:      buffer->base.flags = IREE_HAL_HEAP_BUFFER_STORAGE_MODE_SLAB;
../../buffer_heap.c:      buffer->data_allocator = iree_allocator_null();
../../buffer_heap.c:      buffer->base.flags = IREE_HAL_HEAP_BUFFER_STORAGE_MODE_SPLIT;
../../buffer_heap.c:      buffer->data_allocator = data_allocator;
../../buffer_heap.c:        buffer->statistics = statistics;
../../buffer_heap.c:        iree_slim_mutex_lock(&statistics->mutex);
../../buffer_heap.c:            &statistics->base, params->type, allocation_size);
../../buffer_heap.c:        iree_slim_mutex_unlock(&statistics->mutex);
../../buffer_heap.c:    *out_buffer = &buffer->base;
../../buffer_heap.c:    iree_hal_buffer_initialize(placement, &buffer->base, allocation_size, 0,
../../buffer_heap.c:                               &buffer->base);
../../buffer_heap.c:    buffer->host_allocator = host_allocator;
../../buffer_heap.c:    buffer->data = data;
../../buffer_heap.c:    buffer->base.flags = IREE_HAL_HEAP_BUFFER_STORAGE_MODE_EXTERNAL;
../../buffer_heap.c:    buffer->release_callback = release_callback;
../../buffer_heap.c:    *out_buffer = &buffer->base;
../../buffer_heap.c:  iree_allocator_t host_allocator = buffer->host_allocator;
../../buffer_heap.c:    if (buffer->statistics != NULL) {
../../buffer_heap.c:      iree_slim_mutex_lock(&buffer->statistics->mutex);
../../buffer_heap.c:      iree_hal_allocator_statistics_record_free(&buffer->statistics->base,
../../buffer_heap.c:                                                base_buffer->memory_type,
../../buffer_heap.c:                                                base_buffer->allocation_size);
../../buffer_heap.c:      iree_slim_mutex_unlock(&buffer->statistics->mutex);
../../buffer_heap.c:  switch (buffer->base.flags) {
../../buffer_heap.c:      iree_allocator_free(buffer->data_allocator, buffer->data.data);
../../buffer_heap.c:      if (buffer->release_callback.fn) {
../../buffer_heap.c:        buffer->release_callback.fn(buffer->release_callback.user_data,
../../buffer_heap.c:  mapping->contents = iree_make_byte_span(buffer->data.data + local_byte_offset,
../../buffer_heap.c:    memset(mapping->contents.data, 0xCD, local_byte_length);
../../buffer_heap.c:  // No-op here as we always have the pointer.
../../executable.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../executable_cache.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../executable_cache.h://===----------------------------------------------------------------------===//
../../executable_cache.h://===----------------------------------------------------------------------===//
../../executable_cache.h:  // improving runtime performance. Avoid for one-shot executables.
../../executable_cache.h:  // Opaque compiler-generated executable data.
../../executable_cache.h:  // Executable-level constants table used to perform runtime specialization
../../executable_cache.h:  //   Vulkan/SPIR-V: specialization constants
../../executable_cache.h://===----------------------------------------------------------------------===//
../../executable_cache.h://===----------------------------------------------------------------------===//
../../executable_cache.h:// launches or re-prepare them each run. Callers should assume that the cache is
../../executable_cache.h:// a no-op and the returned Executables only live for as long as the cache does.
../../executable_cache.h:// The term 'cache' here is rather optimistic - it's perfectly acceptable for
../../executable_cache.h:// overhead in re-preparing executables.
../../executable_cache.h:// Thread-safe - multiple threads may prepare executables (including the *same*
../../executable_cache.h:// Any host-side work that needs to be performed will be scheduled on |loop|.
../../executable_cache.h:// This enables JITs, device-specific translation, and verification to be
../../executable_cache.h:// Depending on the driver preparation may take a non-trivial amount of time
../../executable_cache.h:// can issue preparation requests from multiple threads - even for the same
../../executable_cache.h:// executables - and calls will block until preparation completes.
../../executable_cache.h://===----------------------------------------------------------------------===//
../../executable_cache.h://===----------------------------------------------------------------------===//
../../buffer.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../buffer.h://===----------------------------------------------------------------------===//
../../buffer.h://===----------------------------------------------------------------------===//
../../buffer.h:#define IREE_HAL_WHOLE_BUFFER ((iree_device_size_t)(-1))
../../buffer.h:  // preferring to place the allocation in host-local memory.
../../buffer.h:  // Allocations will fail if there is no host-local memory type that can
../../buffer.h:  // IREE_HAL_MEMORY_TYPE_DEVICE_VISIBLE but doing so can incur non-trivial
../../buffer.h:  // preferring to place the allocation in device-local memory.
../../buffer.h:  // operations or light usage of host -> device upload staging buffers.
../../buffer.h:  // Allocations will fail if there is no host-local memory type that can
../../buffer.h:  // This should only be used by device-side code where it is known-safe to
../../buffer.h:  //  - D3D12_RESOURCE_STATE_COPY_SOURCE
../../buffer.h:  //  - GPUBufferUsage.COPY_SRC
../../buffer.h:  //  - VK_BUFFER_USAGE_TRANSFER_SRC_BIT
../../buffer.h:  //  - D3D12_RESOURCE_STATE_COPY_DEST
../../buffer.h:  //  - GPUBufferUsage.COPY_DST
../../buffer.h:  //  - VK_BUFFER_USAGE_TRANSFER_DST_BIT
../../buffer.h:  //  - D3D12_RESOURCE_STATE_COPY_SOURCE | D3D12_RESOURCE_STATE_COPY_DEST
../../buffer.h:  //  - GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST
../../buffer.h:  //  - VK_BUFFER_USAGE_TRANSFER_SRC_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT
../../buffer.h:  // Dispatch parameters must be aligned on 16-byte boundaries and be of the
../../buffer.h:  //  - D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT
../../buffer.h:  //  - GPUBufferUsage.INDIRECT
../../buffer.h:  //  - MTLResourceUsageRead
../../buffer.h:  //  - VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT
../../buffer.h:  // data-dependent sequences but are largely read-only and may have total size
../../buffer.h:  // limitations (~32-64KB visible per binding).
../../buffer.h:  // read-only across all workgroups in a dispatch.
../../buffer.h:  //  - D3D12_CONSTANT_BUFFER_VIEW_DESC
../../buffer.h:  //  - GPUBufferUsage.UNIFORM
../../buffer.h:  //  - MTLResourceUsageRead
../../buffer.h:  //  - VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT
../../buffer.h:  // Read-only buffers can enable non-local prefetching and replication.
../../buffer.h:  // Write-only buffers can reduce cache pollution and writeback latency.
../../buffer.h:  //  - D3D12_UNORDERED_ACCESS_VIEW_DESC::D3D12_BUFFER_UAV
../../buffer.h:  //  - GPUBufferUsage.STORAGE
../../buffer.h:  //  - MTLResourceUsageRead | MTLResourceUsageWrite
../../buffer.h:  //  - VK_BUFFER_USAGE_STORAGE_BUFFER_BIT
../../buffer.h:  // fixed-function sampling hardware and texture caches that are not available
../../buffer.h:  // low-end hardware in order to tickle driver compiler optimizations. In
../../buffer.h:  // latency or correctness hazards especially in data-dependent operations.
../../buffer.h:  //  - D3D12_SHADER_RESOURCE_VIEW_DESC::D3D12_BUFFER_SRV
../../buffer.h:  //  - MTLResourceUsageRead | MTLResourceUsageWrite
../../buffer.h:  //  - VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT
../../buffer.h:  // Buffer contents are available for use by all dispatch-related operations.
../../buffer.h:  // clone the buffer per-device in order to keep accesses local.
../../buffer.h:  // read-only access if they support it.
../../buffer.h:  // Reads and writes will be non-contiguous or non-temporal and host-cached
../../buffer.h:  // Buffer may be mapped for scoped random-access host access.
../../buffer.h:  // judiciously: do not assume mapping is a high-performance technique!
../../buffer.h:  // Buffers are mapped as part of a scoped map-access-unmap sequence.
../../buffer.h:  // If there are any in-flight operations using the buffer contents are
../../buffer.h:  // coherent cross-device sharing.
../../buffer.h://===----------------------------------------------------------------------===//
../../buffer.h://===----------------------------------------------------------------------===//
../../buffer.h:  // as a free-floating heap-allocated buffer on the host.
../../buffer.h:// associated with. Commonly used for free-floating buffer handles such as heap
../../buffer.h://===----------------------------------------------------------------------===//
../../buffer.h://===----------------------------------------------------------------------===//
../../buffer.h:// Designed to be zero-initialized: any field with a 0 value will be assigned
../../buffer.h:  // The actual alignment may be any value greater-than-or-equal-to this value.
../../buffer.h:  if (!params->usage) {
../../buffer.h:    params->usage = IREE_HAL_BUFFER_USAGE_DEFAULT;
../../buffer.h:  if (!params->access) {
../../buffer.h:    params->access = IREE_HAL_MEMORY_ACCESS_ALL;
../../buffer.h:  if (!params->type) {
../../buffer.h:    params->type = IREE_HAL_MEMORY_TYPE_OPTIMAL;
../../buffer.h:  if (!params->queue_affinity) {
../../buffer.h:    params->queue_affinity = IREE_HAL_QUEUE_AFFINITY_ANY;
../../buffer.h://===----------------------------------------------------------------------===//
../../buffer.h://===----------------------------------------------------------------------===//
../../buffer.h:// Implementation-specific private mapping data.
../../buffer.h:  // Used internally - do not modify.
../../buffer.h://===----------------------------------------------------------------------===//
../../buffer.h://===----------------------------------------------------------------------===//
../../buffer.h:// Returns a no-op buffer release callback that implies that no cleanup is
../../buffer.h://===----------------------------------------------------------------------===//
../../buffer.h://===----------------------------------------------------------------------===//
../../buffer.h:// host-allocated buffer (IREE_HAL_MEMORY_TYPE_HOST_LOCAL) on an accelerator
../../buffer.h:// memory or take a non-trivial performance hit when attempting to do so
../../buffer.h:// trying to access a device-allocated buffer
../../buffer.h:// mapping them into a host-accessible address space via MapMemory. Buffers must
../../buffer.h:// buffers like std::span - though unlike std::span the returned buffer holds
../../buffer.h:// free-floating objects will have no device assigned.
../../buffer.h:// Preservation is a way to track lifetime of an asynchronously-allocated buffer
../../buffer.h:// there is a new co-owner of the buffer lifetime and that owner must make a
../../buffer.h:// Though intended for asynchronously-allocated buffers it is fine to preserve
../../buffer.h:// synchronously-allocated ones. Any code that _may_ receive asynchronously
../../buffer.h:// that will never receive asynchronously allocated buffers - such as those
../../buffer.h:// using the inline HAL - can ignore tracking.
../../buffer.h:// asynchronously allocated buffers - such as those using the inline HAL - can
../../buffer.h:// buffer is exposing read-only memory that may be in mutable pages.
../../buffer.h:// May fail, though unlikely to do so for read-only mapping and the result can
../../buffer.h:// Invalidates ranges of non-coherent memory from the host caches.
../../buffer.h:// visible on the host. Use before reading from non-coherent memory.
../../buffer.h:// Flushes ranges of non-coherent memory from the host caches.
../../buffer.h:// for device access. Use after writing to non-coherent memory.
../../buffer.h:// The byte range provided is local to the mapping. May return a 0-length span.
../../buffer.h://===----------------------------------------------------------------------===//
../../buffer.h://===----------------------------------------------------------------------===//
../../buffer.h://===----------------------------------------------------------------------===//
../../buffer.h://===----------------------------------------------------------------------===//
../../buffer.h://===----------------------------------------------------------------------===//
../../buffer.h://===----------------------------------------------------------------------===//
../../buffer.h:  // This is captured on each buffer including non-allocated buffers so that
../../buffer.h:  // and all fields valid until its reference count drops to 0 and its host-side
../../buffer.h:  // Implementation-defined flags used for additional bookkeeping or routing
../../cts/command_buffer_copy_buffer_test.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../cts/command_buffer_copy_buffer_test.h:              kDefaultAllocationSize / 2 - 4);
../../cts/command_buffer_copy_buffer_test.h:                               /*length=*/kDefaultAllocationSize / 2 - 4),
../../cts/command_buffer_copy_buffer_test.h:                               /*length=*/kDefaultAllocationSize / 2 - 4),
../../cts/command_buffer_copy_buffer_test.h:          /*target_offset=*/8 + kDefaultAllocationSize / 2 - 4,
../../cts/command_buffer_copy_buffer_test.h:          /*length=*/kDefaultAllocationSize -
../../cts/command_buffer_copy_buffer_test.h:              (8 + kDefaultAllocationSize / 2 - 4)),
../../cts/command_buffer_copy_buffer_test.h:              kDefaultAllocationSize / 2 - 4);
../../cts/command_buffer_copy_buffer_test.h:          /*length=*/kDefaultAllocationSize / 2 - 4),
../../cts/command_buffer_copy_buffer_test.h:          /*length=*/kDefaultAllocationSize / 2 - 4),
../../cts/command_buffer_copy_buffer_test.h:          /*target_offset=*/8 + kDefaultAllocationSize / 2 - 4,
../../cts/command_buffer_copy_buffer_test.h:          /*length=*/kDefaultAllocationSize -
../../cts/command_buffer_copy_buffer_test.h:              (8 + kDefaultAllocationSize / 2 - 4)),
../../cts/command_buffer_update_buffer_test.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../cts/event_test.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../cts/semaphore_submission_test.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../cts/semaphore_submission_test.h:// Test device -> device synchronization: submit two batches with a
../../cts/semaphore_submission_test.h:// semaphore signal -> wait dependency.
../../cts/semaphore_submission_test.h:  // command_buffer1 -> semaphore1 -> command_buffer2 -> semaphore2
../../cts/semaphore_submission_test.h:// Test device -> device synchronization: submit multiple batches with
../../cts/semaphore_submission_test.h:  // The signaling-wait relation is:
../../cts/semaphore_submission_test.h:// Test device -> device synchronization: submit multiple batches with
../../cts/semaphore_submission_test.h:  // The signal-wait relation is
../../cts/semaphore_submission_test.h:// Test host + device -> device synchronization: submit two batches
../../cts/semaphore_submission_test.h:// Test device -> host + device synchronization: submit two batches
../../cts/semaphore_submission_test.h:  // Signal-wait relation:
../../cts/semaphore_submission_test.h:  // signal-wait relation:
../../cts/semaphore_submission_test.h:  // signal-wait relation:
../../cts/semaphore_submission_test.h:  // signal-wait relation:
../../cts/semaphore_submission_test.h:  // signal-wait relation:
../../cts/semaphore_test.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../cts/semaphore_test.h:  // Result status is undefined - some backends may return DeadlineExceededError
../../cts/semaphore_test.h:  // Result status is undefined - some backends may return DeadlineExceededError
../../cts/semaphore_test.h:  // Result status is undefined - some backends may return DeadlineExceededError
../../cts/semaphore_test.h:// Tests threading behavior by ping-ponging between the test main thread and
../../cts/semaphore_test.h:    iree_hal_semaphore_t* semaphore = this->CreateSemaphore();
../../cts/semaphore_test.h:  iree_hal_semaphore_t* semaphore1 = this->CreateSemaphore();
../../cts/semaphore_test.h:  iree_hal_semaphore_t* semaphore2 = this->CreateSemaphore();
../../cts/semaphore_test.h:  iree_hal_semaphore_t* semaphore = this->CreateSemaphore();
../../cts/semaphore_test.h:  iree_hal_semaphore_t* semaphore = this->CreateSemaphore();
../../cts/semaphore_test.h:  iree_hal_semaphore_t* semaphore1 = this->CreateSemaphore();
../../cts/semaphore_test.h:  iree_hal_semaphore_t* semaphore2 = this->CreateSemaphore();
../../cts/semaphore_test.h:  iree_hal_semaphore_t* semaphore1 = this->CreateSemaphore();
../../cts/semaphore_test.h:  iree_hal_semaphore_t* semaphore2 = this->CreateSemaphore();
../../cts/CMakeLists.txt:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../cts/CMakeLists.txt:# These tests use executables produced by the iree-compile compiler tool.
../../buffer.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../buffer.c://===----------------------------------------------------------------------===//
../../buffer.c://===----------------------------------------------------------------------===//
../../buffer.c:// clang-format off
../../buffer.c:// clang-format on
../../buffer.c://===----------------------------------------------------------------------===//
../../buffer.c://===----------------------------------------------------------------------===//
../../buffer.c:        allocated_buffer->allocation_size, byte_offset, byte_length,
../../buffer.c:        allocated_buffer->memory_type, allocated_buffer->allowed_access,
../../buffer.c:        allocated_buffer->allowed_usage, &iree_hal_subspan_buffer_vtable,
../../buffer.c:        &buffer->base);
../../buffer.c:    buffer->host_allocator = host_allocator;
../../buffer.c:    *out_buffer = &buffer->base;
../../buffer.c:  iree_allocator_t host_allocator = buffer->host_allocator;
../../buffer.c:  iree_hal_buffer_release(base_buffer->allocated_buffer);
../../buffer.c:  return _VTABLE_DISPATCH(buffer->allocated_buffer, map_range)(
../../buffer.c:      buffer->allocated_buffer, mapping_mode, memory_access, local_byte_offset,
../../buffer.c:  return _VTABLE_DISPATCH(buffer->allocated_buffer, unmap_range)(
../../buffer.c:      buffer->allocated_buffer, local_byte_offset, local_byte_length, mapping);
../../buffer.c:  return _VTABLE_DISPATCH(buffer->allocated_buffer, invalidate_range)(
../../buffer.c:      buffer->allocated_buffer, local_byte_offset, local_byte_length);
../../buffer.c:  return _VTABLE_DISPATCH(buffer->allocated_buffer, flush_range)(
../../buffer.c:      buffer->allocated_buffer, local_byte_offset, local_byte_length);
../../buffer.c://===----------------------------------------------------------------------===//
../../buffer.c://===----------------------------------------------------------------------===//
../../buffer.c:  iree_hal_resource_initialize(vtable, &buffer->resource);
../../buffer.c:  buffer->allocated_buffer = allocated_buffer;
../../buffer.c:  buffer->allocation_size = allocation_size;
../../buffer.c:  buffer->byte_offset = byte_offset;
../../buffer.c:  buffer->byte_length = byte_length;
../../buffer.c:  buffer->placement = placement;
../../buffer.c:  buffer->preserve_count = IREE_ATOMIC_VAR_INIT(1);
../../buffer.c:  buffer->memory_type = memory_type;
../../buffer.c:  buffer->allowed_access = allowed_access;
../../buffer.c:  buffer->allowed_usage = allowed_usage;
../../buffer.c:    iree_hal_buffer_retain(buffer->allocated_buffer);
../../buffer.c:    if (buffer->pooling_allocator) {
../../buffer.c:      iree_hal_allocator_deallocate_buffer(buffer->pooling_allocator, buffer);
../../buffer.c:    iree_atomic_ref_count_inc(&((iree_hal_resource_t*)(buffer))->ref_count);
../../buffer.c:      iree_atomic_ref_count_dec(&((iree_hal_resource_t*)(buffer))->ref_count) ==
../../buffer.c:        byte_offset, byte_length, end - 1, iree_hal_buffer_byte_length(buffer));
../../buffer.c:      length == IREE_HAL_WHOLE_BUFFER ? max_length - offset : length;
../../buffer.c:  iree_device_size_t end = offset + adjusted_length - 1;
../../buffer.c:          ? iree_hal_buffer_byte_length(lhs_buffer) - lhs_offset
../../buffer.c:          ? iree_hal_buffer_byte_length(rhs_buffer) - rhs_offset
../../buffer.c:  return buffer->allocated_buffer;
../../buffer.c:  return buffer->allocation_size;
../../buffer.c:  return buffer == buffer->allocated_buffer
../../buffer.c:             ? buffer->placement
../../buffer.c:             : buffer->allocated_buffer->placement;
../../buffer.c:      buffer == buffer->allocated_buffer
../../buffer.c:          ? &buffer->preserve_count
../../buffer.c:          : &buffer->allocated_buffer->preserve_count;
../../buffer.c:      buffer == buffer->allocated_buffer
../../buffer.c:          ? &buffer->preserve_count
../../buffer.c:          : &buffer->allocated_buffer->preserve_count;
../../buffer.c:      buffer == buffer->allocated_buffer
../../buffer.c:          ? &buffer->preserve_count
../../buffer.c:          : &buffer->allocated_buffer->preserve_count;
../../buffer.c:  return buffer->byte_offset;
../../buffer.c:  return buffer->byte_length;
../../buffer.c:  return buffer->memory_type;
../../buffer.c:  return buffer->allowed_access;
../../buffer.c:  return buffer->allowed_usage;
../../buffer.c://===----------------------------------------------------------------------===//
../../buffer.c://===----------------------------------------------------------------------===//
../../buffer.c:    return iree_ok_status();  // No-op.
../../buffer.c:    // We can turn all-zero values into single-byte fills as that can be much
../../buffer.c:    return iree_ok_status();  // No-op.
../../buffer.c:    return iree_ok_status();  // No-op.
../../buffer.c:    return iree_ok_status();  // No-op.
../../buffer.c:  // Check for overlap - like memcpy we require that the two ranges don't have
../../buffer.c:  // any overlap - because we use memcpy below!
../../buffer.c:    // Whole buffer copy requested - that could mean either, so take the min.
../../buffer.c:    // Specific length requested - validate that we have matching lengths.
../../buffer.c://===----------------------------------------------------------------------===//
../../buffer.c://===----------------------------------------------------------------------===//
../../buffer.c:    if (!out_buffer_mapping->impl.is_persistent) iree_hal_buffer_retain(buffer);
../../buffer.c:  out_buffer_mapping->buffer = buffer;
../../buffer.c:  out_buffer_mapping->impl.allowed_access = memory_access;
../../buffer.c:  out_buffer_mapping->impl.is_persistent = is_persistent ? 1 : 0;
../../buffer.c:  out_buffer_mapping->impl.byte_offset = local_byte_offset;
../../buffer.c:  out_buffer_mapping->contents = iree_make_byte_span(NULL, local_byte_length);
../../buffer.c:      buffer, mapping_mode, memory_access, buffer_mapping->impl.byte_offset,
../../buffer.c:      buffer_mapping->contents.data_length, buffer_mapping);
../../buffer.c:  iree_hal_buffer_t* buffer = buffer_mapping->buffer;
../../buffer.c:  if (buffer_mapping->contents.data != NULL) {
../../buffer.c:        buffer, buffer_mapping->impl.byte_offset,
../../buffer.c:        buffer_mapping->contents.data_length, buffer_mapping);
../../buffer.c:  if (!buffer_mapping->impl.is_persistent) {
../../buffer.c:  iree_hal_buffer_t* buffer = buffer_mapping->buffer;
../../buffer.c:      buffer_mapping->impl.allowed_access, IREE_HAL_MEMORY_ACCESS_READ));
../../buffer.c:      buffer_mapping->impl.byte_offset, buffer_mapping->contents.data_length,
../../buffer.c:  iree_hal_buffer_t* buffer = buffer_mapping->buffer;
../../buffer.c:      buffer_mapping->impl.allowed_access, IREE_HAL_MEMORY_ACCESS_WRITE));
../../buffer.c:      buffer_mapping->impl.byte_offset, buffer_mapping->contents.data_length,
../../buffer.c:      buffer_mapping->impl.allowed_access, memory_access));
../../buffer.c:      0, buffer_mapping->contents.data_length, byte_offset, byte_length,
../../buffer.c:  out_span->data_length = data_length;
../../buffer.c:  out_span->data = buffer_mapping->contents.data + byte_offset;
../../cts/buffer_mapping_test.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../cts/buffer_mapping_test.h:                               /*byte_length=*/0,  // <---- empty!
../../cts/buffer_mapping_test.h:// Maps a buffer range for reading from device -> host.
../../cts/buffer_mapping_test.h:// Maps a buffer range for writing from host -> device.
../../cts/cts_test_template.cc.in:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../cts/cts_test_template.cc.in:// clang-format off
../../cts/cts_test_template.cc.in:// clang-format on
../../cts/cts_test_base.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../cts/cts_test_base.h:    // One signal semaphore from 0 -> 1.
../../cts/command_buffer_dispatch_constants_test.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../cts/command_buffer_dispatch_constants_test.h:    // No executable-level "specialization constants" (not to be confused with
../../cts/command_buffer_dispatch_constants_test.h:    // per-dispatch varying "push constants").
../../cts/command_buffer_dispatch_test.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../cts/command_buffer_dispatch_test.h:// Dispatches absf(x) on a subrange (elements 1-2) of a 4 element input buffer.
../../cts/command_buffer_dispatch_test.h:// input_buffer  = [-2.5 -2.5 -2.5 -2.5]
../../cts/command_buffer_dispatch_test.h:// output_buffer = [-9.0  2.5  2.5 -9.0]
../../cts/command_buffer_dispatch_test.h:  CreateFilledDeviceBuffer<float>(4 * sizeof(float), -2.5f, &input_buffer);
../../cts/command_buffer_dispatch_test.h:  CreateFilledDeviceBuffer<float>(4 * sizeof(float), -9.0f, &output_buffer);
../../cts/command_buffer_dispatch_test.h:  EXPECT_THAT(output_values, ::testing::ElementsAre(-9.0f, 2.5f, 2.5f, -9.0f));
../../cts/command_buffer_fill_buffer_test.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../cts/testdata/executable_cache_test.mlir:// func.func @abs(%input : tensor<f32>) -> (tensor<f32>) {
../../cts/testdata/executable_cache_test.mlir:  hal.executable.export public @abs ordinal(0) layout(#pipeline_layout) count(%arg0: !hal.device) -> (index, index, index) {
../../cts/testdata/executable_cache_test.mlir:      %2 = iree_tensor_ext.dispatch.tensor.load %0, offsets = [], sizes = [], strides = [] : !iree_tensor_ext.dispatch.tensor<readonly:f32> -> tensor<f32>
../../cts/testdata/executable_cache_test.mlir:      %4 = linalg.generic {indexing_maps = [affine_map<() -> ()>, affine_map<() -> ()>], iterator_types = []} ins(%2 : tensor<f32>) outs(%3 : tensor<f32>) {
../../cts/testdata/executable_cache_test.mlir:      } -> tensor<f32>
../../cts/testdata/executable_cache_test.mlir:      iree_tensor_ext.dispatch.tensor.store %4, %1, offsets = [], sizes = [], strides = [] : tensor<f32> -> !iree_tensor_ext.dispatch.tensor<writeonly:f32>
../../cts/README.md:in isolation, demonstrating typical full-system usage, and pointing out where
../../cts/README.md:Each HAL driver (in-tree or out-of-tree) can use the `iree_hal_cts_test_suite()`
../../cts/README.md:* https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/chap3.html#introduction-conventions
../../cts/README.md:* https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/chap4.html#fundamentals-errors
../../cts/README.md:[Vulkan Validation Layers](https://github.com/KhronosGroup/Vulkan-ValidationLayers)
../../cts/command_buffer_test.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../cts/executable_cache_test.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../cts/file_test.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../string_util_test.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../string_util_test.cc:// Parses a serialized element of |element_type| to its in-memory form.
../../string_util_test.cc:// Parses a serialized element of type T to its in-memory form.
../../string_util_test.cc:// Behaves the same as a thread-safe intrusive pointer.
../../string_util_test.cc:  // nullptr if the handle holds no value. To re-wrap in a handle use either
../../string_util_test.cc:  // C-style creation functions.
../../string_util_test.cc:  // Creates a host-local heap allocator that can be used when buffers are
../../string_util_test.cc:  // host-format.
../../string_util_test.cc:  // Converts buffer view elements into a fully-specified string-form format
../../string_util_test.cc:  EXPECT_THAT(ParseShape("0x-1"), StatusIs(StatusCode::kInvalidArgument));
../../string_util_test.cc:  EXPECT_THAT(ParseShapeAndElementType("0x-1"),
../../string_util_test.cc:  EXPECT_THAT(ParseElement<int8_t>("-128"), IsOkAndHolds(Eq(INT8_MIN)));
../../string_util_test.cc:  EXPECT_THAT(ParseElement<int16_t>("-32768"), IsOkAndHolds(Eq(INT16_MIN)));
../../string_util_test.cc:  EXPECT_THAT(ParseElement<int32_t>("-2147483648"),
../../string_util_test.cc:  EXPECT_THAT(ParseElement<int64_t>("-9223372036854775808"),
../../string_util_test.cc:  EXPECT_THAT(ParseElement<double>("-1.5e-10"), IsOkAndHolds(Eq(-1.5e-10)));
../../string_util_test.cc:  EXPECT_THAT(ParseElement<uint8_t>("-128"),
../../string_util_test.cc:  EXPECT_THAT(ParseElement<uint16_t>("-32768"),
../../string_util_test.cc:  EXPECT_THAT(ParseElement<uint32_t>("-9223372036854775808"),
../../string_util_test.cc:  EXPECT_THAT(FormatElement<int8_t>(INT8_MIN), IsOkAndHolds(Eq("-128")));
../../string_util_test.cc:  EXPECT_THAT(FormatElement<int16_t>(INT16_MIN), IsOkAndHolds(Eq("-32768")));
../../string_util_test.cc:              IsOkAndHolds(Eq("-2147483648")));
../../string_util_test.cc:              IsOkAndHolds(Eq("-9223372036854775808")));
../../string_util_test.cc:  EXPECT_THAT(FormatElement<double>(-1.5e-10), IsOkAndHolds(Eq("-1.5E-10")));
../../string_util_test.cc:  EXPECT_THAT(FormatElement<int16_t>(-12345, IREE_HAL_ELEMENT_TYPE_OPAQUE_16),
../../string_util_test.cc:      FormatBufferElements<int32_t>(std::vector<int32_t>(300, -99),
../../string_util_test.cc:          "[-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99]"));
../../string_util_test.cc:      FormatBufferElements<int32_t>(std::vector<int32_t>(300, -99),
../../string_util_test.cc:          "[-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:          "-99]"));
../../string_util_test.cc:  expect_round_trip("i8=-8");
../../string_util_test.cc:  expect_round_trip("si8=-8");
../../string_util_test.cc:  expect_round_trip("4xi8=0 -1 2 3");
../../string_util_test.cc:  expect_round_trip("4xsi8=0 -1 2 3");
../../string_util_test.cc:  expect_round_trip("4xi16=0 -1 2 3");
../../string_util_test.cc:      "100x3xi16=[-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:      "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:      "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:      "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:      "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:      "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:      "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:      "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:      "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:      "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:      "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:      "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:      "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:      "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:      "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:      "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:      "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:      "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:      "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 "
../../string_util_test.cc:      "-99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99][-99 -99 -99]");
../../command_buffer_validation.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../command_buffer_validation.c:  if (IREE_UNLIKELY(!validation_state->has_began ||
../../command_buffer_validation.c:                    validation_state->has_ended)) {
../../command_buffer_validation.c:      !iree_all_bits_set(command_buffer->allowed_categories,
../../command_buffer_validation.c:        iree_hal_command_category_format(command_buffer->allowed_categories,
../../command_buffer_validation.c:          validation_state->device_allocator,
../../command_buffer_validation.c:  // mode or try to fast path it if the buffer is known-good.
../../command_buffer_validation.c:          requirements.max_byte_offset, end - 1, binding.offset, binding.length,
../../command_buffer_validation.c:          binding.offset + binding.length - 1);
../../command_buffer_validation.c:                    command_buffer->binding_capacity)) {
../../command_buffer_validation.c:        buffer_ref.buffer_slot, command_buffer->binding_capacity);
../../command_buffer_validation.c:  command_buffer->binding_count =
../../command_buffer_validation.c:      iree_max(command_buffer->binding_count, buffer_ref.buffer_slot + 1);
../../command_buffer_validation.c:      &validation_state->binding_requirements[buffer_ref.buffer_slot];
../../command_buffer_validation.c:  table_requirements->required_compatibility |=
../../command_buffer_validation.c:  table_requirements->usage |= requirements.usage;
../../command_buffer_validation.c:  table_requirements->access |= requirements.access;
../../command_buffer_validation.c:  table_requirements->type |= requirements.type;
../../command_buffer_validation.c:  table_requirements->max_byte_offset = iree_max(
../../command_buffer_validation.c:      table_requirements->max_byte_offset, requirements.max_byte_offset);
../../command_buffer_validation.c:    table_requirements->min_byte_alignment =
../../command_buffer_validation.c:        iree_device_size_lcm(table_requirements->min_byte_alignment,
../../command_buffer_validation.c:  out_validation_state->device_allocator = device_allocator;
../../command_buffer_validation.c:  out_validation_state->has_began = false;
../../command_buffer_validation.c:  out_validation_state->has_ended = false;
../../command_buffer_validation.c:  out_validation_state->debug_group_depth = 0;
../../command_buffer_validation.c:  if (validation_state->has_began && validation_state->has_ended) {
../../command_buffer_validation.c:                            "re-recording command buffers is not allowed");
../../command_buffer_validation.c:  } else if (validation_state->has_began) {
../../command_buffer_validation.c:  validation_state->has_began = true;
../../command_buffer_validation.c:  if (validation_state->debug_group_depth != 0) {
../../command_buffer_validation.c:                            validation_state->debug_group_depth);
../../command_buffer_validation.c:  } else if (!validation_state->has_began || validation_state->has_ended) {
../../command_buffer_validation.c:  validation_state->has_ended = true;
../../command_buffer_validation.c:  ++validation_state->debug_group_depth;
../../command_buffer_validation.c:  --validation_state->debug_group_depth;
../../command_buffer_validation.c:  // Check for overlap - just like memcpy we don't handle that.
../../command_buffer_validation.c:  // through. This is only possible if both buffers are directly referenced -
../../command_buffer_validation.c:        "reduction operation cannot be specified on a non-reducing collective");
../../command_buffer_validation.c:                              ", must be 4-byte aligned",
../../command_buffer_validation.c:  if (!validation_state->has_began) {
../../command_buffer_validation.c:  } else if (!validation_state->has_ended) {
../../command_buffer_validation.c:  IREE_TRACE_ZONE_APPEND_VALUE_I64(z0, command_buffer->binding_count);
../../command_buffer_validation.c:  for (uint32_t i = 0; i < command_buffer->binding_count; ++i) {
../../command_buffer_validation.c:            validation_state->binding_requirements[i]),
../../channel.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../channel.c://===----------------------------------------------------------------------===//
../../channel.c://===----------------------------------------------------------------------===//
../../cts/testdata/command_buffer_dispatch_constants_test.mlir:  hal.executable.export public @write_constants ordinal(0) layout(#pipeline_layout) count(%arg0: !hal.device) -> (index, index, index) {
../../README.md:The IREE HAL expresses a low-level abstraction over modern compute APIs like
../../README.md:[presentations and talks](../../README.md#presentations-and-talks) for further
../../cts/testdata/command_buffer_dispatch_test.mlir:// func.func @abs(%input : tensor<2xf32>) -> (tensor<2xf32>) {
../../cts/testdata/command_buffer_dispatch_test.mlir:  hal.executable.export public @abs ordinal(0) layout(#pipeline_layout) count(%arg0: !hal.device) -> (index, index, index) {
../../cts/testdata/command_buffer_dispatch_test.mlir:      %2 = iree_tensor_ext.dispatch.tensor.load %0, offsets = [0], sizes = [2], strides = [1] : !iree_tensor_ext.dispatch.tensor<readonly:tensor<2xf32>> -> tensor<2xf32>
../../cts/testdata/command_buffer_dispatch_test.mlir:      %4 = linalg.generic {indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> (d0)>], iterator_types = ["parallel"]} ins(%2 : tensor<2xf32>) outs(%3 : tensor<2xf32>) {
../../cts/testdata/command_buffer_dispatch_test.mlir:      } -> tensor<2xf32>
../../cts/testdata/command_buffer_dispatch_test.mlir:      iree_tensor_ext.dispatch.tensor.store %4, %1, offsets = [0], sizes = [2], strides = [1] : tensor<2xf32> -> !iree_tensor_ext.dispatch.tensor<writeonly:tensor<2xf32>>
../../local/executable_plugin_manager.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/executable_plugin_manager.h://===----------------------------------------------------------------------===//
../../local/executable_plugin_manager.h://===----------------------------------------------------------------------===//
../../local/executable_plugin_manager.h://===----------------------------------------------------------------------===//
../../local/executable_plugin_manager.h://===----------------------------------------------------------------------===//
../../local/executable_plugin_manager.h:// Thread-safe: registration is permanent and it is safe to register while loads
../../local/executable_plugin_manager.h:// are happening - though resolution behavior would be non-deterministic and
../../local/executable_plugin_manager.h://===----------------------------------------------------------------------===//
../../local/executable_plugin_manager.h://===----------------------------------------------------------------------===//
../../channel_provider.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../channel_provider.c://===----------------------------------------------------------------------===//
../../channel_provider.c://===----------------------------------------------------------------------===//
../../local/executable_library_benchmark.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/executable_library_benchmark.c:          "This is the fastest-changing dimension.");
../../local/executable_library_benchmark.c:          "This is the slowest-changing dimension.");
../../local/executable_library_benchmark.c:    fprintf(file, "# --%.*s=[integer value]\n", (int)flag_name.size,
../../local/executable_library_benchmark.c:    fprintf(file, "--%.*s=%u", (int)flag_name.size, flag_name.data,
../../local/executable_library_benchmark.c:    if (i < dispatch_params.constant_count - 1) {
../../local/executable_library_benchmark.c:    fprintf(file, "# --%.*s=\"shapextype[=values]\"\n", (int)flag_name.size,
../../local/executable_library_benchmark.c:    fprintf(file, "--%.*s=\"%.*s\"\n", (int)flag_name.size, flag_name.data,
../../local/executable_library_benchmark.c:    "  # 16 4-byte elements zero-initialized:\n"
../../local/executable_library_benchmark.c:    "  --binding=2x8xi32\n"
../../local/executable_library_benchmark.c:    "  --binding=10000xi8=123\n"
../../local/executable_library_benchmark.c:    "  # 2 4-byte floating-point values with contents [[1.4], [2.1]]:\n"
../../local/executable_library_benchmark.c:    "  --binding=2x1xf32=1.4,2.1");
../../local/executable_library_benchmark.c:  iree_allocator_t host_allocator = benchmark_state->host_allocator;
../../local/executable_library_benchmark.c:      (iree_hal_executable_plugin_manager_t*)benchmark_def->user_data;
../../local/executable_library_benchmark.c:  executable_params.executable_data = file_contents->const_buffer;
../../local/executable_library_benchmark.c:  // Allocate workgroup-local memory that each invocation can use.
../../local/executable_library_benchmark.c:      local_executable->dispatch_attrs
../../local/executable_library_benchmark.c:          ? local_executable->dispatch_attrs[FLAG_entry_point]
../../local/executable_library_benchmark.c:      "during compilation using --iree-hal-dump-executable-binaries-to=path/.\n"
../../local/executable_library_benchmark.c:      "by the executable. `iree-benchmark-module` is the user-friendly\n"
../../local/executable_library_benchmark.c:      "Example --flagfile:\n"
../../local/executable_library_benchmark.c:      "  --executable_format=embedded-elf\n"
../../local/executable_library_benchmark.c:      "  --executable_file=iree/hal/local/elf/testdata/"
../../local/executable_library_benchmark.c:      "  --entry_point=0\n"
../../local/executable_library_benchmark.c:      "  --workgroup_count_x=1\n"
../../local/executable_library_benchmark.c:      "  --workgroup_count_y=1\n"
../../local/executable_library_benchmark.c:      "  --workgroup_count_z=1\n"
../../local/executable_library_benchmark.c:      "  --workgroup_size_x=1\n"
../../local/executable_library_benchmark.c:      "  --workgroup_size_y=1\n"
../../local/executable_library_benchmark.c:      "  --workgroup_size_z=1\n"
../../local/executable_library_benchmark.c:      "  --binding=4xf32=1,2,3,4\n"
../../local/executable_library_benchmark.c:      "  --binding=4xf32=100,200,300,400\n"
../../local/executable_library_benchmark.c:      "  --binding=4xf32=0,0,0,0\n"
../../local/executable_plugin.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/executable_plugin.h://===----------------------------------------------------------------------===//
../../local/executable_plugin.h://===----------------------------------------------------------------------===//
../../local/executable_plugin.h://===----------------------------------------------------------------------===//
../../local/executable_plugin.h://===----------------------------------------------------------------------===//
../../local/executable_plugin.h:// externally-defined executable library imports. Plugins can either be
../../local/executable_plugin.h:// to ahead-of-time JITs that may compile functions during resolution or return
../../local/executable_plugin.h:// stubs that are JITed on-demand. See iree_hal_executable_plugin_v0_t::resolve
../../local/executable_plugin.h://===----------------------------------------------------------------------===//
../../local/executable_plugin.h://===----------------------------------------------------------------------===//
../../local/executable_plugin.h:  // Equivalent compiler flag: -fsanitize=address
../../local/executable_plugin.h:  // Equivalent compiler flag: -fsanitize=memory
../../local/executable_plugin.h:  // Equivalent compiler flag: -fsanitize=thread
../../local/executable_plugin.h:  // Equivalent compiler flag: -fsanitize=undefined
../../local/executable_plugin.h://===----------------------------------------------------------------------===//
../../local/executable_plugin.h://===----------------------------------------------------------------------===//
../../local/executable_plugin.h:  // Name used for logging/diagnostics - should be C literal-like.
../../local/executable_plugin.h:  // Human-readable description used for logging/diagnostics.
../../local/executable_plugin.h://===----------------------------------------------------------------------===//
../../local/executable_plugin.h://===----------------------------------------------------------------------===//
../../local/executable_plugin.h:// This allows us to keep this header standalone for easy out-of-tree builds and
../../local/executable_plugin.h:// Well-known status codes matching iree_status_code_t.
../../local/executable_plugin.h://===----------------------------------------------------------------------===//
../../local/executable_plugin.h://===----------------------------------------------------------------------===//
../../local/executable_plugin.h:// This allows us to keep this header standalone for easy out-of-tree builds and
../../local/executable_plugin.h://===----------------------------------------------------------------------===//
../../local/executable_plugin.h://===----------------------------------------------------------------------===//
../../local/executable_plugin.h:// iree_string_view_t-compatible type.
../../local/executable_plugin.h:// iree_string_pair_t-compatible type.
../../local/executable_plugin.h://===----------------------------------------------------------------------===//
../../local/executable_plugin.h://===----------------------------------------------------------------------===//
../../local/executable_plugin.h:    if (lhsc == '\0') return lhsc - rhsc;
../../local/executable_plugin.h:  return lhsc - rhsc;
../../local/executable_plugin.h://===----------------------------------------------------------------------===//
../../local/executable_plugin.h://===----------------------------------------------------------------------===//
../../local/executable_plugin.h:// The entire structure is designed to be read-only and able to live embedded in
../../local/executable_plugin.h:// Thread-safe: the plugin must be safe to load and resolve from multiple
../../local/executable_plugin.h:  // what to JIT in the context - or pass unique thunk functions for each import
../../local/executable_plugin.h:  // entries) at runtime so long as they observe the thread-safety guarantees.
../../local/executable_library_test.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/executable_library_test.c:// Demonstration of the HAL-side of the iree_hal_executable_library_t ABI.
../../local/executable_library_test.c:// hand-coded example to show the codegen-side), setting up the I/O buffers and
../../local/executable_library_test.c:  // but could be targeted at generated files or runtime-loaded shared objects.
../../local/executable_library_test.c:      header->version, IREE_HAL_EXECUTABLE_LIBRARY_VERSION_LATEST,
../../local/executable_library_test.c:  IREE_ASSERT(strcmp(header->name, "demo_library") == 0,
../../local/executable_library_test.c:  IREE_ASSERT_GT(library.v0->exports.count, 0,
../../local/executable_library_test.c:  // Push constants are an array of 4-byte values that are much more efficient
../../local/executable_library_test.c:      library.v0->exports.ptrs[0];
../../utils/memory_file.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/memory_file.c://===----------------------------------------------------------------------===//
../../utils/memory_file.c://===----------------------------------------------------------------------===//
../../utils/memory_file.c:// TODO(benvanik): make these either compile-time configuration options so we
../../utils/memory_file.c:// When 1 a fast-path for importable memory will be used to avoid staging.
../../utils/memory_file.c://===----------------------------------------------------------------------===//
../../utils/memory_file.c://===----------------------------------------------------------------------===//
../../utils/memory_file.c:// Reference-counted storage for memory file contents.
../../utils/memory_file.c:  iree_atomic_ref_count_init(&storage->ref_count);
../../utils/memory_file.c:  storage->host_allocator = host_allocator;
../../utils/memory_file.c:  storage->handle = handle;
../../utils/memory_file.c:  iree_io_file_handle_retain(storage->handle);
../../utils/memory_file.c:  storage->contents = contents;
../../utils/memory_file.c:  iree_allocator_t host_allocator = storage->host_allocator;
../../utils/memory_file.c:  iree_io_file_handle_release(storage->handle);
../../utils/memory_file.c:    iree_atomic_ref_count_inc(&storage->ref_count);
../../utils/memory_file.c:      iree_atomic_ref_count_dec(&storage->ref_count) == 1) {
../../utils/memory_file.c://===----------------------------------------------------------------------===//
../../utils/memory_file.c://===----------------------------------------------------------------------===//
../../utils/memory_file.c:                            "support for wrapping non-host-allocation file "
../../utils/memory_file.c:  // iree_host_size_t (for host offsets/sizes) - if so we need to ensure the
../../utils/memory_file.c:  iree_hal_resource_initialize(&iree_hal_memory_file_vtable, &file->resource);
../../utils/memory_file.c:  file->host_allocator = host_allocator;
../../utils/memory_file.c:  file->access = access;
../../utils/memory_file.c:      handle, contents, host_allocator, &file->storage);
../../utils/memory_file.c:  // Try importing the buffer as a host-local staging buffer.
../../utils/memory_file.c:  iree_allocator_t host_allocator = file->host_allocator;
../../utils/memory_file.c:  if (file->imported_buffer) {
../../utils/memory_file.c:    iree_hal_buffer_release(file->imported_buffer);
../../utils/memory_file.c:    file->imported_buffer = NULL;
../../utils/memory_file.c:  iree_hal_memory_file_storage_release(file->storage);
../../utils/memory_file.c:// Tries to import |contents| as a device-accessible HAL buffer.
../../utils/memory_file.c:// If this succeeds we can fast-path copies without needing to allocate any
../../utils/memory_file.c:      .user_data = file->storage,
../../utils/memory_file.c:  iree_hal_memory_file_storage_retain(file->storage);
../../utils/memory_file.c:      imported_release_callback, &file->imported_buffer);
../../utils/memory_file.c:    iree_hal_memory_file_storage_release(file->storage);
../../utils/memory_file.c:  return file->access;
../../utils/memory_file.c:  return file->storage->contents.data_length;
../../utils/memory_file.c:  return file->imported_buffer;
../../utils/memory_file.c:  iree_byte_span_t file_contents = file->storage->contents;
../../utils/memory_file.c:  iree_byte_span_t file_contents = file->storage->contents;
../../utils/semaphore_base.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/semaphore_base.h:// and may re-entrantly use the semaphore to query but not manage timepoints.
../../utils/semaphore_base.h:  // Intrusive doubly-linked list next entry pointer.
../../utils/semaphore_base.h:  // Intrusive doubly-linked list previous entry pointer.
../../utils/semaphore_base.h:// A doubly-linked FIFO list of timepoints.
../../utils/semaphore_base.h:// Note that the timepoints are not owned by the list - this just nicely
../../utils/semaphore_base.h:// Device implementations can acquire timepoints that provide low-latency
../../utils/semaphore_base.h:// can be allocation-free making the timepoint operations safe to perform from
../../utils/semaphore_base.h:  // Non-recursive mutex guarding access to the timepoint list.
../../utils/semaphore_base.h:  // enough as deadlines still require the scan. We could sort by non-infinite
../../utils/semaphore_base.h:// NOTE: this behavior is due to racy multi-threaded behavior and not a
../../utils/semaphore_base.h:// timepoints on-demand.
../../utils/semaphore_base.h:// re-entrantly use the semaphore.
../../utils/stream_tracing.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/stream_tracing.c:#define IREE_HAL_TRACING_DEFAULT_QUERY_CAPACITY (128 * 1024 - 256)
../../utils/stream_tracing.c:// --------------------->---Submissions--->----------
../../utils/stream_tracing.c:      z0, device_interface->vtable->record_native_event(device_interface,
../../utils/stream_tracing.c:      z0, device_interface->vtable->synchronize_native_event(device_interface,
../../utils/stream_tracing.c:    context->device_interface = device_interface;
../../utils/stream_tracing.c:    context->block_pool = block_pool;
../../utils/stream_tracing.c:    context->host_allocator = host_allocator;
../../utils/stream_tracing.c:    context->query_capacity = IREE_ARRAYSIZE(context->event_pool);
../../utils/stream_tracing.c:    context->submitted_event_list.head = NULL;
../../utils/stream_tracing.c:    context->submitted_event_list.tail = NULL;
../../utils/stream_tracing.c:    context->verbosity = stream_tracing_verbosity;
../../utils/stream_tracing.c:    iree_slim_mutex_initialize(&context->event_mutex);
../../utils/stream_tracing.c:  // Pre-allocate all events in the event pool.
../../utils/stream_tracing.c:                                     (int64_t)context->query_capacity);
../../utils/stream_tracing.c:    context->event_freelist_head = &context->event_pool[0];
../../utils/stream_tracing.c:    for (iree_host_size_t i = 0; i < context->query_capacity; ++i) {
../../utils/stream_tracing.c:      status = device_interface->vtable->create_native_event(
../../utils/stream_tracing.c:          device_interface, &context->event_pool[i].event);
../../utils/stream_tracing.c:        context->event_pool[i - 1].next_in_command_buffer =
../../utils/stream_tracing.c:            &context->event_pool[i];
../../utils/stream_tracing.c:      context->event_pool[i].next_submission = NULL;
../../utils/stream_tracing.c:      context->event_pool[i].was_submitted = false;
../../utils/stream_tracing.c:      if (i + 1 == context->query_capacity) {
../../utils/stream_tracing.c:        context->event_pool[i].next_in_command_buffer = NULL;
../../utils/stream_tracing.c:    status = device_interface->vtable->create_native_event(
../../utils/stream_tracing.c:        device_interface, &context->base_event);
../../utils/stream_tracing.c:        device_interface, context->base_event, &cpu_timestamp, &gpu_timestamp,
../../utils/stream_tracing.c:    context->id = iree_tracing_gpu_context_allocate(
../../utils/stream_tracing.c:  for (iree_host_size_t i = 0; i < context->query_capacity; ++i) {
../../utils/stream_tracing.c:    if (context->event_pool[i].event) {
../../utils/stream_tracing.c:      context->device_interface->vtable->destroy_native_event(
../../utils/stream_tracing.c:          context->device_interface, context->event_pool[i].event);
../../utils/stream_tracing.c:  if (context->base_event) {
../../utils/stream_tracing.c:    context->device_interface->vtable->destroy_native_event(
../../utils/stream_tracing.c:        context->device_interface, context->base_event);
../../utils/stream_tracing.c:  iree_slim_mutex_deinitialize(&context->event_mutex);
../../utils/stream_tracing.c:  context->device_interface->vtable->destroy(context->device_interface);
../../utils/stream_tracing.c:  iree_allocator_t host_allocator = context->host_allocator;
../../utils/stream_tracing.c:  // Inner per-event loop.
../../utils/stream_tracing.c:    uint32_t query_id = (uint32_t)(event - &context->event_pool[0]);
../../utils/stream_tracing.c:        context->device_interface->vtable->synchronize_native_event(
../../utils/stream_tracing.c:            context->device_interface, event->event));
../../utils/stream_tracing.c:    IREE_RETURN_IF_ERROR(context->device_interface->vtable->query_native_event(
../../utils/stream_tracing.c:        context->device_interface, event->event));
../../utils/stream_tracing.c:    // Calculate context-relative time and notify tracy.
../../utils/stream_tracing.c:    context->device_interface->vtable->event_elapsed_time(
../../utils/stream_tracing.c:        context->device_interface, &relative_millis, context->base_event,
../../utils/stream_tracing.c:        event->event);
../../utils/stream_tracing.c:    iree_tracing_gpu_zone_notify(context->id, query_id, gpu_timestamp);
../../utils/stream_tracing.c:    event = event->next_in_command_buffer;
../../utils/stream_tracing.c:  iree_slim_mutex_lock(&context->event_mutex);
../../utils/stream_tracing.c:      context->submitted_event_list.head;
../../utils/stream_tracing.c:    context->submitted_event_list.head = events->next_submission;
../../utils/stream_tracing.c:      last_events->next_submission = events->next_submission;
../../utils/stream_tracing.c:    events = events->next_submission;
../../utils/stream_tracing.c:  completion_event->was_submitted = true;
../../utils/stream_tracing.c:  iree_slim_mutex_unlock(&context->event_mutex);
../../utils/stream_tracing.c:  iree_slim_mutex_lock(&context->event_mutex);
../../utils/stream_tracing.c:  if (!context->submitted_event_list.head) {
../../utils/stream_tracing.c:    iree_slim_mutex_unlock(&context->event_mutex);
../../utils/stream_tracing.c:      context->submitted_event_list.head;
../../utils/stream_tracing.c:  // Outer per-command_buffer loop.
../../utils/stream_tracing.c:    iree_hal_stream_tracing_context_event_t* next = events->next_submission;
../../utils/stream_tracing.c:    events->was_submitted = true;
../../utils/stream_tracing.c:    context->submitted_event_list.head = events;
../../utils/stream_tracing.c:  iree_slim_mutex_unlock(&context->event_mutex);
../../utils/stream_tracing.c:  iree_slim_mutex_lock(&context->event_mutex);
../../utils/stream_tracing.c:  if (!event_list->head) {
../../utils/stream_tracing.c:    iree_slim_mutex_unlock(&context->event_mutex);
../../utils/stream_tracing.c:  if (!context->submitted_event_list.head) {
../../utils/stream_tracing.c:    context->submitted_event_list.head = event_list->head;
../../utils/stream_tracing.c:    context->submitted_event_list.tail = event_list->head;
../../utils/stream_tracing.c:    context->submitted_event_list.tail->next_submission = event_list->head;
../../utils/stream_tracing.c:    context->submitted_event_list.tail = event_list->head;
../../utils/stream_tracing.c:  iree_slim_mutex_unlock(&context->event_mutex);
../../utils/stream_tracing.c:  iree_slim_mutex_lock(&context->event_mutex);
../../utils/stream_tracing.c:  if (!event_list->head) {
../../utils/stream_tracing.c:    iree_slim_mutex_unlock(&context->event_mutex);
../../utils/stream_tracing.c:  // Free an event list that was previously created. There is some book-keeping
../../utils/stream_tracing.c:  // passed in event_list and add them to the front of the free-list.
../../utils/stream_tracing.c:  if (!event_list->head->was_submitted) {
../../utils/stream_tracing.c:    iree_hal_stream_tracing_context_event_t* event = event_list->head;
../../utils/stream_tracing.c:      uint32_t query_id = (uint32_t)(event - &context->event_pool[0]);
../../utils/stream_tracing.c:      iree_tracing_gpu_zone_notify(context->id, query_id, 0);
../../utils/stream_tracing.c:      event = event->next_in_command_buffer;
../../utils/stream_tracing.c:  if (!context->event_freelist_head) {
../../utils/stream_tracing.c:    context->event_freelist_head = event_list->head;
../../utils/stream_tracing.c:    iree_slim_mutex_unlock(&context->event_mutex);
../../utils/stream_tracing.c:  event_list->head->next_submission = NULL;
../../utils/stream_tracing.c:  event_list->head->was_submitted = false;
../../utils/stream_tracing.c:  event_list->tail->next_in_command_buffer = context->event_freelist_head;
../../utils/stream_tracing.c:  context->event_freelist_head = event_list->head;
../../utils/stream_tracing.c:  event_list->head = NULL;
../../utils/stream_tracing.c:  event_list->tail = NULL;
../../utils/stream_tracing.c:  iree_slim_mutex_unlock(&context->event_mutex);
../../utils/stream_tracing.c:  if (!event_list->head) {
../../utils/stream_tracing.c:    event_list->head = event;
../../utils/stream_tracing.c:    event_list->tail = event;
../../utils/stream_tracing.c:    event_list->tail->next_in_command_buffer = event;
../../utils/stream_tracing.c:    event_list->tail = event;
../../utils/stream_tracing.c:  iree_slim_mutex_lock(&context->event_mutex);
../../utils/stream_tracing.c:  iree_hal_stream_tracing_context_event_t* event = context->event_freelist_head;
../../utils/stream_tracing.c:  context->event_freelist_head = event->next_in_command_buffer;
../../utils/stream_tracing.c:  uint32_t query_id = event - &context->event_pool[0];
../../utils/stream_tracing.c:  IREE_ASSERT(event->next_in_command_buffer != NULL);
../../utils/stream_tracing.c:  event->next_in_command_buffer = NULL;
../../utils/stream_tracing.c:  IREE_IGNORE_ERROR(context->device_interface->vtable->record_native_event(
../../utils/stream_tracing.c:      context->device_interface, event->event));
../../utils/stream_tracing.c:  iree_slim_mutex_unlock(&context->event_mutex);
../../utils/stream_tracing.c:  iree_slim_mutex_lock(&context->event_mutex);
../../utils/stream_tracing.c:  iree_hal_stream_tracing_context_event_t* event = context->event_freelist_head;
../../utils/stream_tracing.c:  context->event_freelist_head = event->next_in_command_buffer;
../../utils/stream_tracing.c:  uint32_t query_id = event - &context->event_pool[0];
../../utils/stream_tracing.c:  IREE_ASSERT(event->next_in_command_buffer != NULL);
../../utils/stream_tracing.c:  event->next_in_command_buffer = NULL;
../../utils/stream_tracing.c:      context->device_interface->vtable->add_graph_event_record_node(
../../utils/stream_tracing.c:          context->device_interface, out_node, graph, dependency_nodes,
../../utils/stream_tracing.c:          dependency_nodes_count, event->event);
../../utils/stream_tracing.c:  iree_slim_mutex_unlock(&context->event_mutex);
../../utils/stream_tracing.c:  if (verbosity > context->verbosity) return;
../../utils/stream_tracing.c:  iree_tracing_gpu_zone_begin(context->id, query_id, src_loc);
../../utils/stream_tracing.c:  if (verbosity > context->verbosity) return;
../../utils/stream_tracing.c:  iree_tracing_gpu_zone_begin_external(context->id, query_id, file_name,
../../utils/stream_tracing.c:  if (verbosity > context->verbosity) return;
../../utils/stream_tracing.c:  iree_tracing_gpu_zone_begin_external(context->id, query_id, file_name,
../../utils/stream_tracing.c:  if (verbosity > context->verbosity) return;
../../utils/stream_tracing.c:  iree_tracing_gpu_zone_end(context->id, query_id);
../../utils/stream_tracing.c:  if (verbosity > context->verbosity) return;
../../utils/stream_tracing.c:  iree_tracing_gpu_zone_end(context->id, query_id);
../../utils/stream_tracing.c:  interface->vtable->destroy(interface);
../../utils/BUILD.bazel:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/mpi_channel_provider.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/mpi_channel_provider.c:// Returns true if |var_name| is set to a non-empty value in the environment.
../../utils/mpi_channel_provider.c:                               &channel_provider->resource);
../../utils/mpi_channel_provider.c:  channel_provider->host_allocator = host_allocator;
../../utils/mpi_channel_provider.c:      host_allocator, &channel_provider->library, &channel_provider->symbols);
../../utils/mpi_channel_provider.c:    status = MPI_RESULT_TO_STATUS(&channel_provider->symbols,
../../utils/mpi_channel_provider.c:      status = MPI_RESULT_TO_STATUS(&channel_provider->symbols,
../../utils/mpi_channel_provider.c:    channel_provider->is_mpi_context_owner = !is_mpi_initialized_already;
../../utils/mpi_channel_provider.c:  if (!channel_provider->library) return false;
../../utils/mpi_channel_provider.c:  MPI_IGNORE_ERROR(&channel_provider->symbols, MPI_Initialized(&flag));
../../utils/mpi_channel_provider.c:  iree_allocator_t host_allocator = channel_provider->host_allocator;
../../utils/mpi_channel_provider.c:  if (channel_provider->is_mpi_context_owner &&
../../utils/mpi_channel_provider.c:    MPI_IGNORE_ERROR(&channel_provider->symbols, MPI_Finalize());
../../utils/mpi_channel_provider.c:  memset(&channel_provider->symbols, 0, sizeof(channel_provider->symbols));
../../utils/mpi_channel_provider.c:  iree_dynamic_library_release(channel_provider->library);
../../utils/mpi_channel_provider.c:  return &channel_provider->symbols;
../../utils/mpi_channel_provider.c:      &channel_provider->symbols,
../../utils/mpi_channel_provider.c:      MPI_Comm_rank(IREE_MPI_COMM_WORLD(&channel_provider->symbols),
../../utils/mpi_channel_provider.c:      &channel_provider->symbols,
../../utils/mpi_channel_provider.c:      MPI_Comm_size(IREE_MPI_COMM_WORLD(&channel_provider->symbols),
../../utils/mpi_channel_provider.c:      &channel_provider->symbols,
../../utils/mpi_channel_provider.c:                IREE_MPI_BYTE(&channel_provider->symbols), 0,
../../utils/mpi_channel_provider.c:                IREE_MPI_COMM_WORLD(&channel_provider->symbols)),
../../utils/file_registry.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/file_registry.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/file_registry.h:// Some implementations - such as for IREE_IO_FILE_HANDLE_TYPE_HOST_ALLOCATION -
../../utils/file_registry.h:// file is allowed to be used with any device or queue as it is host-only.
../../utils/libmpi_dynamic_symbols.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/mpi_channel_provider.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/mpi_channel_provider.h:// Creates an MPI-based collective channel provider.
../../utils/file_cache.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/file_cache.h:// An in-memory cache of file handles to devices and queues that have an open
../../utils/file_cache.h:// Thread-safe: multiple threads can access the cache concurrently.
../../utils/allocators.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/allocators.c:  // with the device. If no allocator specs were provided this may be no-op and
../../utils/allocators.c:  // Swap the allocator on the device - this is only safe because we know no
../../utils/allocators.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/allocators.h:// WARNING: not thread-safe and must only be called immediately after device
../../local/inline_command_buffer.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/inline_command_buffer.c://===----------------------------------------------------------------------===//
../../local/inline_command_buffer.c://===----------------------------------------------------------------------===//
../../local/inline_command_buffer.c:// Inline synchronous one-shot command "buffer".
../../local/inline_command_buffer.c:  memset(&command_buffer->state, 0, sizeof(command_buffer->state));
../../local/inline_command_buffer.c:      &command_buffer->state.dispatch_state;
../../local/inline_command_buffer.c:  dispatch_state->binding_ptrs = command_buffer->state.binding_ptr_storage;
../../local/inline_command_buffer.c:  dispatch_state->binding_lengths =
../../local/inline_command_buffer.c:      command_buffer->state.binding_length_storage;
../../local/inline_command_buffer.c:      &iree_hal_inline_command_buffer_vtable, &command_buffer->base);
../../local/inline_command_buffer.c:  command_buffer->host_allocator = host_allocator;
../../local/inline_command_buffer.c:  *out_command_buffer = &command_buffer->base;
../../local/inline_command_buffer.c:  iree_allocator_t host_allocator = command_buffer->host_allocator;
../../local/inline_command_buffer.c:  return iree_hal_resource_is(&command_buffer->resource,
../../local/inline_command_buffer.c://===----------------------------------------------------------------------===//
../../local/inline_command_buffer.c://===----------------------------------------------------------------------===//
../../local/inline_command_buffer.c:  iree_cpu_requery_processor_id(&command_buffer->state.processor_tag,
../../local/inline_command_buffer.c:                                &command_buffer->state.processor_id);
../../local/inline_command_buffer.c://===----------------------------------------------------------------------===//
../../local/inline_command_buffer.c://===----------------------------------------------------------------------===//
../../local/inline_command_buffer.c://===----------------------------------------------------------------------===//
../../local/inline_command_buffer.c://===----------------------------------------------------------------------===//
../../local/inline_command_buffer.c:  // No-op; we execute synchronously.
../../local/inline_command_buffer.c://===----------------------------------------------------------------------===//
../../local/inline_command_buffer.c://===----------------------------------------------------------------------===//
../../local/inline_command_buffer.c:  // No-op; we execute synchronously.
../../local/inline_command_buffer.c://===----------------------------------------------------------------------===//
../../local/inline_command_buffer.c://===----------------------------------------------------------------------===//
../../local/inline_command_buffer.c:  // No-op; we execute synchronously.
../../local/inline_command_buffer.c://===----------------------------------------------------------------------===//
../../local/inline_command_buffer.c://===----------------------------------------------------------------------===//
../../local/inline_command_buffer.c:  // No-op; we execute synchronously.
../../local/inline_command_buffer.c://===----------------------------------------------------------------------===//
../../local/inline_command_buffer.c://===----------------------------------------------------------------------===//
../../local/inline_command_buffer.c://===----------------------------------------------------------------------===//
../../local/inline_command_buffer.c://===----------------------------------------------------------------------===//
../../local/inline_command_buffer.c://===----------------------------------------------------------------------===//
../../local/inline_command_buffer.c://===----------------------------------------------------------------------===//
../../local/inline_command_buffer.c://===----------------------------------------------------------------------===//
../../local/inline_command_buffer.c://===----------------------------------------------------------------------===//
../../local/inline_command_buffer.c://===----------------------------------------------------------------------===//
../../local/inline_command_buffer.c://===----------------------------------------------------------------------===//
../../local/inline_command_buffer.c://===----------------------------------------------------------------------===//
../../local/inline_command_buffer.c://===----------------------------------------------------------------------===//
../../local/inline_command_buffer.c:  if (local_executable->dispatch_attrs) {
../../local/inline_command_buffer.c:    dispatch_attrs = local_executable->dispatch_attrs[entry_point];
../../local/inline_command_buffer.c:  // this - but that's what the task system is for.
../../local/inline_command_buffer.c:      &command_buffer->state.dispatch_state;
../../local/inline_command_buffer.c:  dispatch_state->workgroup_size_x =
../../local/inline_command_buffer.c:  dispatch_state->workgroup_size_y =
../../local/inline_command_buffer.c:  dispatch_state->workgroup_size_z =
../../local/inline_command_buffer.c:    memcpy(&dispatch_state->workgroup_count_x, buffer_mapping.contents.data,
../../local/inline_command_buffer.c:    dispatch_state->workgroup_count_x = config.workgroup_count[0];
../../local/inline_command_buffer.c:    dispatch_state->workgroup_count_y = config.workgroup_count[1];
../../local/inline_command_buffer.c:    dispatch_state->workgroup_count_z = config.workgroup_count[2];
../../local/inline_command_buffer.c:  // Single-threaded.
../../local/inline_command_buffer.c:  dispatch_state->max_concurrency = 1;
../../local/inline_command_buffer.c:                            "constants must be 4-byte aligned");
../../local/inline_command_buffer.c:  dispatch_state->constant_count = dispatch_attrs.constant_count;
../../local/inline_command_buffer.c:  dispatch_state->constants = (const uint32_t*)constants.data;
../../local/inline_command_buffer.c:  // no ownership/retaining/etc - it's part of the HAL contract that buffers are
../../local/inline_command_buffer.c:  dispatch_state->binding_count = bindings.count;
../../local/inline_command_buffer.c:    command_buffer->state.binding_ptr_storage[i] = buffer_mapping.contents.data;
../../local/inline_command_buffer.c:    command_buffer->state.binding_length_storage[i] =
../../local/inline_command_buffer.c:  // TODO(benvanik): plumb through an arena or fixed-size reservation to use.
../../local/inline_command_buffer.c:  // getting allocated and retained implicitly - this should be a compiler
../../local/inline_command_buffer.c:    IREE_RETURN_IF_ERROR(iree_allocator_malloc(command_buffer->host_allocator,
../../local/inline_command_buffer.c:      command_buffer->state.processor_id, local_memory);
../../local/inline_command_buffer.c:    iree_allocator_free(command_buffer->host_allocator, local_memory.data);
../../local/inline_command_buffer.c://===----------------------------------------------------------------------===//
../../local/inline_command_buffer.c://===----------------------------------------------------------------------===//
../../utils/collective_batch.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/collective_batch.c://===----------------------------------------------------------------------===//
../../utils/collective_batch.c://===----------------------------------------------------------------------===//
../../utils/collective_batch.c:  out_batch->arena = arena;
../../utils/collective_batch.c:  out_batch->resource_set = resource_set;
../../utils/collective_batch.c:  out_batch->capacity = 0;
../../utils/collective_batch.c:  out_batch->count = 0;
../../utils/collective_batch.c:  out_batch->entries = NULL;
../../utils/collective_batch.c:  batch->capacity = 0;
../../utils/collective_batch.c:  batch->count = 0;
../../utils/collective_batch.c:  batch->entries = NULL;
../../utils/collective_batch.c:  return batch->count == 0;
../../utils/collective_batch.c:  batch->count = 0;
../../utils/collective_batch.c:      batch->capacity == 0 ? IREE_HAL_COLLECTIVE_BATCH_INITIAL_CAPACITY
../../utils/collective_batch.c:                           : batch->capacity * 2;
../../utils/collective_batch.c:  // Allocate new storage - this may fail if the system (or block pool) is over
../../utils/collective_batch.c:      iree_arena_allocate(batch->arena, new_capacity * sizeof(*batch->entries),
../../utils/collective_batch.c:  memcpy(new_entries, batch->entries, batch->count * sizeof(*batch->entries));
../../utils/collective_batch.c:  batch->capacity = new_capacity;
../../utils/collective_batch.c:  batch->entries = new_entries;
../../utils/collective_batch.c:  if (batch->count + 1 > batch->capacity) {
../../utils/collective_batch.c:  IREE_RETURN_IF_ERROR(iree_hal_resource_set_insert(batch->resource_set,
../../utils/collective_batch.c:  batch->entries[batch->count++] = (iree_hal_collective_batch_entry_t){
../../utils/resource_set_benchmark.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/resource_set_benchmark.c:                               &test_resource->resource);
../../utils/resource_set_benchmark.c:  test_resource->host_allocator = host_allocator;
../../utils/resource_set_benchmark.c:  iree_allocator_t host_allocator = resource->host_allocator;
../../utils/resource_set_benchmark.c:// This is our worst-case with unique resources that never match the MRU.
../../utils/resource_set_benchmark.c:  iree_allocator_t host_allocator = benchmark_state->host_allocator;
../../utils/resource_set_benchmark.c:  // Sized like we usually do it in the runtime for ~512-1024 elements.
../../utils/resource_set_benchmark.c:  // Allocate the resources we'll be using - we keep them live so that we are
../../utils/resource_set_benchmark.c:  uint32_t count = (uint32_t)(uintptr_t)benchmark_def->user_data;
../../utils/resource_set_benchmark.c:// the worst-case performance when all resources are unique and guaranteed to
../../utils/resource_set_benchmark.c:  iree_allocator_t host_allocator = benchmark_state->host_allocator;
../../utils/resource_set_benchmark.c:  // Sized like we usually do it in the runtime for ~512-1024 elements.
../../utils/resource_set_benchmark.c:  // Allocate the resources we'll be using - we keep them live so that we are
../../utils/resource_set_benchmark.c:  uint32_t count = (uint32_t)(uintptr_t)benchmark_def->user_data;
../../utils/resource_set_benchmark.c:// In reality what the compiler spits out is non-random and often just
../../utils/resource_set_benchmark.c:  iree_allocator_t host_allocator = benchmark_state->host_allocator;
../../utils/resource_set_benchmark.c:  // Sized like we usually do it in the runtime for ~512-1024 elements.
../../utils/resource_set_benchmark.c:  // Allocate the resources we'll be using - we keep them live so that we are
../../utils/resource_set_benchmark.c:  uint32_t count = (uint32_t)(uintptr_t)benchmark_def->user_data;
../../utils/memory_file.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/memory_file.h://===----------------------------------------------------------------------===//
../../utils/memory_file.h://===----------------------------------------------------------------------===//
../../utils/semaphore_base_test.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/semaphore_base_test.cc:    iree_hal_semaphore_initialize(&test_semaphore_vtable, &semaphore->base);
../../utils/semaphore_base_test.cc:    semaphore->host_allocator = host_allocator;
../../utils/semaphore_base_test.cc:    iree_slim_mutex_initialize(&semaphore->mutex);
../../utils/semaphore_base_test.cc:    iree_notification_initialize(&semaphore->notification);
../../utils/semaphore_base_test.cc:    iree_status_ignore(semaphore->failure_status);
../../utils/semaphore_base_test.cc:    iree_notification_deinitialize(&semaphore->notification);
../../utils/semaphore_base_test.cc:    iree_slim_mutex_deinitialize(&semaphore->mutex);
../../utils/semaphore_base_test.cc:    iree_hal_semaphore_deinitialize(&semaphore->base);
../../utils/semaphore_base_test.cc:    iree_allocator_free(semaphore->host_allocator, semaphore);
../../utils/semaphore_base_test.cc:    iree_slim_mutex_lock(&semaphore->mutex);
../../utils/semaphore_base_test.cc:    iree_status_t status = iree_status_clone(semaphore->failure_status);
../../utils/semaphore_base_test.cc:    *out_value = semaphore->current_value;
../../utils/semaphore_base_test.cc:    iree_slim_mutex_unlock(&semaphore->mutex);
../../utils/semaphore_base_test.cc:    iree_slim_mutex_lock(&semaphore->mutex);
../../utils/semaphore_base_test.cc:    semaphore->current_value = new_value;
../../utils/semaphore_base_test.cc:    iree_slim_mutex_unlock(&semaphore->mutex);
../../utils/semaphore_base_test.cc:    iree_hal_semaphore_notify(&semaphore->base, new_value, IREE_STATUS_OK);
../../utils/semaphore_base_test.cc:    iree_notification_post(&semaphore->notification, IREE_ALL_WAITERS);
../../utils/semaphore_base_test.cc:    iree_slim_mutex_lock(&semaphore->mutex);
../../utils/semaphore_base_test.cc:    iree_status_ignore(semaphore->failure_status);
../../utils/semaphore_base_test.cc:    semaphore->failure_status = status;
../../utils/semaphore_base_test.cc:    iree_slim_mutex_unlock(&semaphore->mutex);
../../utils/semaphore_base_test.cc:    iree_hal_semaphore_notify(&semaphore->base, 0, status_code);
../../utils/semaphore_base_test.cc:    iree_notification_post(&semaphore->notification, IREE_ALL_WAITERS);
../../utils/semaphore_base_test.cc:        &semaphore->notification,
../../utils/semaphore_base_test.cc:        [](void* user_data) -> bool {
../../utils/semaphore_base_test.cc:          iree_slim_mutex_lock(&state->semaphore->mutex);
../../utils/semaphore_base_test.cc:              state->semaphore->current_value >= state->value ||
../../utils/semaphore_base_test.cc:              !iree_status_is_ok(state->semaphore->failure_status);
../../utils/semaphore_base_test.cc:          iree_slim_mutex_unlock(&state->semaphore->mutex);
../../utils/semaphore_base_test.cc:  ++state->callback_count;
../../utils/semaphore_base_test.cc:  state->value = value;
../../utils/semaphore_base_test.cc:  state->status_code = status_code;
../../utils/semaphore_base_test.cc:  return iree_status_from_code(state->callback_result);
../../utils/semaphore_base_test.cc:// Tests cancelling timepoints after they are resolved. Should be a no-op.
../../utils/semaphore_base_test.cc:  // Cancel after signal, which should be a no-op.
../../utils/fd_file.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/fd_file.h://===----------------------------------------------------------------------===//
../../utils/fd_file.h://===----------------------------------------------------------------------===//
../../event.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/debug_allocator.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/file_cache.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-excepthaln
../../utils/file_cache.c:  iree_atomic_ref_count_init(&file_cache->ref_count);
../../utils/file_cache.c:  file_cache->host_allocator = host_allocator;
../../utils/file_cache.c:  iree_slim_mutex_initialize(&file_cache->mutex);
../../utils/file_cache.c:  file_cache->entry_capacity = 0;
../../utils/file_cache.c:  file_cache->entry_count = 0;
../../utils/file_cache.c:  file_cache->entries = NULL;
../../utils/file_cache.c:  iree_allocator_t host_allocator = file_cache->host_allocator;
../../utils/file_cache.c:  iree_slim_mutex_deinitialize(&file_cache->mutex);
../../utils/file_cache.c:    iree_atomic_ref_count_inc(&file_cache->ref_count);
../../utils/file_cache.c:      iree_atomic_ref_count_dec(&file_cache->ref_count) == 1) {
../../utils/file_cache.c:  iree_allocator_t host_allocator = file_cache->host_allocator;
../../utils/file_cache.c:  iree_slim_mutex_lock(&file_cache->mutex);
../../utils/file_cache.c:  for (iree_host_size_t i = 0; i < file_cache->entry_count; ++i) {
../../utils/file_cache.c:    iree_hal_file_cache_entry_t* entry = file_cache->entries[i];
../../utils/file_cache.c:    iree_hal_file_release(entry->file);
../../utils/file_cache.c:    iree_hal_device_release(entry->device);
../../utils/file_cache.c:    iree_io_file_handle_release(entry->handle);
../../utils/file_cache.c:  file_cache->entry_count = 0;
../../utils/file_cache.c:  if (file_cache->entries) {
../../utils/file_cache.c:    iree_allocator_free(host_allocator, file_cache->entries);
../../utils/file_cache.c:    file_cache->entries = NULL;
../../utils/file_cache.c:    file_cache->entry_capacity = 0;
../../utils/file_cache.c:  iree_slim_mutex_unlock(&file_cache->mutex);
../../utils/file_cache.c:  if (new_capacity < file_cache->entry_capacity) return iree_ok_status();
../../utils/file_cache.c:  iree_hal_file_cache_entry_t** new_entries = file_cache->entries;
../../utils/file_cache.c:      file_cache->host_allocator, new_capacity * sizeof(file_cache->entries[0]),
../../utils/file_cache.c:    file_cache->entry_capacity = new_capacity;
../../utils/file_cache.c:    file_cache->entries = new_entries;
../../utils/file_cache.c:  if (file_cache->entry_count == file_cache->entry_capacity) {
../../utils/file_cache.c:        file_cache, iree_max(16u, file_cache->entry_capacity * 2)));
../../utils/file_cache.c:  IREE_RETURN_IF_ERROR(iree_allocator_malloc(file_cache->host_allocator,
../../utils/file_cache.c:  entry->handle = handle;
../../utils/file_cache.c:  iree_io_file_handle_retain(entry->handle);
../../utils/file_cache.c:  entry->device = device;
../../utils/file_cache.c:  iree_hal_device_retain(entry->device);
../../utils/file_cache.c:  entry->queue_affinity = queue_affinity;
../../utils/file_cache.c:  entry->access = access;
../../utils/file_cache.c:  entry->file = file;
../../utils/file_cache.c:  iree_hal_file_retain(entry->file);
../../utils/file_cache.c:  file_cache->entries[file_cache->entry_count++] = entry;
../../utils/file_cache.c:  iree_slim_mutex_lock(&file_cache->mutex);
../../utils/file_cache.c:  for (iree_host_size_t i = 0; i < file_cache->entry_count; ++i) {
../../utils/file_cache.c:    iree_hal_file_cache_entry_t* entry = file_cache->entries[i];
../../utils/file_cache.c:    if (entry->device == device &&
../../utils/file_cache.c:        iree_all_bits_set(entry->queue_affinity, queue_affinity) &&
../../utils/file_cache.c:        iree_all_bits_set(entry->access, access) && entry->handle == handle) {
../../utils/file_cache.c:      iree_hal_file_t* file = entry->file;
../../utils/file_cache.c:      iree_slim_mutex_unlock(&file_cache->mutex);
../../utils/file_cache.c:  iree_slim_mutex_unlock(&file_cache->mutex);
../../utils/collective_batch.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/collective_batch.h://===----------------------------------------------------------------------===//
../../utils/collective_batch.h://===----------------------------------------------------------------------===//
../../utils/collective_batch.h:// command buffers may drop their reference while it is in-flight.
../../utils/collective_batch.h:  // 1-16 entries on average.
../../utils/semaphore_base.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/semaphore_base.c://===----------------------------------------------------------------------===//
../../utils/semaphore_base.c://===----------------------------------------------------------------------===//
../../utils/semaphore_base.c:  return list->head == NULL;
../../utils/semaphore_base.c:  if (list->tail) {
../../utils/semaphore_base.c:    list->tail->next = timepoint;
../../utils/semaphore_base.c:    list->head = timepoint;
../../utils/semaphore_base.c:  timepoint->next = NULL;
../../utils/semaphore_base.c:  timepoint->prev = list->tail;
../../utils/semaphore_base.c:  list->tail = timepoint;
../../utils/semaphore_base.c:  iree_hal_semaphore_timepoint_t* next = timepoint->next;
../../utils/semaphore_base.c:  iree_hal_semaphore_timepoint_t* prev = timepoint->prev;
../../utils/semaphore_base.c:    prev->next = next;
../../utils/semaphore_base.c:    timepoint->prev = NULL;
../../utils/semaphore_base.c:    list->head = next;
../../utils/semaphore_base.c:    next->prev = prev;
../../utils/semaphore_base.c:    timepoint->next = NULL;
../../utils/semaphore_base.c:    list->tail = prev;
../../utils/semaphore_base.c:  ready_list->head = available_list->head;
../../utils/semaphore_base.c:  ready_list->tail = available_list->tail;
../../utils/semaphore_base.c:  available_list->head = NULL;
../../utils/semaphore_base.c:  available_list->tail = NULL;
../../utils/semaphore_base.c:  iree_hal_semaphore_callback_t callback = timepoint->callback;
../../utils/semaphore_base.c:  for (iree_hal_semaphore_timepoint_t* timepoint = list->head;
../../utils/semaphore_base.c:    list->head = timepoint->next;
../../utils/semaphore_base.c:    timepoint->next = NULL;
../../utils/semaphore_base.c:    timepoint->prev = NULL;
../../utils/semaphore_base.c:    timepoint = list->head;
../../utils/semaphore_base.c:  list->tail = NULL;
../../utils/semaphore_base.c:  iree_slim_mutex_lock(&semaphore->timepoint_mutex);
../../utils/semaphore_base.c:  if (iree_hal_semaphore_timepoint_list_is_empty(&semaphore->timepoint_list)) {
../../utils/semaphore_base.c:    iree_slim_mutex_unlock(&semaphore->timepoint_mutex);
../../utils/semaphore_base.c:  // Scan through the list and divvy up timepoints into still-pending, ready to
../../utils/semaphore_base.c:           semaphore->timepoint_list.head;
../../utils/semaphore_base.c:    iree_hal_semaphore_timepoint_t* next_timepoint = timepoint->next;
../../utils/semaphore_base.c:    timepoint->next = NULL;
../../utils/semaphore_base.c:    if (timepoint->minimum_value <= new_value) {
../../utils/semaphore_base.c:    } else if (timepoint->deadline_ns <= now_ns) {
../../utils/semaphore_base.c:  semaphore->timepoint_list = pending_list;
../../utils/semaphore_base.c:  iree_slim_mutex_unlock(&semaphore->timepoint_mutex);
../../utils/semaphore_base.c:  iree_slim_mutex_lock(&semaphore->timepoint_mutex);
../../utils/semaphore_base.c:  iree_hal_semaphore_timepoint_list_take_all(&semaphore->timepoint_list,
../../utils/semaphore_base.c:  iree_slim_mutex_unlock(&semaphore->timepoint_mutex);
../../utils/semaphore_base.c://===----------------------------------------------------------------------===//
../../utils/semaphore_base.c://===----------------------------------------------------------------------===//
../../utils/semaphore_base.c:  iree_hal_resource_initialize(vtable, &out_semaphore->resource);
../../utils/semaphore_base.c:  iree_slim_mutex_initialize(&out_semaphore->timepoint_mutex);
../../utils/semaphore_base.c:  memset(&out_semaphore->timepoint_list, 0,
../../utils/semaphore_base.c:         sizeof(out_semaphore->timepoint_list));
../../utils/semaphore_base.c:  iree_slim_mutex_deinitialize(&semaphore->timepoint_mutex);
../../utils/semaphore_base.c:  out_timepoint->next = NULL;
../../utils/semaphore_base.c:  out_timepoint->prev = NULL;
../../utils/semaphore_base.c:  out_timepoint->semaphore = semaphore;
../../utils/semaphore_base.c:  out_timepoint->minimum_value = minimum_value;
../../utils/semaphore_base.c:  out_timepoint->deadline_ns = iree_timeout_as_deadline_ns(timeout);
../../utils/semaphore_base.c:  out_timepoint->callback = callback;
../../utils/semaphore_base.c:  iree_slim_mutex_lock(&semaphore->timepoint_mutex);
../../utils/semaphore_base.c:  iree_hal_semaphore_timepoint_list_push_back(&semaphore->timepoint_list,
../../utils/semaphore_base.c:  iree_slim_mutex_unlock(&semaphore->timepoint_mutex);
../../utils/semaphore_base.c:  iree_slim_mutex_lock(&semaphore->timepoint_mutex);
../../utils/semaphore_base.c:  const bool needs_release = timepoint->semaphore != NULL;
../../utils/semaphore_base.c:    iree_hal_semaphore_timepoint_list_erase(&semaphore->timepoint_list,
../../utils/semaphore_base.c:  iree_slim_mutex_unlock(&semaphore->timepoint_mutex);
../../utils/CMakeLists.txt:# CMake-only content.                                                          #
../../utils/libmpi.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/libmpi.h://===----------------------------------------------------------------------===//
../../utils/libmpi.h://===----------------------------------------------------------------------===//
../../utils/libmpi.h:#define IREE_MPI_BYTE(syms) (IREE_MPI_Datatype)((syms)->ompi_mpi_byte)
../../utils/libmpi.h:#define IREE_MPI_COMM_WORLD(syms) (IREE_MPI_Comm)((syms)->ompi_mpi_comm_world)
../../utils/libmpi.h://===----------------------------------------------------------------------===//
../../utils/libmpi.h://===----------------------------------------------------------------------===//
../../utils/libmpi.h://===----------------------------------------------------------------------===//
../../utils/libmpi.h://===----------------------------------------------------------------------===//
../../utils/libmpi.h:  iree_hal_mpi_result_to_status((syms), ((syms)->expr), __FILE__, __LINE__)
../../utils/libmpi.h:  IREE_RETURN_IF_ERROR(iree_hal_mpi_result_to_status((syms), ((syms)->expr), \
../../utils/libmpi.h:  IREE_IGNORE_ERROR(iree_hal_mpi_result_to_status((syms), ((syms)->expr), \
../../utils/file_transfer.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/file_transfer.h://===----------------------------------------------------------------------===//
../../utils/file_transfer.h://===----------------------------------------------------------------------===//
../../utils/file_transfer.h:// Options for file-based transfer operations.
../../utils/file_transfer.h:// host-based staging buffers. This implementation may require staging buffers
../../utils/file_transfer.h:// host-based staging buffers. This implementation may require staging buffers
../../utils/debug_allocator.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/debug_allocator.c://===----------------------------------------------------------------------===//
../../utils/debug_allocator.c://===----------------------------------------------------------------------===//
../../utils/debug_allocator.c://  i8: -51 / 205
../../utils/debug_allocator.c:// i16: -12851 / 52685
../../utils/debug_allocator.c:// i32: -842150451 / 3452816845
../../utils/debug_allocator.c:// i64: -3617008641903833651 / 14829735431805717965
../../utils/debug_allocator.c:// f16: -23.20313
../../utils/debug_allocator.c:// f32: -4.316021e+08
../../utils/debug_allocator.c:// f64: -6.27743856220419e+66
../../utils/debug_allocator.c:                               &allocator->resource);
../../utils/debug_allocator.c:  allocator->host_allocator = host_allocator;
../../utils/debug_allocator.c:  allocator->device = device;
../../utils/debug_allocator.c:  iree_hal_device_retain(allocator->device);
../../utils/debug_allocator.c:  allocator->device_allocator = device_allocator;
../../utils/debug_allocator.c:  iree_hal_allocator_retain(allocator->device_allocator);
../../utils/debug_allocator.c:  iree_allocator_t host_allocator = allocator->host_allocator;
../../utils/debug_allocator.c:  iree_hal_allocator_release(allocator->device_allocator);
../../utils/debug_allocator.c:  return allocator->host_allocator;
../../utils/debug_allocator.c:  return iree_hal_allocator_trim(allocator->device_allocator);
../../utils/debug_allocator.c:  iree_hal_allocator_query_statistics(allocator->device_allocator,
../../utils/debug_allocator.c:  return iree_hal_allocator_query_memory_heaps(allocator->device_allocator,
../../utils/debug_allocator.c:      allocator->device_allocator, *params, *allocation_size, params,
../../utils/debug_allocator.c:      allocator->device_allocator, *params, allocation_size, out_buffer));
../../utils/debug_allocator.c:    return iree_hal_debug_allocator_fill_on_device(allocator->device,
../../utils/debug_allocator.c:  // No-op; we never point a buffer back at us for deallocation.
../../utils/debug_allocator.c:  return iree_hal_allocator_import_buffer(allocator->device_allocator, *params,
../../utils/debug_allocator.c:  return iree_hal_allocator_export_buffer(allocator->device_allocator, buffer,
../../utils/resource_set.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/resource_set.h:  // Retained resources - may be less than the capacity derived from the block
../../utils/resource_set.h:// Number of elements in the most-recently-used resource list of a set.
../../utils/resource_set.h:// as we'll (in-theory) be able to load the entries into SIMD registers.
../../utils/resource_set.h://   32-bit: 64 / 4 = 16x4b ptrs (4 x uint32x4_t)
../../utils/resource_set.h://   64-bit: 64 / 8 = 8x8b ptrs (4 x uint64x2_t)
../../utils/resource_set.h:// "Efficient" append-only set for retaining a set of resources.
../../utils/resource_set.h:// This is a non-deterministic data structure that tries to reduce the amount of
../../utils/resource_set.h:// overhead involved in tracking a reasonably-sized set of resources (~dozens to
../../utils/resource_set.h:// This tries to elide insertions by maintaining a most-recently-used list.
../../utils/resource_set.h:// whatever user code may need to do to maintain proper lifetime - or as small
../../utils/resource_set.h:// in terms of code-size.
../../utils/resource_set.h:// **WARNING**: thread-unsafe insertion: it's assumed that sets are constructed
../../utils/resource_set.h:  // TODO(benvanik): ensure alignment on the set - should be at
../../utils/resource_set.h:// Inserts zero or more resources into the set from a user-defined data
../../local/executable_library_demo.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/deferred_work_queue.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/deferred_work_queue.h:// bind_to_thread called on it or as a side-effect from one of the public
../../utils/deferred_work_queue.h:  // Returns a device-side event from the given host/device event.
../../utils/resource_set_test.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/resource_set_test.cc:                               &test_resource->resource);
../../utils/resource_set_test.cc:  test_resource->host_allocator = host_allocator;
../../utils/resource_set_test.cc:  test_resource->index = index;
../../utils/resource_set_test.cc:  test_resource->live_bitmap = live_bitmap;
../../utils/resource_set_test.cc:  iree_allocator_t host_allocator = resource->host_allocator;
../../utils/resource_set_test.cc:  *resource->live_bitmap &= ~(1 << resource->index);
../../utils/resource_set_test.cc:  // Allocate 5 resources - this lets us test for special paths that may handle
../../utils/resource_set_test.cc:// Tests inserting multiple resources at a time from a user-defined struct.
../../utils/resource_set_test.cc:  // Allocate 5 resources - this lets us test for special paths that may handle
../../utils/resource_set_test.cc:  // NOTE: the only requirement of the MRU is that it's _mostly_ MRU - we may
../../utils/resource_set_test.cc:  EXPECT_EQ(resource_set->mru[0], resources[31]);
../../utils/resource_set_test.cc:  EXPECT_EQ(resource_set->mru[1], resources[30]);
../../utils/resource_set_test.cc:  EXPECT_EQ(resource_set->mru[2], resources[29]);
../../utils/resource_set_test.cc:  EXPECT_EQ(resource_set->mru[3], resources[28]);
../../utils/resource_set_test.cc:  EXPECT_EQ(resource_set->mru[4], resources[27]);
../../utils/resource_set_test.cc:  EXPECT_EQ(resource_set->mru[0], resources[31]);
../../utils/resource_set_test.cc:  EXPECT_EQ(resource_set->mru[1], resources[30]);
../../utils/resource_set_test.cc:  EXPECT_EQ(resource_set->mru[2], resources[29]);
../../utils/resource_set_test.cc:  EXPECT_EQ(resource_set->mru[3], resources[28]);
../../utils/resource_set_test.cc:  EXPECT_EQ(resource_set->mru[4], resources[27]);
../../utils/resource_set_test.cc:  EXPECT_EQ(resource_set->mru[0], resources[28]);
../../utils/resource_set_test.cc:  EXPECT_EQ(resource_set->mru[1], resources[31]);
../../utils/resource_set_test.cc:  EXPECT_EQ(resource_set->mru[2], resources[30]);
../../utils/resource_set_test.cc:  EXPECT_EQ(resource_set->mru[3], resources[29]);
../../utils/resource_set_test.cc:  EXPECT_EQ(resource_set->mru[4], resources[27]);
../../utils/resource_set_test.cc:  EXPECT_EQ(resource_set->mru[0], resources[0]);
../../utils/resource_set_test.cc:  EXPECT_EQ(resource_set->mru[1], resources[28]);
../../utils/resource_set_test.cc:  EXPECT_EQ(resource_set->mru[2], resources[31]);
../../utils/resource_set_test.cc:  EXPECT_EQ(resource_set->mru[3], resources[30]);
../../utils/resource_set_test.cc:  EXPECT_EQ(resource_set->mru[4], resources[29]);
../../utils/resource_set_test.cc:  EXPECT_EQ(resource_set->mru[5], resources[27]);
../../utils/resource_set_test.cc:  // Release all of the resources - they should still be owned by the set.
../../utils/caching_allocator.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/caching_allocator.c://===----------------------------------------------------------------------===//
../../utils/caching_allocator.c://===----------------------------------------------------------------------===//
../../utils/caching_allocator.c:  out_params->heap = heap;
../../utils/caching_allocator.c:  out_params->max_allocation_size = heap.max_allocation_size;
../../utils/caching_allocator.c:  out_params->max_allocation_capacity = IREE_DEVICE_SIZE_MAX;
../../utils/caching_allocator.c:  out_params->max_free_allocation_count =
../../utils/caching_allocator.c:// Pool of arbitrarily-sized device allocations for a particular heap.
../../utils/caching_allocator.c:// Thread-safe. Pools can service requests from multiple threads concurrently by
../../utils/caching_allocator.c:// way of a pool-specific mutex. The mutex will not be held during underlying
../../utils/caching_allocator.c:// extremely slow and the underlying allocator is also assumed thread-safe.
../../utils/caching_allocator.c:  // acquired/released from multiple threads if shared across user-visible
../../utils/caching_allocator.c:  // Note that we keep the mutex per-pool so that if we do need to allocate or
../../utils/caching_allocator.c:  out_pool->params = params;
../../utils/caching_allocator.c:  out_pool->device_allocator = device_allocator;
../../utils/caching_allocator.c:  iree_slim_mutex_initialize(&out_pool->mutex);
../../utils/caching_allocator.c:  out_pool->total_allocated_size = 0;
../../utils/caching_allocator.c:  out_pool->free_allocated_size = 0;
../../utils/caching_allocator.c:  out_pool->free_count = 0;
../../utils/caching_allocator.c:                            out_pool->free_allocated_size);
../../utils/caching_allocator.c:  IREE_ASSERT_EQ(pool->total_allocated_size, 0,
../../utils/caching_allocator.c:  IREE_ASSERT_EQ(pool->free_allocated_size, 0,
../../utils/caching_allocator.c:  IREE_ASSERT_EQ(pool->free_count, 0,
../../utils/caching_allocator.c:  iree_slim_mutex_deinitialize(&pool->mutex);
../../utils/caching_allocator.c:  IREE_ASSERT_LT(pool->free_count, pool->params.max_free_allocation_count);
../../utils/caching_allocator.c:  iree_host_size_t i = pool->free_count++;
../../utils/caching_allocator.c:  pool->free_buffers[i] = buffer;
../../utils/caching_allocator.c:  pool->free_allocated_size += buffer->allocation_size;
../../utils/caching_allocator.c:                            pool->free_allocated_size);
../../utils/caching_allocator.c:  iree_hal_buffer_t* buffer = pool->free_buffers[i];
../../utils/caching_allocator.c:  if (i < pool->free_count - 1) {
../../utils/caching_allocator.c:    memmove(&pool->free_buffers[i], &pool->free_buffers[i + 1],
../../utils/caching_allocator.c:            (pool->free_count - i - 1) * sizeof(pool->free_buffers[0]));
../../utils/caching_allocator.c:  --pool->free_count;
../../utils/caching_allocator.c:  pool->free_allocated_size -= buffer->allocation_size;
../../utils/caching_allocator.c:                            pool->free_allocated_size);
../../utils/caching_allocator.c:  for (int i = (int)pool->free_count - 1; i >= 0; --i) {
../../utils/caching_allocator.c:    iree_hal_buffer_t* buffer = pool->free_buffers[i];
../../utils/caching_allocator.c:    if (iree_all_bits_set(iree_hal_buffer_memory_type(buffer), params->type) &&
../../utils/caching_allocator.c:                          params->usage) &&
../../utils/caching_allocator.c:// Thread-safe; multiple threads may concurrently access the |pool|.
../../utils/caching_allocator.c:  iree_slim_mutex_lock(&pool->mutex);
../../utils/caching_allocator.c:  while (pool->free_count > 0 && pool->total_allocated_size > target_size) {
../../utils/caching_allocator.c:                                                       pool->free_count - 1);
../../utils/caching_allocator.c:    // the total yet - we want to do that only after releasing the buffer.
../../utils/caching_allocator.c:    iree_slim_mutex_unlock(&pool->mutex);
../../utils/caching_allocator.c:    iree_hal_allocator_deallocate_buffer(pool->device_allocator, dead_buffer);
../../utils/caching_allocator.c:    iree_slim_mutex_lock(&pool->mutex);
../../utils/caching_allocator.c:    IREE_ASSERT_GE(pool->total_allocated_size, allocation_size);
../../utils/caching_allocator.c:    pool->total_allocated_size -= allocation_size;
../../utils/caching_allocator.c:  iree_slim_mutex_unlock(&pool->mutex);
../../utils/caching_allocator.c:// Thread-safe; multiple threads may concurrently access the |pool|.
../../utils/caching_allocator.c:  iree_slim_mutex_lock(&pool->mutex);
../../utils/caching_allocator.c:    pool->total_allocated_size += allocation_size;
../../utils/caching_allocator.c:  iree_slim_mutex_unlock(&pool->mutex);
../../utils/caching_allocator.c:      pool, pool->params.max_allocation_capacity);
../../utils/caching_allocator.c:      pool->device_allocator, *params, allocation_size, &buffer);
../../utils/caching_allocator.c:    iree_slim_mutex_lock(&pool->mutex);
../../utils/caching_allocator.c:    pool->total_allocated_size -= allocation_size;
../../utils/caching_allocator.c:    iree_slim_mutex_unlock(&pool->mutex);
../../utils/caching_allocator.c:// Thread-safe; multiple threads may concurrently access the |pool|.
../../utils/caching_allocator.c:  iree_slim_mutex_lock(&pool->mutex);
../../utils/caching_allocator.c:  const bool under_capacity = pool->total_allocated_size - allocation_size <=
../../utils/caching_allocator.c:                              pool->params.max_allocation_capacity;
../../utils/caching_allocator.c:      pool->free_count + 1 <= pool->params.max_free_allocation_count;
../../utils/caching_allocator.c:    iree_slim_mutex_unlock(&pool->mutex);
../../utils/caching_allocator.c:    iree_hal_allocator_deallocate_buffer(pool->device_allocator, buffer);
../../utils/caching_allocator.c:    iree_slim_mutex_lock(&pool->mutex);
../../utils/caching_allocator.c:    pool->total_allocated_size -= allocation_size;
../../utils/caching_allocator.c:  iree_slim_mutex_unlock(&pool->mutex);
../../utils/caching_allocator.c://===----------------------------------------------------------------------===//
../../utils/caching_allocator.c://===----------------------------------------------------------------------===//
../../utils/caching_allocator.c:  // Allocate the allocator itself and then a trailing list of variable-length
../../utils/caching_allocator.c:  iree_host_size_t pool_list_size = pool_count * sizeof(allocator->pools[0]);
../../utils/caching_allocator.c:        sizeof(*pool) + sizeof(pool->free_buffers[0]) *
../../utils/caching_allocator.c:                               &allocator->resource);
../../utils/caching_allocator.c:  allocator->host_allocator = host_allocator;
../../utils/caching_allocator.c:  allocator->device_allocator = device_allocator;
../../utils/caching_allocator.c:  iree_hal_allocator_retain(allocator->device_allocator);
../../utils/caching_allocator.c:  allocator->pool_count = pool_count;
../../utils/caching_allocator.c:        sizeof(*pool) + sizeof(pool->free_buffers[0]) *
../../utils/caching_allocator.c:    allocator->pools[i] = pool;
../../utils/caching_allocator.c:  // user-provided pool parameters to heaps. It's likely that not all heaps
../../utils/caching_allocator.c:                                             &pool_params->max_allocation_size),
../../utils/caching_allocator.c:                               &pool_params->max_allocation_capacity),
../../utils/caching_allocator.c:      pool_params->max_free_allocation_count = max_free_allocation_count;
../../utils/caching_allocator.c:  iree_allocator_t host_allocator = allocator->host_allocator;
../../utils/caching_allocator.c:  for (iree_host_size_t i = 0; i < allocator->pool_count; ++i) {
../../utils/caching_allocator.c:    iree_hal_caching_allocator_pool_deinitialize(allocator->pools[i]);
../../utils/caching_allocator.c:  iree_hal_allocator_release(allocator->device_allocator);
../../utils/caching_allocator.c:  return allocator->host_allocator;
../../utils/caching_allocator.c:  for (iree_host_size_t i = 0; i < allocator->pool_count; ++i) {
../../utils/caching_allocator.c:    iree_hal_caching_allocator_pool_trim(allocator->pools[i]);
../../utils/caching_allocator.c:  return iree_hal_allocator_trim(allocator->device_allocator);
../../utils/caching_allocator.c:  iree_hal_allocator_query_statistics(allocator->device_allocator,
../../utils/caching_allocator.c:  return iree_hal_allocator_query_memory_heaps(allocator->device_allocator,
../../utils/caching_allocator.c:      allocator->device_allocator, *params, *allocation_size, params,
../../utils/caching_allocator.c:  for (iree_host_size_t i = 0; i < allocator->pool_count; ++i) {
../../utils/caching_allocator.c:    iree_hal_allocator_memory_heap_t heap = allocator->pools[i]->params.heap;
../../utils/caching_allocator.c:      return allocator->pools[i];
../../utils/caching_allocator.c:  if (iree_any_bit_set(params->usage,
../../utils/caching_allocator.c:  // If we don't want to pool then early-exit to the backing allocator.
../../utils/caching_allocator.c:        allocator->device_allocator, *params, allocation_size, out_buffer);
../../utils/caching_allocator.c:                             allocator->device_allocator, *params,
../../utils/caching_allocator.c:    return iree_hal_allocator_allocate_buffer(allocator->device_allocator,
../../utils/caching_allocator.c:  (*out_buffer)->pooling_allocator = base_allocator;
../../utils/caching_allocator.c:  return iree_hal_allocator_import_buffer(allocator->device_allocator, *params,
../../utils/caching_allocator.c:  return iree_hal_allocator_export_buffer(allocator->device_allocator, buffer,
../../local/local_executable_cache.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/local_executable_cache.c:      loader_count * sizeof(*executable_cache->loaders) + identifier.size;
../../local/local_executable_cache.c:                                 &executable_cache->resource);
../../local/local_executable_cache.c:    executable_cache->host_allocator = host_allocator;
../../local/local_executable_cache.c:        identifier, &executable_cache->identifier,
../../local/local_executable_cache.c:        (char*)executable_cache + total_size - identifier.size);
../../local/local_executable_cache.c:    executable_cache->worker_capacity = worker_capacity;
../../local/local_executable_cache.c:    executable_cache->loader_count = loader_count;
../../local/local_executable_cache.c:    for (iree_host_size_t i = 0; i < executable_cache->loader_count; ++i) {
../../local/local_executable_cache.c:      executable_cache->loaders[i] = loaders[i];
../../local/local_executable_cache.c:      iree_hal_executable_loader_retain(executable_cache->loaders[i]);
../../local/local_executable_cache.c:  iree_allocator_t host_allocator = executable_cache->host_allocator;
../../local/local_executable_cache.c:  for (iree_host_size_t i = 0; i < executable_cache->loader_count; ++i) {
../../local/local_executable_cache.c:    iree_hal_executable_loader_release(executable_cache->loaders[i]);
../../local/local_executable_cache.c:  for (iree_host_size_t i = 0; i < executable_cache->loader_count; ++i) {
../../local/local_executable_cache.c:            executable_cache->loaders[i], caching_mode, executable_format)) {
../../local/local_executable_cache.c:  for (iree_host_size_t i = 0; i < executable_cache->loader_count; ++i) {
../../local/local_executable_cache.c:            executable_cache->loaders[i], executable_params->caching_mode,
../../local/local_executable_cache.c:            executable_params->executable_format)) {
../../local/local_executable_cache.c:        executable_cache->loaders[i], executable_params,
../../local/local_executable_cache.c:        executable_cache->worker_capacity, out_executable);
../../local/local_executable_cache.c:      (int)executable_params->executable_format.size,
../../local/local_executable_cache.c:      executable_params->executable_format.data);
../../utils/executable_debug_info.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/executable_debug_info.c:        "expected debug info field `%s` to contain a non-empty string value",
../../utils/executable_debug_info.c:    out_info->function_name = iree_make_string_view(ptr, name_length);
../../utils/executable_debug_info.c:    out_info->source_filename = iree_make_string_view(ptr, filename_length);
../../utils/deferred_work_queue.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/deferred_work_queue.c://===----------------------------------------------------------------------===//
../../utils/deferred_work_queue.c://===----------------------------------------------------------------------===//
../../utils/deferred_work_queue.c:  // Intrusive doubly-linked list next entry pointer.
../../utils/deferred_work_queue.c:  // Intrusive doubly-linked list previous entry pointer.
../../utils/deferred_work_queue.c:  for (iree_host_size_t i = 0; i < action->event_count; ++i) {
../../utils/deferred_work_queue.c:    action->device_interface->vtable->release_wait_event(
../../utils/deferred_work_queue.c:        action->device_interface, action->wait_events[i]);
../../utils/deferred_work_queue.c:  action->event_count = 0;
../../utils/deferred_work_queue.c://===----------------------------------------------------------------------===//
../../utils/deferred_work_queue.c://===----------------------------------------------------------------------===//
../../utils/deferred_work_queue.c:  return list->head == NULL;
../../utils/deferred_work_queue.c:  IREE_ASSERT(list->head && list->tail);
../../utils/deferred_work_queue.c:  iree_hal_deferred_work_queue_action_t* action = list->head;
../../utils/deferred_work_queue.c:  IREE_ASSERT(!action->prev);
../../utils/deferred_work_queue.c:  list->head = action->next;
../../utils/deferred_work_queue.c:  if (action->next) {
../../utils/deferred_work_queue.c:    action->next->prev = NULL;
../../utils/deferred_work_queue.c:    action->next = NULL;
../../utils/deferred_work_queue.c:  if (list->tail == action) {
../../utils/deferred_work_queue.c:    list->tail = NULL;
../../utils/deferred_work_queue.c:  IREE_ASSERT(!action->next && !action->prev);
../../utils/deferred_work_queue.c:  if (list->tail) {
../../utils/deferred_work_queue.c:    list->tail->next = action;
../../utils/deferred_work_queue.c:    list->head = action;
../../utils/deferred_work_queue.c:  action->prev = list->tail;
../../utils/deferred_work_queue.c:  list->tail = action;
../../utils/deferred_work_queue.c:  ready_list->head = available_list->head;
../../utils/deferred_work_queue.c:  ready_list->tail = available_list->tail;
../../utils/deferred_work_queue.c:  available_list->head = NULL;
../../utils/deferred_work_queue.c:  available_list->tail = NULL;
../../utils/deferred_work_queue.c:    iree_hal_deferred_work_queue_action_t* next_action = head_action->next;
../../utils/deferred_work_queue.c://===----------------------------------------------------------------------===//
../../utils/deferred_work_queue.c:// Ready-list processing
../../utils/deferred_work_queue.c://===----------------------------------------------------------------------===//
../../utils/deferred_work_queue.c:  iree_slim_mutex_lock(&list->guard_mutex);
../../utils/deferred_work_queue.c:  if (list->head) {
../../utils/deferred_work_queue.c:    out = list->head;
../../utils/deferred_work_queue.c:    list->head = list->head->next;
../../utils/deferred_work_queue.c:    if (out == list->tail) {
../../utils/deferred_work_queue.c:      list->tail = NULL;
../../utils/deferred_work_queue.c:  iree_slim_mutex_unlock(&list->guard_mutex);
../../utils/deferred_work_queue.c:  iree_slim_mutex_lock(&list->guard_mutex);
../../utils/deferred_work_queue.c:  next->next = NULL;
../../utils/deferred_work_queue.c:  if (list->tail) {
../../utils/deferred_work_queue.c:    list->tail->next = next;
../../utils/deferred_work_queue.c:    list->tail = next;
../../utils/deferred_work_queue.c:    list->head = next;
../../utils/deferred_work_queue.c:    list->tail = next;
../../utils/deferred_work_queue.c:  iree_slim_mutex_unlock(&list->guard_mutex);
../../utils/deferred_work_queue.c:  iree_hal_deferred_work_queue_entry_list_node_t* head = list->head;
../../utils/deferred_work_queue.c:    iree_hal_deferred_work_queue_action_list_destroy(head->ready_list_head);
../../utils/deferred_work_queue.c:    list->head = head->next;
../../utils/deferred_work_queue.c:  iree_slim_mutex_deinitialize(&list->guard_mutex);
../../utils/deferred_work_queue.c:  list->head = NULL;
../../utils/deferred_work_queue.c:  list->tail = NULL;
../../utils/deferred_work_queue.c:  iree_slim_mutex_initialize(&list->guard_mutex);
../../utils/deferred_work_queue.c:  iree_slim_mutex_lock(&list->guard_mutex);
../../utils/deferred_work_queue.c:  if (list->head) {
../../utils/deferred_work_queue.c:    out = list->head;
../../utils/deferred_work_queue.c:    list->head = list->head->next;
../../utils/deferred_work_queue.c:    if (out == list->tail) {
../../utils/deferred_work_queue.c:      list->tail = NULL;
../../utils/deferred_work_queue.c:  iree_slim_mutex_unlock(&list->guard_mutex);
../../utils/deferred_work_queue.c:  iree_slim_mutex_lock(&list->guard_mutex);
../../utils/deferred_work_queue.c:  next->next = NULL;
../../utils/deferred_work_queue.c:  if (list->tail) {
../../utils/deferred_work_queue.c:    list->tail->next = next;
../../utils/deferred_work_queue.c:    list->tail = next;
../../utils/deferred_work_queue.c:    list->head = next;
../../utils/deferred_work_queue.c:    list->tail = next;
../../utils/deferred_work_queue.c:  iree_slim_mutex_unlock(&list->guard_mutex);
../../utils/deferred_work_queue.c:  list->head = NULL;
../../utils/deferred_work_queue.c:  list->tail = NULL;
../../utils/deferred_work_queue.c:  iree_slim_mutex_initialize(&list->guard_mutex);
../../utils/deferred_work_queue.c:  iree_hal_deferred_work_queue_completion_list_node_t* head = list->head;
../../utils/deferred_work_queue.c:    if (head->created_event) {
../../utils/deferred_work_queue.c:      device_interface->vtable->destroy_native_event(device_interface,
../../utils/deferred_work_queue.c:                                                     head->native_event);
../../utils/deferred_work_queue.c:    list->head = list->head->next;
../../utils/deferred_work_queue.c:  iree_slim_mutex_deinitialize(&list->guard_mutex);
../../utils/deferred_work_queue.c:  IREE_ASSERT(list->ready_list_head);
../../utils/deferred_work_queue.c:  iree_hal_deferred_work_queue_action_t* action = list->ready_list_head;
../../utils/deferred_work_queue.c:  IREE_ASSERT(!action->prev);
../../utils/deferred_work_queue.c:  list->ready_list_head = action->next;
../../utils/deferred_work_queue.c:  if (action->next) {
../../utils/deferred_work_queue.c:    action->next->prev = NULL;
../../utils/deferred_work_queue.c:    action->next = NULL;
../../utils/deferred_work_queue.c:  IREE_ASSERT(!action->next && !action->prev);
../../utils/deferred_work_queue.c:  iree_hal_deferred_work_queue_action_t* head = entry->ready_list_head;
../../utils/deferred_work_queue.c:  entry->ready_list_head = action;
../../utils/deferred_work_queue.c:    action->next = head;
../../utils/deferred_work_queue.c:    head->prev = action;
../../utils/deferred_work_queue.c:// The ready-list processing worker's working/exiting state.
../../utils/deferred_work_queue.c:// States in the list has increasing priorities--meaning normally ones appearing
../../utils/deferred_work_queue.c:// The data structure needed by a ready-list processing worker thread to issue
../../utils/deferred_work_queue.c:  iree_notification_initialize(&working_area->state_notification);
../../utils/deferred_work_queue.c:      &working_area->ready_worklist, host_allocator);
../../utils/deferred_work_queue.c:  iree_atomic_store(&working_area->worker_state,
../../utils/deferred_work_queue.c:      &working_area->ready_worklist, host_allocator);
../../utils/deferred_work_queue.c:  iree_notification_deinitialize(&working_area->state_notification);
../../utils/deferred_work_queue.c:  iree_notification_initialize(&completion_area->state_notification);
../../utils/deferred_work_queue.c:      &completion_area->completion_list);
../../utils/deferred_work_queue.c:  iree_atomic_store(&completion_area->worker_state,
../../utils/deferred_work_queue.c:      &completion_area->completion_list, device_interface, host_allocator);
../../utils/deferred_work_queue.c:  iree_notification_deinitialize(&completion_area->state_notification);
../../utils/deferred_work_queue.c:// The main function for the ready-list processing worker thread.
../../utils/deferred_work_queue.c://===----------------------------------------------------------------------===//
../../utils/deferred_work_queue.c://===----------------------------------------------------------------------===//
../../utils/deferred_work_queue.c:  // Non-recursive mutex guarding access.
../../utils/deferred_work_queue.c:  // The double-linked list of deferred work.
../../utils/deferred_work_queue.c:  actions->host_allocator = host_allocator;
../../utils/deferred_work_queue.c:  actions->block_pool = block_pool;
../../utils/deferred_work_queue.c:  actions->device_interface = device_interface;
../../utils/deferred_work_queue.c:  iree_slim_mutex_initialize(&actions->action_mutex);
../../utils/deferred_work_queue.c:  memset(&actions->action_list, 0, sizeof(actions->action_list));
../../utils/deferred_work_queue.c:  // Initialize the working area for the ready-list processing worker.
../../utils/deferred_work_queue.c:      &actions->working_area;
../../utils/deferred_work_queue.c:      &actions->completion_area;
../../utils/deferred_work_queue.c:  // Create the ready-list processing worker itself.
../../utils/deferred_work_queue.c:  params.name = IREE_SV("iree-hip-queue-worker");
../../utils/deferred_work_queue.c:      params, actions->host_allocator, &actions->worker_thread);
../../utils/deferred_work_queue.c:  params.name = IREE_SV("iree-hip-queue-completion");
../../utils/deferred_work_queue.c:        actions, params, actions->host_allocator, &actions->completion_thread);
../../utils/deferred_work_queue.c:  iree_atomic_store(&working_area->worker_state,
../../utils/deferred_work_queue.c:  iree_notification_post(&working_area->state_notification, IREE_ALL_WAITERS);
../../utils/deferred_work_queue.c:  iree_atomic_store(&completion_area->worker_state,
../../utils/deferred_work_queue.c:  iree_notification_post(&completion_area->state_notification,
../../utils/deferred_work_queue.c:  iree_hal_deferred_work_queue_notify_worker_thread(&actions->working_area);
../../utils/deferred_work_queue.c:      &actions->completion_area);
../../utils/deferred_work_queue.c:  iree_slim_mutex_lock(&actions->action_mutex);
../../utils/deferred_work_queue.c:  actions->exit_requested = true;
../../utils/deferred_work_queue.c:  iree_slim_mutex_unlock(&actions->action_mutex);
../../utils/deferred_work_queue.c:  iree_allocator_t host_allocator = work_queue->host_allocator;
../../utils/deferred_work_queue.c:  iree_thread_release(work_queue->worker_thread);
../../utils/deferred_work_queue.c:  iree_thread_release(work_queue->completion_thread);
../../utils/deferred_work_queue.c:      &work_queue->working_area, work_queue->host_allocator);
../../utils/deferred_work_queue.c:      &work_queue->completion_area, work_queue->device_interface,
../../utils/deferred_work_queue.c:      work_queue->host_allocator);
../../utils/deferred_work_queue.c:  iree_slim_mutex_deinitialize(&work_queue->action_mutex);
../../utils/deferred_work_queue.c:      work_queue->action_list.head);
../../utils/deferred_work_queue.c:  work_queue->device_interface->vtable->destroy(work_queue->device_interface);
../../utils/deferred_work_queue.c:  iree_hal_deferred_work_queue_t* actions = action->owning_actions;
../../utils/deferred_work_queue.c:  iree_allocator_t host_allocator = actions->host_allocator;
../../utils/deferred_work_queue.c:  if (action->cleanup_callback) {
../../utils/deferred_work_queue.c:    action->cleanup_callback(action->callback_user_data);
../../utils/deferred_work_queue.c:  iree_hal_resource_set_free(action->resource_set);
../../utils/deferred_work_queue.c:  iree_slim_mutex_lock(&actions->action_mutex);
../../utils/deferred_work_queue.c:  --actions->pending_work_items_count;
../../utils/deferred_work_queue.c:  iree_slim_mutex_unlock(&actions->action_mutex);
../../utils/deferred_work_queue.c:      command_buffer_count * sizeof(*action->payload.execution.command_buffers);
../../utils/deferred_work_queue.c:      z0, iree_allocator_malloc(actions->host_allocator, total_action_size,
../../utils/deferred_work_queue.c:  action->owning_actions = actions;
../../utils/deferred_work_queue.c:  action->device_interface = actions->device_interface;
../../utils/deferred_work_queue.c:  action->state = IREE_HAL_QUEUE_ACTION_STATE_ALIVE;
../../utils/deferred_work_queue.c:  action->cleanup_callback = cleanup_callback;
../../utils/deferred_work_queue.c:  action->callback_user_data = callback_user_data;
../../utils/deferred_work_queue.c:  action->kind = IREE_HAL_QUEUE_ACTION_TYPE_EXECUTION;
../../utils/deferred_work_queue.c:  action->event_count = 0;
../../utils/deferred_work_queue.c:  action->is_pending = true;
../../utils/deferred_work_queue.c:  action->wait_semaphore_list.count = wait_semaphore_list.count;
../../utils/deferred_work_queue.c:  action->wait_semaphore_list.semaphores = (iree_hal_semaphore_t**)action_ptr;
../../utils/deferred_work_queue.c:  memcpy(action->wait_semaphore_list.semaphores, wait_semaphore_list.semaphores,
../../utils/deferred_work_queue.c:  action->wait_semaphore_list.payload_values =
../../utils/deferred_work_queue.c:      action->wait_semaphore_list.payload_values,
../../utils/deferred_work_queue.c:  action->signal_semaphore_list.count = signal_semaphore_list.count;
../../utils/deferred_work_queue.c:  action->signal_semaphore_list.semaphores = (iree_hal_semaphore_t**)action_ptr;
../../utils/deferred_work_queue.c:      action->signal_semaphore_list.semaphores,
../../utils/deferred_work_queue.c:  action->signal_semaphore_list.payload_values =
../../utils/deferred_work_queue.c:  memcpy(action->signal_semaphore_list.payload_values,
../../utils/deferred_work_queue.c:  action->payload.execution.count = command_buffer_count;
../../utils/deferred_work_queue.c:  action->payload.execution.command_buffers =
../../utils/deferred_work_queue.c:  memcpy(action->payload.execution.command_buffers, command_buffers,
../../utils/deferred_work_queue.c:  iree_status_t status = iree_hal_resource_set_allocate(actions->block_pool,
../../utils/deferred_work_queue.c:                                                        &action->resource_set);
../../utils/deferred_work_queue.c:    status = iree_hal_resource_set_insert(action->resource_set,
../../utils/deferred_work_queue.c:    status = iree_hal_resource_set_insert(action->resource_set,
../../utils/deferred_work_queue.c:        action->resource_set, command_buffer_count, command_buffers);
../../utils/deferred_work_queue.c:    action->payload.execution.binding_tables =
../../utils/deferred_work_queue.c:          &action->payload.execution.binding_tables[i];
../../utils/deferred_work_queue.c:      target_table->count = element_count;
../../utils/deferred_work_queue.c:      target_table->bindings = binding_element_ptr;
../../utils/deferred_work_queue.c:      memcpy((void*)target_table->bindings, binding_tables[i].bindings,
../../utils/deferred_work_queue.c:          action->resource_set, element_count, target_table->bindings,
../../utils/deferred_work_queue.c:    action->payload.execution.binding_tables = NULL;
../../utils/deferred_work_queue.c:    iree_slim_mutex_lock(&actions->action_mutex);
../../utils/deferred_work_queue.c:    if (actions->exit_requested) {
../../utils/deferred_work_queue.c:      iree_hal_deferred_work_queue_action_list_push_back(&actions->action_list,
../../utils/deferred_work_queue.c:      actions->pending_work_items_count += 1;
../../utils/deferred_work_queue.c:    iree_slim_mutex_unlock(&actions->action_mutex);
../../utils/deferred_work_queue.c:    iree_hal_resource_set_free(action->resource_set);
../../utils/deferred_work_queue.c:    iree_allocator_free(actions->host_allocator, action);
../../utils/deferred_work_queue.c:      z0, iree_allocator_malloc(actions->host_allocator, total_action_size,
../../utils/deferred_work_queue.c:  action->owning_actions = actions;
../../utils/deferred_work_queue.c:  action->device_interface = actions->device_interface;
../../utils/deferred_work_queue.c:  action->state = IREE_HAL_QUEUE_ACTION_STATE_ALIVE;
../../utils/deferred_work_queue.c:  action->cleanup_callback = NULL;
../../utils/deferred_work_queue.c:  action->callback_user_data = NULL;
../../utils/deferred_work_queue.c:  action->kind = kind;
../../utils/deferred_work_queue.c:  action->event_count = 0;
../../utils/deferred_work_queue.c:  action->is_pending = true;
../../utils/deferred_work_queue.c:  action->wait_semaphore_list.count = wait_semaphore_list.count;
../../utils/deferred_work_queue.c:  action->wait_semaphore_list.semaphores = (iree_hal_semaphore_t**)action_ptr;
../../utils/deferred_work_queue.c:  memcpy(action->wait_semaphore_list.semaphores, wait_semaphore_list.semaphores,
../../utils/deferred_work_queue.c:  action->wait_semaphore_list.payload_values =
../../utils/deferred_work_queue.c:      action->wait_semaphore_list.payload_values,
../../utils/deferred_work_queue.c:  action->signal_semaphore_list.count = signal_semaphore_list.count;
../../utils/deferred_work_queue.c:  action->signal_semaphore_list.semaphores = (iree_hal_semaphore_t**)action_ptr;
../../utils/deferred_work_queue.c:      action->signal_semaphore_list.semaphores,
../../utils/deferred_work_queue.c:  action->signal_semaphore_list.payload_values =
../../utils/deferred_work_queue.c:  memcpy(action->signal_semaphore_list.payload_values,
../../utils/deferred_work_queue.c:  action->payload.alloc.buffer = buffer;
../../utils/deferred_work_queue.c:  iree_status_t status = iree_hal_resource_set_allocate(actions->block_pool,
../../utils/deferred_work_queue.c:                                                        &action->resource_set);
../../utils/deferred_work_queue.c:    status = iree_hal_resource_set_insert(action->resource_set,
../../utils/deferred_work_queue.c:    status = iree_hal_resource_set_insert(action->resource_set,
../../utils/deferred_work_queue.c:    status = iree_hal_resource_set_insert(action->resource_set, 1, &buffer);
../../utils/deferred_work_queue.c:    iree_slim_mutex_lock(&actions->action_mutex);
../../utils/deferred_work_queue.c:    if (actions->exit_requested) {
../../utils/deferred_work_queue.c:      iree_hal_deferred_work_queue_action_list_push_back(&actions->action_list,
../../utils/deferred_work_queue.c:      actions->pending_work_items_count += 1;
../../utils/deferred_work_queue.c:    iree_slim_mutex_unlock(&actions->action_mutex);
../../utils/deferred_work_queue.c:    iree_hal_resource_set_free(action->resource_set);
../../utils/deferred_work_queue.c:    iree_allocator_free(actions->host_allocator, action);
../../utils/deferred_work_queue.c:  if (iree_status_is_ok(actions->status) && status != actions->status) {
../../utils/deferred_work_queue.c:    actions->status = iree_status_clone(status);
../../utils/deferred_work_queue.c:  iree_hal_deferred_work_queue_t* actions = action->owning_actions;
../../utils/deferred_work_queue.c:  iree_slim_mutex_unlock(&actions->action_mutex);
../../utils/deferred_work_queue.c:  iree_hal_semaphore_list_fail(action->signal_semaphore_list,
../../utils/deferred_work_queue.c:  iree_slim_mutex_lock(&actions->action_mutex);
../../utils/deferred_work_queue.c:  action->owning_actions->pending_work_items_count -= 1;
../../utils/deferred_work_queue.c:  iree_hal_deferred_work_queue_t* actions = action->owning_actions;
../../utils/deferred_work_queue.c:  iree_slim_mutex_lock(&actions->action_mutex);
../../utils/deferred_work_queue.c:  iree_slim_mutex_unlock(&actions->action_mutex);
../../utils/deferred_work_queue.c:    iree_hal_deferred_work_queue_action_t* next_action = head_action->next;
../../utils/deferred_work_queue.c:        entry->ready_list_head, status);
../../utils/deferred_work_queue.c:  iree_hal_deferred_work_queue_action_list_fail_locked(&actions->action_list,
../../utils/deferred_work_queue.c:      &actions->working_area.ready_worklist, status);
../../utils/deferred_work_queue.c:  iree_slim_mutex_lock(&actions->action_mutex);
../../utils/deferred_work_queue.c:  iree_slim_mutex_unlock(&actions->action_mutex);
../../utils/deferred_work_queue.c:  IREE_ASSERT_LE(action->kind, IREE_HAL_QUEUE_ACTION_TYPE_QUEUE_MAX);
../../utils/deferred_work_queue.c:  IREE_ASSERT_EQ(action->state, IREE_HAL_QUEUE_ACTION_STATE_ALIVE);
../../utils/deferred_work_queue.c:  status = iree_hal_semaphore_list_signal(action->signal_semaphore_list);
../../utils/deferred_work_queue.c:  IREE_ASSERT_LE(action->kind, IREE_HAL_QUEUE_ACTION_TYPE_QUEUE_MAX);
../../utils/deferred_work_queue.c:  IREE_ASSERT_EQ(action->is_pending, false);
../../utils/deferred_work_queue.c:  iree_hal_deferred_work_queue_t* actions = action->owning_actions;
../../utils/deferred_work_queue.c:      actions->device_interface;
../../utils/deferred_work_queue.c:  for (iree_host_size_t i = 0; i < action->event_count; ++i) {
../../utils/deferred_work_queue.c:        z0, device_interface->vtable->device_wait_on_host_event(
../../utils/deferred_work_queue.c:                device_interface, action->wait_events[i]));
../../utils/deferred_work_queue.c:  switch (action->kind) {
../../utils/deferred_work_queue.c:      for (iree_host_size_t i = 0; i < action->payload.execution.count; ++i) {
../../utils/deferred_work_queue.c:            action->payload.execution.command_buffers[i];
../../utils/deferred_work_queue.c:            action->payload.execution.binding_tables
../../utils/deferred_work_queue.c:                ? action->payload.execution.binding_tables[i]
../../utils/deferred_work_queue.c:              z0, device_interface->vtable->create_stream_command_buffer(
../../utils/deferred_work_queue.c:              z0, iree_hal_resource_set_insert(action->resource_set, 1,
../../utils/deferred_work_queue.c:            z0, device_interface->vtable->submit_command_buffer(
../../utils/deferred_work_queue.c:        // the action->resource_set and deleted after the action
../../utils/deferred_work_queue.c:          z0, device_interface->vtable->async_alloc(
../../utils/deferred_work_queue.c:                  device_interface, action->payload.alloc.buffer));
../../utils/deferred_work_queue.c:          z0, device_interface->vtable->async_dealloc(
../../utils/deferred_work_queue.c:                  device_interface, action->payload.dealloc.buffer));
../../utils/deferred_work_queue.c:  for (iree_host_size_t i = 0; i < action->signal_semaphore_list.count; ++i) {
../../utils/deferred_work_queue.c:        device_interface->vtable
../../utils/deferred_work_queue.c:            ->semaphore_acquire_timepoint_device_signal_native_event(
../../utils/deferred_work_queue.c:                device_interface, action->signal_semaphore_list.semaphores[i],
../../utils/deferred_work_queue.c:                action->signal_semaphore_list.payload_values[i], &event));
../../utils/deferred_work_queue.c:        device_interface->vtable->record_native_event(device_interface, event));
../../utils/deferred_work_queue.c:  // we can re-use those as a wait event. However if there are no signals
../../utils/deferred_work_queue.c:        z0, device_interface->vtable->create_native_event(device_interface,
../../utils/deferred_work_queue.c:      z0, device_interface->vtable->record_native_event(device_interface,
../../utils/deferred_work_queue.c:  iree_status_t status = iree_allocator_malloc(actions->host_allocator,
../../utils/deferred_work_queue.c:  entry->native_event = completion_event;
../../utils/deferred_work_queue.c:  entry->created_event = created_event;
../../utils/deferred_work_queue.c:  entry->callback =
../../utils/deferred_work_queue.c:  entry->user_data = action;
../../utils/deferred_work_queue.c:      &actions->completion_area.completion_list, entry);
../../utils/deferred_work_queue.c:      &actions->completion_area);
../../utils/deferred_work_queue.c:  iree_slim_mutex_lock(&actions->action_mutex);
../../utils/deferred_work_queue.c:          &actions->action_list)) {
../../utils/deferred_work_queue.c:    iree_slim_mutex_unlock(&actions->action_mutex);
../../utils/deferred_work_queue.c:  if (IREE_UNLIKELY(!iree_status_is_ok(actions->status))) {
../../utils/deferred_work_queue.c:    iree_hal_deferred_work_queue_action_list_fail_locked(&actions->action_list,
../../utils/deferred_work_queue.c:                                                         actions->status);
../../utils/deferred_work_queue.c:    iree_slim_mutex_unlock(&actions->action_mutex);
../../utils/deferred_work_queue.c:      &actions->action_list)) {
../../utils/deferred_work_queue.c:            &actions->action_list);
../../utils/deferred_work_queue.c:    iree_hal_semaphore_t** semaphores = action->wait_semaphore_list.semaphores;
../../utils/deferred_work_queue.c:    uint64_t* values = action->wait_semaphore_list.payload_values;
../../utils/deferred_work_queue.c:    action->is_pending = false;
../../utils/deferred_work_queue.c:    if (action->state == IREE_HAL_QUEUE_ACTION_STATE_ALIVE) {
../../utils/deferred_work_queue.c:      for (iree_host_size_t i = 0; i < action->wait_semaphore_list.count; ++i) {
../../utils/deferred_work_queue.c:          iree_hal_semaphore_list_erase(&action->wait_semaphore_list, i);
../../utils/deferred_work_queue.c:          --i;
../../utils/deferred_work_queue.c:        if (!action->device_interface->vtable->acquire_host_wait_event(
../../utils/deferred_work_queue.c:                action->device_interface, semaphores[i], values[i],
../../utils/deferred_work_queue.c:          action->is_pending = true;
../../utils/deferred_work_queue.c:        if (IREE_UNLIKELY(action->event_count >=
../../utils/deferred_work_queue.c:          action->device_interface->vtable->release_wait_event(
../../utils/deferred_work_queue.c:              action->device_interface, wait_event);
../../utils/deferred_work_queue.c:          if (iree_status_is_ok(actions->status)) {
../../utils/deferred_work_queue.c:            actions->status = status;
../../utils/deferred_work_queue.c:        action->wait_events[action->event_count++] = wait_event;
../../utils/deferred_work_queue.c:        iree_hal_semaphore_list_erase(&action->wait_semaphore_list, i);
../../utils/deferred_work_queue.c:        --i;
../../utils/deferred_work_queue.c:    if (IREE_UNLIKELY(!iree_status_is_ok(actions->status))) {
../../utils/deferred_work_queue.c:                                                        actions->status);
../../utils/deferred_work_queue.c:          &actions->action_list, actions->status);
../../utils/deferred_work_queue.c:    if (action->is_pending) {
../../utils/deferred_work_queue.c:        switch (action->kind) {
../../utils/deferred_work_queue.c:  actions->action_list = pending_list;
../../utils/deferred_work_queue.c:  iree_slim_mutex_unlock(&actions->action_mutex);
../../utils/deferred_work_queue.c:    status = iree_allocator_malloc(actions->host_allocator, sizeof(*entry),
../../utils/deferred_work_queue.c:    iree_slim_mutex_lock(&actions->action_mutex);
../../utils/deferred_work_queue.c:    iree_slim_mutex_unlock(&actions->action_mutex);
../../utils/deferred_work_queue.c:  entry->ready_list_head = ready_list.head;
../../utils/deferred_work_queue.c:      &actions->working_area.ready_worklist, entry);
../../utils/deferred_work_queue.c:  iree_hal_deferred_work_queue_notify_worker_thread(&actions->working_area);
../../utils/deferred_work_queue.c://===----------------------------------------------------------------------===//
../../utils/deferred_work_queue.c://===----------------------------------------------------------------------===//
../../utils/deferred_work_queue.c:      iree_atomic_load(&working_area->worker_state, iree_memory_order_acquire);
../../utils/deferred_work_queue.c:      &completion_area->worker_state, iree_memory_order_acquire);
../../utils/deferred_work_queue.c:  iree_slim_mutex_lock(&actions->action_mutex);
../../utils/deferred_work_queue.c:  iree_status_t status = actions->status;
../../utils/deferred_work_queue.c:        &actions->working_area.ready_worklist, status);
../../utils/deferred_work_queue.c:    iree_slim_mutex_unlock(&actions->action_mutex);
../../utils/deferred_work_queue.c:  iree_slim_mutex_unlock(&actions->action_mutex);
../../utils/deferred_work_queue.c:            &actions->working_area.ready_worklist);
../../utils/deferred_work_queue.c:    while (entry->ready_list_head) {
../../utils/deferred_work_queue.c:      switch (action->state) {
../../utils/deferred_work_queue.c:            &actions->working_area.ready_worklist, entry);
../../utils/deferred_work_queue.c:    iree_allocator_free(actions->host_allocator, entry);
../../utils/deferred_work_queue.c:      &actions->completion_area.completion_list;
../../utils/deferred_work_queue.c:  iree_slim_mutex_lock(&actions->action_mutex);
../../utils/deferred_work_queue.c:  iree_status_t status = iree_status_clone(actions->status);
../../utils/deferred_work_queue.c:  iree_slim_mutex_unlock(&actions->action_mutex);
../../utils/deferred_work_queue.c:      status = actions->device_interface->vtable->synchronize_native_event(
../../utils/deferred_work_queue.c:          actions->device_interface, entry->native_event);
../../utils/deferred_work_queue.c:    if (entry->callback) {
../../utils/deferred_work_queue.c:          iree_status_join(status, entry->callback(status, entry->user_data));
../../utils/deferred_work_queue.c:    if (IREE_UNLIKELY(entry->created_event)) {
../../utils/deferred_work_queue.c:          status, actions->device_interface->vtable->destroy_native_event(
../../utils/deferred_work_queue.c:                      actions->device_interface, entry->native_event));
../../utils/deferred_work_queue.c:    iree_allocator_free(actions->host_allocator, entry);
../../utils/deferred_work_queue.c:      &actions->completion_area;
../../utils/deferred_work_queue.c:  iree_status_t status = actions->device_interface->vtable->bind_to_thread(
../../utils/deferred_work_queue.c:      actions->device_interface);
../../utils/deferred_work_queue.c:        &completion_area->state_notification,
../../utils/deferred_work_queue.c:    iree_atomic_store(&completion_area->worker_state,
../../utils/deferred_work_queue.c:    iree_slim_mutex_lock(&actions->action_mutex);
../../utils/deferred_work_queue.c:    if (IREE_UNLIKELY(actions->exit_requested &&
../../utils/deferred_work_queue.c:                      !actions->pending_work_items_count)) {
../../utils/deferred_work_queue.c:      iree_slim_mutex_unlock(&actions->action_mutex);
../../utils/deferred_work_queue.c:    iree_slim_mutex_unlock(&actions->action_mutex);
../../utils/deferred_work_queue.c:// The main function for the ready-list processing worker thread.
../../utils/deferred_work_queue.c:      &actions->working_area;
../../utils/deferred_work_queue.c:  // Some APIs store thread-local data. Allow the interface to bind
../../utils/deferred_work_queue.c:  // the thread-local data once for this thread rather than having to
../../utils/deferred_work_queue.c:  iree_status_t status = actions->device_interface->vtable->bind_to_thread(
../../utils/deferred_work_queue.c:      actions->device_interface);
../../utils/deferred_work_queue.c:    return -1;
../../utils/deferred_work_queue.c:        &working_area->state_notification,
../../utils/deferred_work_queue.c:    iree_atomic_store(&working_area->worker_state,
../../utils/deferred_work_queue.c:    iree_slim_mutex_lock(&actions->action_mutex);
../../utils/deferred_work_queue.c:    if (IREE_UNLIKELY(actions->exit_requested &&
../../utils/deferred_work_queue.c:                      !actions->pending_work_items_count)) {
../../utils/deferred_work_queue.c:      iree_slim_mutex_unlock(&actions->action_mutex);
../../utils/deferred_work_queue.c:          &actions->completion_area);
../../utils/deferred_work_queue.c:    iree_slim_mutex_unlock(&actions->action_mutex);
../../utils/libmpi_test.cc:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/file_transfer.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/file_transfer.c://===----------------------------------------------------------------------===//
../../utils/file_transfer.c://===----------------------------------------------------------------------===//
../../utils/file_transfer.c:// TODO(benvanik): make these either compile-time configuration options so we
../../utils/file_transfer.c://===----------------------------------------------------------------------===//
../../utils/file_transfer.c://===----------------------------------------------------------------------===//
../../utils/file_transfer.c:// 1-4 but on very large systems with lots of bandwidth we may be able to
../../utils/file_transfer.c:// an async wait on a loop for when the operation completes on the device - when
../../utils/file_transfer.c:  // Pending timepoint representing an in-flight operation. Upon completion of
../../utils/file_transfer.c:  // Some loop implementations are re-entrant and we need to be able to handle
../../utils/file_transfer.c:  // asynchronously and the ref count lets us have the top-level call clean up.
../../utils/file_transfer.c:  // Direction of the operation (read file->buffer or write buffer->file).
../../utils/file_transfer.c:  // Sticky error status; when any worker fails this will be set to non-OK and
../../utils/file_transfer.c:  total_size = worker_offset + sizeof(operation->workers[0]) * worker_count;
../../utils/file_transfer.c:  iree_atomic_ref_count_init(&operation->ref_count);
../../utils/file_transfer.c:  operation->device = device;
../../utils/file_transfer.c:  operation->queue_affinity = queue_affinity;
../../utils/file_transfer.c:  operation->direction = direction;
../../utils/file_transfer.c:  operation->file = file;
../../utils/file_transfer.c:  operation->file_offset = file_offset;
../../utils/file_transfer.c:  operation->buffer = buffer;
../../utils/file_transfer.c:  operation->buffer_offset = buffer_offset;
../../utils/file_transfer.c:  operation->length = length;
../../utils/file_transfer.c:  operation->staging_buffer_size = worker_count * worker_chunk_size;
../../utils/file_transfer.c:  operation->transfer_head = 0;
../../utils/file_transfer.c:  operation->remaining_chunks = (iree_host_size_t)total_chunk_count;
../../utils/file_transfer.c:  operation->worker_count = worker_count;
../../utils/file_transfer.c:  operation->signal_semaphore_list.count = signal_semaphore_list.count;
../../utils/file_transfer.c:  operation->signal_semaphore_list.semaphores =
../../utils/file_transfer.c:  operation->signal_semaphore_list.payload_values =
../../utils/file_transfer.c:  operation->workers =
../../utils/file_transfer.c:    operation->trace_id =
../../utils/file_transfer.c:    IREE_TRACE_ZONE_APPEND_VALUE_I64(z0, operation->trace_id);
../../utils/file_transfer.c:  memcpy(operation->signal_semaphore_list.semaphores,
../../utils/file_transfer.c:  memcpy(operation->signal_semaphore_list.payload_values,
../../utils/file_transfer.c:    iree_hal_transfer_worker_t* worker = &operation->workers[i];
../../utils/file_transfer.c:    worker->operation = operation;
../../utils/file_transfer.c:    IREE_TRACE(worker->trace_id = (int64_t)i);
../../utils/file_transfer.c:    worker->staging_buffer_offset = worker_chunk_size * i;
../../utils/file_transfer.c:    worker->staging_buffer_length = worker_chunk_size;
../../utils/file_transfer.c:    worker->pending_timepoint = 0ull;
../../utils/file_transfer.c:    status = iree_hal_semaphore_create(device, worker->pending_timepoint,
../../utils/file_transfer.c:                                       &worker->semaphore);
../../utils/file_transfer.c:    iree_atomic_ref_count_inc(&operation->ref_count);
../../utils/file_transfer.c:      iree_atomic_ref_count_dec(&operation->ref_count) == 1) {
../../utils/file_transfer.c:  IREE_TRACE_ZONE_APPEND_VALUE_I64(z0, operation->trace_id);
../../utils/file_transfer.c:      iree_hal_device_host_allocator(operation->device);
../../utils/file_transfer.c:  IREE_ASSERT(operation->live_workers == 0, "all workers must have exited");
../../utils/file_transfer.c:  for (iree_host_size_t i = 0; i < operation->worker_count; ++i) {
../../utils/file_transfer.c:    iree_hal_semaphore_release(operation->workers[i].semaphore);
../../utils/file_transfer.c:  iree_hal_buffer_release(operation->staging_buffer);
../../utils/file_transfer.c:  for (iree_host_size_t i = 0; i < operation->signal_semaphore_list.count;
../../utils/file_transfer.c:    iree_hal_semaphore_release(operation->signal_semaphore_list.semaphores[i]);
../../utils/file_transfer.c:  iree_hal_buffer_release(operation->buffer);
../../utils/file_transfer.c:  iree_hal_file_release(operation->file);
../../utils/file_transfer.c:  iree_hal_device_release(operation->device);
../../utils/file_transfer.c:  iree_status_ignore(operation->error_status);
../../utils/file_transfer.c:// Pre-condition: all workers have exited and there are no operations in flight.
../../utils/file_transfer.c:// Post-condition: the operation is freed.
../../utils/file_transfer.c:  IREE_TRACE_ZONE_APPEND_VALUE_I64(z0, operation->trace_id);
../../utils/file_transfer.c:  IREE_ASSERT(operation->live_workers == 0, "no workers can be live");
../../utils/file_transfer.c:  // completed copies into/out-of it. In reads it's expected there are copies
../../utils/file_transfer.c:  // in-flight and we can wait on all worker semaphores. In writes the last
../../utils/file_transfer.c:  if (operation->direction == IREE_HAL_TRANSFER_READ_FILE_TO_BUFFER) {
../../utils/file_transfer.c:    wait_semaphore_list.count = operation->worker_count;
../../utils/file_transfer.c:    for (iree_host_size_t i = 0; i < operation->worker_count; ++i) {
../../utils/file_transfer.c:      iree_hal_transfer_worker_t* worker = &operation->workers[i];
../../utils/file_transfer.c:      wait_semaphore_list.semaphores[i] = worker->semaphore;
../../utils/file_transfer.c:      wait_semaphore_list.payload_values[i] = worker->pending_timepoint;
../../utils/file_transfer.c:      operation->signal_semaphore_list;
../../utils/file_transfer.c:  if (!iree_status_is_ok(operation->error_status)) {
../../utils/file_transfer.c:  // be scheduled after any copies that may be in-flight (say worker 4 failed
../../utils/file_transfer.c:  // on a chunk but workers 0-3 succeeded).
../../utils/file_transfer.c:      operation->device, operation->queue_affinity, wait_semaphore_list,
../../utils/file_transfer.c:      signal_semaphore_list, operation->staging_buffer,
../../utils/file_transfer.c:// The first non-OK |status| provided will be set as a stick error on the
../../utils/file_transfer.c:  IREE_TRACE_ZONE_APPEND_VALUE_I64(z0, (int64_t)operation->trace_id);
../../utils/file_transfer.c:  IREE_TRACE_ZONE_APPEND_VALUE_I64(z0, (int64_t)worker->trace_id);
../../utils/file_transfer.c:  if (iree_status_is_ok(operation->error_status) &&
../../utils/file_transfer.c:    operation->error_status = status;
../../utils/file_transfer.c:      (iree_host_size_t)(worker - operation->workers);
../../utils/file_transfer.c:  operation->live_workers &= ~(1ull << worker_index);
../../utils/file_transfer.c:  if (operation->live_workers > 0) {
../../utils/file_transfer.c:    // Other workers are still live - this is just one worker exiting by not
../../utils/file_transfer.c:  // Free the operation - the dealloca (and maybe even some copies) may still be
../../utils/file_transfer.c:  // in-flight but all on the device side and not using any resources on the
../../utils/file_transfer.c:  iree_hal_transfer_operation_t* operation = worker->operation;
../../utils/file_transfer.c:  IREE_TRACE_ZONE_APPEND_VALUE_I64(z0, (int64_t)operation->trace_id);
../../utils/file_transfer.c:  IREE_TRACE_ZONE_APPEND_VALUE_I64(z0, (int64_t)worker->trace_id);
../../utils/file_transfer.c:      !iree_status_is_ok(operation->error_status)) {
../../utils/file_transfer.c:  // Early-exit if we're out of chunks to process.
../../utils/file_transfer.c:  if (operation->remaining_chunks == 0) {
../../utils/file_transfer.c:  --operation->remaining_chunks;
../../utils/file_transfer.c:  iree_device_size_t transfer_offset = operation->transfer_head;
../../utils/file_transfer.c:      operation->length - transfer_offset, worker->staging_buffer_length);
../../utils/file_transfer.c:  operation->transfer_head += transfer_length;
../../utils/file_transfer.c:  uint64_t wait_timepoint = worker->pending_timepoint;
../../utils/file_transfer.c:      .semaphores = &worker->semaphore,
../../utils/file_transfer.c:  uint64_t signal_timepoint = ++worker->pending_timepoint;
../../utils/file_transfer.c:      .semaphores = &worker->semaphore,
../../utils/file_transfer.c:  worker->pending_transfer_offset = transfer_offset;
../../utils/file_transfer.c:  worker->pending_transfer_length = transfer_length;
../../utils/file_transfer.c:      operation->file, operation->file_offset + worker->pending_transfer_offset,
../../utils/file_transfer.c:      operation->staging_buffer, worker->staging_buffer_offset,
../../utils/file_transfer.c:      worker->pending_transfer_length);
../../utils/file_transfer.c:        operation->device, operation->queue_affinity, wait_semaphore_list,
../../utils/file_transfer.c:        signal_semaphore_list, operation->staging_buffer,
../../utils/file_transfer.c:        worker->staging_buffer_offset, operation->buffer,
../../utils/file_transfer.c:        operation->buffer_offset + transfer_offset, transfer_length,
../../utils/file_transfer.c:    if (iree_hal_transfer_worker_live_count(operation->live_workers) >
../../utils/file_transfer.c:        operation->remaining_chunks) {
../../utils/file_transfer.c:          iree_hal_semaphore_await(worker->semaphore,
../../utils/file_transfer.c:                                   worker->pending_timepoint),
../../utils/file_transfer.c:  IREE_TRACE_ZONE_APPEND_VALUE_I64(z0, (int64_t)operation->trace_id);
../../utils/file_transfer.c:  IREE_ASSERT(operation->direction == IREE_HAL_TRANSFER_READ_FILE_TO_BUFFER);
../../utils/file_transfer.c:      .queue_affinity = operation->queue_affinity,
../../utils/file_transfer.c:  // When it completes we'll do the first host->device copy via mapping.
../../utils/file_transfer.c:      .count = operation->worker_count,
../../utils/file_transfer.c:          iree_alloca(sizeof(iree_hal_semaphore_t*) * operation->worker_count),
../../utils/file_transfer.c:      .payload_values = iree_alloca(sizeof(uint64_t) * operation->worker_count),
../../utils/file_transfer.c:  for (iree_host_size_t i = 0; i < operation->worker_count; ++i) {
../../utils/file_transfer.c:    iree_hal_transfer_worker_t* worker = &operation->workers[i];
../../utils/file_transfer.c:    alloca_semaphore_list.semaphores[i] = worker->semaphore;
../../utils/file_transfer.c:    alloca_semaphore_list.payload_values[i] = ++worker->pending_timepoint;
../../utils/file_transfer.c:              operation->device, operation->queue_affinity, wait_semaphore_list,
../../utils/file_transfer.c:              staging_buffer_params, operation->staging_buffer_size,
../../utils/file_transfer.c:              IREE_HAL_ALLOCA_FLAG_NONE, &operation->staging_buffer));
../../utils/file_transfer.c:  // We'll wait on each and start the worker-specific coroutines.
../../utils/file_transfer.c:       worker_index < operation->worker_count; ++worker_index) {
../../utils/file_transfer.c:    iree_hal_transfer_worker_t* worker = &operation->workers[worker_index];
../../utils/file_transfer.c:    operation->live_workers |= 1ull << worker_index;
../../utils/file_transfer.c:        iree_hal_semaphore_await(worker->semaphore, worker->pending_timepoint),
../../utils/file_transfer.c:      operation->live_workers &= ~(1ull << worker_index);
../../utils/file_transfer.c:    if (operation->remaining_chunks == 0) break;
../../utils/file_transfer.c:    operation->error_status = status;
../../utils/file_transfer.c:  IREE_TRACE_ZONE_APPEND_VALUE_I64(z0, (int64_t)operation->trace_id);
../../utils/file_transfer.c:  IREE_TRACE_ZONE_APPEND_VALUE_I64(z0, (int64_t)worker->trace_id);
../../utils/file_transfer.c:  if (!iree_status_is_ok(operation->error_status)) {
../../utils/file_transfer.c:  IREE_ASSERT(operation->remaining_chunks > 0,
../../utils/file_transfer.c:  --operation->remaining_chunks;
../../utils/file_transfer.c:  iree_device_size_t transfer_offset = operation->transfer_head;
../../utils/file_transfer.c:      operation->length - transfer_offset, worker->staging_buffer_length);
../../utils/file_transfer.c:  operation->transfer_head += transfer_length;
../../utils/file_transfer.c:      .semaphores = &worker->semaphore,
../../utils/file_transfer.c:      .payload_values = &worker->pending_timepoint,
../../utils/file_transfer.c:  ++worker->pending_timepoint;
../../utils/file_transfer.c:      .semaphores = &worker->semaphore,
../../utils/file_transfer.c:      .payload_values = &worker->pending_timepoint,
../../utils/file_transfer.c:  worker->pending_transfer_offset = transfer_offset;
../../utils/file_transfer.c:  worker->pending_transfer_length = transfer_length;
../../utils/file_transfer.c:      operation->device, operation->queue_affinity, wait_semaphore_list,
../../utils/file_transfer.c:      signal_semaphore_list, operation->buffer,
../../utils/file_transfer.c:      operation->buffer_offset + transfer_offset, operation->staging_buffer,
../../utils/file_transfer.c:      worker->staging_buffer_offset, transfer_length, IREE_HAL_COPY_FLAG_NONE);
../../utils/file_transfer.c:        iree_hal_semaphore_await(worker->semaphore, worker->pending_timepoint),
../../utils/file_transfer.c:  iree_hal_transfer_operation_t* operation = worker->operation;
../../utils/file_transfer.c:  IREE_TRACE_ZONE_APPEND_VALUE_I64(z0, (int64_t)operation->trace_id);
../../utils/file_transfer.c:  IREE_TRACE_ZONE_APPEND_VALUE_I64(z0, (int64_t)worker->trace_id);
../../utils/file_transfer.c:      !iree_status_is_ok(operation->error_status)) {
../../utils/file_transfer.c:      operation->file, operation->file_offset + worker->pending_transfer_offset,
../../utils/file_transfer.c:      operation->staging_buffer, worker->staging_buffer_offset,
../../utils/file_transfer.c:      worker->pending_transfer_length);
../../utils/file_transfer.c:  if (iree_status_is_ok(status) && operation->remaining_chunks == 0) {
../../utils/file_transfer.c:  IREE_TRACE_ZONE_APPEND_VALUE_I64(z0, (int64_t)operation->trace_id);
../../utils/file_transfer.c:  IREE_ASSERT(operation->direction == IREE_HAL_TRANSFER_WRITE_BUFFER_TO_FILE);
../../utils/file_transfer.c:      .queue_affinity = operation->queue_affinity,
../../utils/file_transfer.c:      .count = operation->worker_count,
../../utils/file_transfer.c:          iree_alloca(sizeof(iree_hal_semaphore_t*) * operation->worker_count),
../../utils/file_transfer.c:      .payload_values = iree_alloca(sizeof(uint64_t) * operation->worker_count),
../../utils/file_transfer.c:  for (iree_host_size_t i = 0; i < operation->worker_count; ++i) {
../../utils/file_transfer.c:    iree_hal_transfer_worker_t* worker = &operation->workers[i];
../../utils/file_transfer.c:    alloca_semaphore_list.semaphores[i] = worker->semaphore;
../../utils/file_transfer.c:    alloca_semaphore_list.payload_values[i] = ++worker->pending_timepoint;
../../utils/file_transfer.c:              operation->device, operation->queue_affinity, wait_semaphore_list,
../../utils/file_transfer.c:              staging_buffer_params, operation->staging_buffer_size,
../../utils/file_transfer.c:              IREE_HAL_ALLOCA_FLAG_NONE, &operation->staging_buffer));
../../utils/file_transfer.c:  // We'll wait on each and start the worker-specific coroutines.
../../utils/file_transfer.c:       worker_index < operation->worker_count; ++worker_index) {
../../utils/file_transfer.c:    iree_hal_transfer_worker_t* worker = &operation->workers[worker_index];
../../utils/file_transfer.c:    operation->live_workers |= 1ull << worker_index;
../../utils/file_transfer.c:    if (operation->remaining_chunks == 0) break;
../../utils/file_transfer.c:    operation->error_status = status;
../../utils/file_transfer.c://===----------------------------------------------------------------------===//
../../utils/file_transfer.c://===----------------------------------------------------------------------===//
../../utils/file_transfer.c:  // This host-side transfer utility requires synchronous I/O.
../../utils/file_transfer.c:  // This host-side transfer utility requires synchronous I/O.
../../local/loaders/accel_module_loader.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/loaders/accel_module_loader.c://===----------------------------------------------------------------------===//
../../local/loaders/accel_module_loader.c:// Built-in executable helpers
../../local/loaders/accel_module_loader.c://===----------------------------------------------------------------------===//
../../local/loaders/accel_module_loader.c:                              "executable has no executable-level constants "
../../local/loaders/accel_module_loader.c:                            "executable requires executable-level constants "
../../local/loaders/accel_module_loader.c:  // Wrap the constant memory in an on-stack buffer.
../../local/loaders/accel_module_loader.c:  // lifetime - this will abort if it's not.
../../local/loaders/accel_module_loader.c://===----------------------------------------------------------------------===//
../../local/loaders/accel_module_loader.c://===----------------------------------------------------------------------===//
../../local/loaders/accel_module_loader.c:  // per-call state.
../../local/loaders/accel_module_loader.c:  // Set executable-level constants.
../../local/loaders/accel_module_loader.c:        context, bytecode_module, executable_params->constant_count,
../../local/loaders/accel_module_loader.c:        executable_params->constants, host_allocator);
../../local/loaders/accel_module_loader.c:    out_state->context = context;
../../local/loaders/accel_module_loader.c:    out_state->vmvx_module_state = vmvx_module_state;
../../local/loaders/accel_module_loader.c:  if (state->context) {
../../local/loaders/accel_module_loader.c:    iree_vm_context_release(state->context);
../../local/loaders/accel_module_loader.c:    state->context = NULL;
../../local/loaders/accel_module_loader.c://===----------------------------------------------------------------------===//
../../local/loaders/accel_module_loader.c://===----------------------------------------------------------------------===//
../../local/loaders/accel_module_loader.c:  // Preallocated per-worker states that are used to emulate TLS.
../../local/loaders/accel_module_loader.c:      iree_host_align(entry_count * sizeof(*executable->entry_fn_ordinals), 8);
../../local/loaders/accel_module_loader.c:      entry_count * sizeof(*executable->base.dispatch_attrs), 8);
../../local/loaders/accel_module_loader.c:      iree_host_align(worker_capacity * sizeof(*executable->worker_states), 8);
../../local/loaders/accel_module_loader.c:                                         host_allocator, &executable->base);
../../local/loaders/accel_module_loader.c:    executable->base.dispatch_attrs = dispatch_attrs;
../../local/loaders/accel_module_loader.c:    executable->worker_capacity = worker_capacity;
../../local/loaders/accel_module_loader.c:    executable->worker_states = (iree_hal_accel_worker_state_t*)ptr;
../../local/loaders/accel_module_loader.c:    executable->bytecode_module = bytecode_module;
../../local/loaders/accel_module_loader.c:    executable->entry_fn_count = entry_count;
../../local/loaders/accel_module_loader.c:    for (iree_host_size_t i = 0; i < executable->entry_fn_count; ++i) {
../../local/loaders/accel_module_loader.c:      executable->entry_fn_ordinals[i] = entry_fn.ordinal;
../../local/loaders/accel_module_loader.c:    // reference from the module. Module-level reflection attrs would help.
../../local/loaders/accel_module_loader.c:    for (iree_host_size_t i = 0; i < executable->entry_fn_count; ++i) {
../../local/loaders/accel_module_loader.c:          .module = executable->bytecode_module,
../../local/loaders/accel_module_loader.c:          .ordinal = executable->entry_fn_ordinals[i],
../../local/loaders/accel_module_loader.c:          host_allocator, &executable->worker_states[i]);
../../local/loaders/accel_module_loader.c:  iree_allocator_t host_allocator = executable->base.host_allocator;
../../local/loaders/accel_module_loader.c:  for (iree_host_size_t i = 0; i < executable->worker_capacity; ++i) {
../../local/loaders/accel_module_loader.c:    iree_hal_accel_worker_state_deinitialize(&executable->worker_states[i]);
../../local/loaders/accel_module_loader.c:  if (IREE_UNLIKELY(ordinal >= executable->entry_fn_count)) {
../../local/loaders/accel_module_loader.c:      .module = executable->bytecode_module,
../../local/loaders/accel_module_loader.c:      .ordinal = executable->entry_fn_ordinals[ordinal],
../../local/loaders/accel_module_loader.c:  // Fetch worker-local state. This caller is the only one able to access it so
../../local/loaders/accel_module_loader.c:  if (IREE_UNLIKELY(worker_id >= executable->worker_capacity)) {
../../local/loaders/accel_module_loader.c:      &executable->worker_states[worker_id];
../../local/loaders/accel_module_loader.c:      worker_state->vmvx_module_state, workgroup_state->processor_id);
../../local/loaders/accel_module_loader.c:  // On-stack interface local to this invocation.
../../local/loaders/accel_module_loader.c:      iree_vm_list_storage_size(&buffer_type, dispatch_state->binding_count);
../../local/loaders/accel_module_loader.c:      &buffer_type, dispatch_state->binding_count, &binding_list));
../../local/loaders/accel_module_loader.c:  // Map bindings into on-stack ACCEL buffers.
../../local/loaders/accel_module_loader.c:      dispatch_state->binding_count * sizeof(iree_vm_buffer_t));
../../local/loaders/accel_module_loader.c:  for (iree_host_size_t i = 0; i < dispatch_state->binding_count; ++i) {
../../local/loaders/accel_module_loader.c:        iree_make_byte_span(dispatch_state->binding_ptrs[i],
../../local/loaders/accel_module_loader.c:                            dispatch_state->binding_lengths[i]),
../../local/loaders/accel_module_loader.c:      iree_make_byte_span(workgroup_state->local_memory,
../../local/loaders/accel_module_loader.c:                          workgroup_state->local_memory_size),
../../local/loaders/accel_module_loader.c:      iree_make_byte_span((void*)dispatch_state->constants,
../../local/loaders/accel_module_loader.c:                          sizeof(uint32_t) * dispatch_state->constant_count),
../../local/loaders/accel_module_loader.c:  // NOTE: this level of the VM ABI is supported - but may change in the future.
../../local/loaders/accel_module_loader.c:      .workgroup_id_x = workgroup_state->workgroup_id_x,
../../local/loaders/accel_module_loader.c:      .workgroup_id_y = workgroup_state->workgroup_id_y,
../../local/loaders/accel_module_loader.c:      .workgroup_id_z = workgroup_state->workgroup_id_z,
../../local/loaders/accel_module_loader.c:      .workgroup_size_x = dispatch_state->workgroup_size_x,
../../local/loaders/accel_module_loader.c:      .workgroup_size_y = dispatch_state->workgroup_size_y,
../../local/loaders/accel_module_loader.c:      .workgroup_size_z = dispatch_state->workgroup_size_z,
../../local/loaders/accel_module_loader.c:      .workgroup_count_x = dispatch_state->workgroup_count_x,
../../local/loaders/accel_module_loader.c:      .workgroup_count_y = dispatch_state->workgroup_count_y,
../../local/loaders/accel_module_loader.c:      .workgroup_count_z = dispatch_state->workgroup_count_z,
../../local/loaders/accel_module_loader.c:      iree_vm_context_state_resolver(worker_state->context),
../../local/loaders/accel_module_loader.c:      executable->base.host_allocator);
../../local/loaders/accel_module_loader.c:  status = entry_fn.module->begin_call(entry_fn.module->self, stack, call);
../../local/loaders/accel_module_loader.c:  for (iree_host_size_t i = 0; i < dispatch_state->binding_count; ++i) {
../../local/loaders/accel_module_loader.c://===----------------------------------------------------------------------===//
../../local/loaders/accel_module_loader.c://===----------------------------------------------------------------------===//
../../local/loaders/accel_module_loader.c:          common_module_count * sizeof(executable_loader->common_modules[0]),
../../local/loaders/accel_module_loader.c:        iree_hal_executable_import_provider_null(), &executable_loader->base);
../../local/loaders/accel_module_loader.c:    executable_loader->host_allocator = host_allocator;
../../local/loaders/accel_module_loader.c:    executable_loader->instance = instance;
../../local/loaders/accel_module_loader.c:    iree_vm_instance_retain(executable_loader->instance);
../../local/loaders/accel_module_loader.c:    // We prepend the accel_module to any user-provided modules.
../../local/loaders/accel_module_loader.c:    executable_loader->common_module_count = common_module_count; 
../../local/loaders/accel_module_loader.c:    executable_loader->common_modules[IREE_VMVX_MODULE_INDEX] = vmvx_module;
../../local/loaders/accel_module_loader.c:      executable_loader->common_modules[1 + i] = user_modules[i];
../../local/loaders/accel_module_loader.c:  iree_allocator_t host_allocator = executable_loader->host_allocator;
../../local/loaders/accel_module_loader.c:  for (iree_host_size_t i = 0; i < executable_loader->common_module_count;
../../local/loaders/accel_module_loader.c:    iree_vm_module_release(executable_loader->common_modules[i]);
../../local/loaders/accel_module_loader.c:  iree_vm_instance_release(executable_loader->instance);
../../local/loaders/accel_module_loader.c:                                iree_make_cstring_view("accel-bytecode-fb"));
../../local/loaders/accel_module_loader.c:      executable_params->executable_data;
../../local/loaders/accel_module_loader.c:  if (iree_all_bits_set(executable_params->caching_mode,
../../local/loaders/accel_module_loader.c:    // Zero-copy route.
../../local/loaders/accel_module_loader.c:    bytecode_module_allocator = executable_loader->host_allocator;
../../local/loaders/accel_module_loader.c:        z0, iree_allocator_clone(executable_loader->host_allocator,
../../local/loaders/accel_module_loader.c:                                 executable_params->executable_data,
../../local/loaders/accel_module_loader.c:  // Load the user-provided bytecode module. We pass ownership of the data (if
../../local/loaders/accel_module_loader.c:      executable_loader->instance, executable_params->executable_data,
../../local/loaders/accel_module_loader.c:      bytecode_module_allocator, executable_loader->host_allocator,
../../local/loaders/accel_module_loader.c:        executable_loader->common_module_count + 1;
../../local/loaders/accel_module_loader.c:    memcpy(context_modules, executable_loader->common_modules,
../../local/loaders/accel_module_loader.c:           executable_loader->common_module_count *
../../local/loaders/accel_module_loader.c:               sizeof(executable_loader->common_modules[0]));
../../local/loaders/accel_module_loader.c:    context_modules[context_module_count - 1] = bytecode_module;
../../local/loaders/accel_module_loader.c:        executable_loader->instance, context_module_count, context_modules,
../../local/loaders/accel_module_loader.c:        executable_loader->host_allocator, out_executable);
../../utils/fd_file.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/fd_file.c://===----------------------------------------------------------------------===//
../../utils/fd_file.c://===----------------------------------------------------------------------===//
../../utils/fd_file.c:  if (_fstat64(fd, &buffer) == -1) {
../../utils/fd_file.c:  if (fstat(fd, &buffer) == -1) {
../../utils/fd_file.c://===----------------------------------------------------------------------===//
../../utils/fd_file.c://===----------------------------------------------------------------------===//
../../utils/fd_file.c:                            "support for creating non-fd files not supported");
../../utils/fd_file.c:  iree_hal_resource_initialize(&iree_hal_fd_file_vtable, &file->resource);
../../utils/fd_file.c:  file->host_allocator = host_allocator;
../../utils/fd_file.c:  file->access = access;
../../utils/fd_file.c:  file->handle = handle;
../../utils/fd_file.c:  iree_io_file_handle_retain(file->handle);
../../utils/fd_file.c:  file->fd = fd;
../../utils/fd_file.c:  file->length = length;
../../utils/fd_file.c:  iree_allocator_t host_allocator = file->host_allocator;
../../utils/fd_file.c:  iree_io_file_handle_release(file->handle);
../../utils/fd_file.c:  return file->access;
../../utils/fd_file.c:  return file->length;
../../utils/fd_file.c:    status = iree_hal_platform_fd_pread(file->fd, buffer_ptr, bytes_requested,
../../utils/fd_file.c:    bytes_remaining -= bytes_read;
../../utils/fd_file.c:    status = iree_hal_platform_fd_pwrite(file->fd, buffer_ptr, bytes_requested,
../../utils/fd_file.c:    bytes_remaining -= bytes_written;
../../local/loaders/system_library_loader.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/loaders/system_library_loader.c://===----------------------------------------------------------------------===//
../../local/loaders/system_library_loader.c://===----------------------------------------------------------------------===//
../../local/loaders/system_library_loader.c:                              executable_data.data_length -
../../local/loaders/system_library_loader.c:  static_assert(sizeof(IREE_HAL_SYSTEM_EXECUTABLE_FOOTER_MAGIC) - /*NUL*/ 1 ==
../../local/loaders/system_library_loader.c:                    sizeof(footer->magic),
../../local/loaders/system_library_loader.c:  if (memcmp(footer->magic, IREE_HAL_SYSTEM_EXECUTABLE_FOOTER_MAGIC,
../../local/loaders/system_library_loader.c:             sizeof(footer->magic)) != 0) {
../../local/loaders/system_library_loader.c://===----------------------------------------------------------------------===//
../../local/loaders/system_library_loader.c://===----------------------------------------------------------------------===//
../../local/loaders/system_library_loader.c:        executable_data.data_length - sizeof(*footer);
../../local/loaders/system_library_loader.c:    if (footer->library_size > data_length ||
../../local/loaders/system_library_loader.c:        footer->debug_offset + footer->debug_size > data_length) {
../../local/loaders/system_library_loader.c:        iree_make_const_byte_span(executable_data.data, footer->library_size);
../../local/loaders/system_library_loader.c:        executable_data.data + footer->debug_offset, footer->debug_size);
../../local/loaders/system_library_loader.c:      IREE_DYNAMIC_LIBRARY_FLAG_NONE, host_allocator, &executable->handle));
../../local/loaders/system_library_loader.c:        executable->handle, debug_data));
../../local/loaders/system_library_loader.c:      executable->handle, IREE_HAL_EXECUTABLE_LIBRARY_EXPORT_NAME,
../../local/loaders/system_library_loader.c:  executable->library.header =
../../local/loaders/system_library_loader.c:               &executable->base.environment);
../../local/loaders/system_library_loader.c:  if (!executable->library.header) {
../../local/loaders/system_library_loader.c:      *executable->library.header;
../../local/loaders/system_library_loader.c:  switch (header->sanitizer) {
../../local/loaders/system_library_loader.c:          "runtime is not compiled with it enabled; add -fsanitize=address to "
../../local/loaders/system_library_loader.c:          "runtime is not compiled with it enabled; add -fsanitize=thread to "
../../local/loaders/system_library_loader.c:          (uint32_t)header->sanitizer);
../../local/loaders/system_library_loader.c:  executable->identifier = iree_make_cstring_view(header->name);
../../local/loaders/system_library_loader.c:  executable->base.dispatch_attrs = executable->library.v0->exports.attrs;
../../local/loaders/system_library_loader.c:  IREE_ASSERT_ARGUMENT(executable_params->executable_data.data &&
../../local/loaders/system_library_loader.c:                       executable_params->executable_data.data_length);
../../local/loaders/system_library_loader.c:  IREE_ASSERT_ARGUMENT(!executable_params->constant_count ||
../../local/loaders/system_library_loader.c:                       executable_params->constants);
../../local/loaders/system_library_loader.c:      executable_params->constant_count * sizeof(*executable_params->constants);
../../local/loaders/system_library_loader.c:                                         host_allocator, &executable->base);
../../local/loaders/system_library_loader.c:  if (iree_status_is_ok(status) && executable_params->constant_count > 0) {
../../local/loaders/system_library_loader.c:    memcpy(target_constants, executable_params->constants,
../../local/loaders/system_library_loader.c:           executable_params->constant_count *
../../local/loaders/system_library_loader.c:               sizeof(*executable_params->constants));
../../local/loaders/system_library_loader.c:    executable->base.environment.constants = target_constants;
../../local/loaders/system_library_loader.c:        executable, executable_params->executable_data, host_allocator);
../../local/loaders/system_library_loader.c:        &executable->base.environment, import_provider,
../../local/loaders/system_library_loader.c:        &executable->library.v0->imports,
../../local/loaders/system_library_loader.c:                                                executable->library.v0);
../../local/loaders/system_library_loader.c:    iree_hal_executable_library_publish_source_files(executable->library.v0);
../../local/loaders/system_library_loader.c:  iree_allocator_t host_allocator = executable->base.host_allocator;
../../local/loaders/system_library_loader.c:  iree_dynamic_library_release(executable->handle);
../../local/loaders/system_library_loader.c:      &executable->base.environment, host_allocator);
../../local/loaders/system_library_loader.c:  const iree_hal_executable_library_v0_t* library = executable->library.v0;
../../local/loaders/system_library_loader.c:  if (IREE_UNLIKELY(ordinal >= library->exports.count)) {
../../local/loaders/system_library_loader.c:  IREE_HAL_EXECUTABLE_LIBRARY_CALL_TRACE_ZONE_BEGIN(z0, executable->identifier,
../../local/loaders/system_library_loader.c:  IREE_HAL_EXECUTABLE_LIBRARY_CALL_HOOK_BEGIN(executable->identifier, library,
../../local/loaders/system_library_loader.c:  int ret = library->exports.ptrs[ordinal](&base_executable->environment,
../../local/loaders/system_library_loader.c:  IREE_HAL_EXECUTABLE_LIBRARY_CALL_HOOK_END(executable->identifier, library,
../../local/loaders/system_library_loader.c://===----------------------------------------------------------------------===//
../../local/loaders/system_library_loader.c://===----------------------------------------------------------------------===//
../../local/loaders/system_library_loader.c:        &executable_loader->base);
../../local/loaders/system_library_loader.c:    executable_loader->host_allocator = host_allocator;
../../local/loaders/system_library_loader.c:    executable_loader->plugin_manager = plugin_manager;
../../local/loaders/system_library_loader.c:        executable_loader->plugin_manager);
../../local/loaders/system_library_loader.c:  iree_allocator_t host_allocator = executable_loader->host_allocator;
../../local/loaders/system_library_loader.c:  iree_hal_executable_plugin_manager_release(executable_loader->plugin_manager);
../../local/loaders/system_library_loader.c:      iree_make_cstring_view("system-" IREE_PLATFORM_DYLIB_TYPE "-" IREE_ARCH));
../../local/loaders/system_library_loader.c:              executable_params, base_executable_loader->import_provider,
../../local/loaders/system_library_loader.c:              executable_loader->host_allocator, out_executable));
../../local/CMakeLists.txt:# CMake-only content.                                                          #
../../local/loaders/registration/init.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/loaders/registration/CMakeLists.txt:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/loaders/registration/BUILD.bazel:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/loaders/registration/BUILD.bazel:    "embedded-elf",
../../local/loaders/registration/BUILD.bazel:    "system-library",
../../local/loaders/registration/BUILD.bazel:    "vmvx-module",
../../local/loaders/registration/BUILD.bazel:        "embedded-elf",
../../local/loaders/registration/BUILD.bazel:        "system-library",
../../local/loaders/registration/BUILD.bazel:        "vmvx-module",
../../local/loaders/registration/BUILD.bazel:        ":embedded-elf_enabled": ["//runtime/src/iree/hal/local/loaders:embedded_elf_loader"],
../../local/loaders/registration/BUILD.bazel:        ":system-library_enabled": ["//runtime/src/iree/hal/local/loaders:system_library_loader"],
../../local/loaders/registration/BUILD.bazel:        ":vmvx-module_enabled": ["//runtime/src/iree/hal/local/loaders:vmvx_module_loader"],
../../local/loaders/registration/init.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/loaders/registration/init.c:// - system-library: used when embedded is not desired (TSAN/debugging/etc).
../../local/loaders/registration/init.c:// - embedded-elf: default codegen portable ELF output format.
../../local/loaders/registration/init.c:// - vmvx-module: reference fallback path using the IREE bytecode VM.
../../local/loaders/registration/init.c:  if (iree_string_view_starts_with(name, IREE_SV("embedded-elf"))) {
../../local/loaders/registration/init.c:  if (iree_string_view_starts_with(name, IREE_SV("system-library"))) {
../../local/loaders/registration/init.c:  if (iree_string_view_starts_with(name, IREE_SV("vmvx-module"))) {
../../local/loaders/registration/init.c:  if (iree_string_view_equal(name, IREE_SV("accel-module"))) {
../../local/loaders/accel_module_loader.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/loaders/accel_module_loader.h:// in many contexts. Modules must be thread-safe and ideally have no thread
../../local/loaders/accel_module_loader.h:// Compiled accel programs that use the user-provided modules are encouraged to
../../local/loaders/accel_module_loader.h:// `arm-sve` modules, etc).
../../local/loaders/system_library_loader.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/loaders/system_library_loader.h:// Creates an executable loader that can load files from platform-supported
../../local/loaders/system_library_loader.h:// This uses the legacy "dylib"-style format that will be deleted soon and is
../../local/loaders/system_library_loader.h:// iree_hal_executable_library_t-compatible files.
../../local/loaders/CMakeLists.txt:# CMake-only content.                                                          #
../../local/loaders/static_library_loader.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/loaders/static_library_loader.h:// ensure that the IREE compiler-produced static library version is one that the
../../local/loaders/static_library_loader.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/loaders/static_library_loader.c://===----------------------------------------------------------------------===//
../../local/loaders/static_library_loader.c://===----------------------------------------------------------------------===//
../../local/loaders/static_library_loader.c:  IREE_ASSERT_ARGUMENT(!executable_params->constant_count ||
../../local/loaders/static_library_loader.c:                       executable_params->constants);
../../local/loaders/static_library_loader.c:      executable_params->constant_count * sizeof(*executable_params->constants);
../../local/loaders/static_library_loader.c:                                         host_allocator, &executable->base);
../../local/loaders/static_library_loader.c:    executable->library.header = library_header;
../../local/loaders/static_library_loader.c:    executable->identifier = iree_make_cstring_view((*library_header)->name);
../../local/loaders/static_library_loader.c:    executable->base.dispatch_attrs = executable->library.v0->exports.attrs;
../../local/loaders/static_library_loader.c:  if (iree_status_is_ok(status) && executable_params->constant_count > 0) {
../../local/loaders/static_library_loader.c:    memcpy(target_constants, executable_params->constants,
../../local/loaders/static_library_loader.c:           executable_params->constant_count *
../../local/loaders/static_library_loader.c:               sizeof(*executable_params->constants));
../../local/loaders/static_library_loader.c:    executable->base.environment.constants = target_constants;
../../local/loaders/static_library_loader.c:        &executable->base.environment, import_provider,
../../local/loaders/static_library_loader.c:        &executable->library.v0->imports,
../../local/loaders/static_library_loader.c:                                                executable->library.v0);
../../local/loaders/static_library_loader.c:    iree_hal_executable_library_publish_source_files(executable->library.v0);
../../local/loaders/static_library_loader.c:  iree_allocator_t host_allocator = executable->base.host_allocator;
../../local/loaders/static_library_loader.c:      &executable->base.environment, host_allocator);
../../local/loaders/static_library_loader.c:  const iree_hal_executable_library_v0_t* library = executable->library.v0;
../../local/loaders/static_library_loader.c:  if (IREE_UNLIKELY(ordinal >= library->exports.count)) {
../../local/loaders/static_library_loader.c:  IREE_HAL_EXECUTABLE_LIBRARY_CALL_TRACE_ZONE_BEGIN(z0, executable->identifier,
../../local/loaders/static_library_loader.c:  IREE_HAL_EXECUTABLE_LIBRARY_CALL_HOOK_BEGIN(executable->identifier, library,
../../local/loaders/static_library_loader.c:  int ret = library->exports.ptrs[ordinal](&base_executable->environment,
../../local/loaders/static_library_loader.c:  IREE_HAL_EXECUTABLE_LIBRARY_CALL_HOOK_END(executable->identifier, library,
../../local/loaders/static_library_loader.c://===----------------------------------------------------------------------===//
../../local/loaders/static_library_loader.c://===----------------------------------------------------------------------===//
../../local/loaders/static_library_loader.c:      sizeof(executable_loader->libraries[0]) * library_count;
../../local/loaders/static_library_loader.c:        &executable_loader->base);
../../local/loaders/static_library_loader.c:    executable_loader->host_allocator = host_allocator;
../../local/loaders/static_library_loader.c:    executable_loader->library_count = library_count;
../../local/loaders/static_library_loader.c:      IREE_TRACE_ZONE_APPEND_TEXT(z0, header->name);
../../local/loaders/static_library_loader.c:      if (header->version > IREE_HAL_EXECUTABLE_LIBRARY_VERSION_LATEST) {
../../local/loaders/static_library_loader.c:            header->version, IREE_HAL_EXECUTABLE_LIBRARY_VERSION_LATEST);
../../local/loaders/static_library_loader.c:      memcpy((void*)&executable_loader->libraries[i], &header_ptr,
../../local/loaders/static_library_loader.c:  iree_allocator_t host_allocator = executable_loader->host_allocator;
../../local/loaders/static_library_loader.c:      (const char*)executable_params->executable_data.data,
../../local/loaders/static_library_loader.c:      executable_params->executable_data.data_length);
../../local/loaders/static_library_loader.c:  // creation to perform a binary-search fairly easily, though, at the cost of
../../local/loaders/static_library_loader.c:  for (iree_host_size_t i = 0; i < executable_loader->library_count; ++i) {
../../local/loaders/static_library_loader.c:        *executable_loader->libraries[i];
../../local/loaders/static_library_loader.c:                               iree_make_cstring_view(header->name))) {
../../local/loaders/static_library_loader.c:          executable_params, executable_loader->libraries[i],
../../local/loaders/static_library_loader.c:          base_executable_loader->import_provider,
../../local/loaders/static_library_loader.c:          executable_loader->host_allocator, out_executable);
../../utils/resource_set.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/resource_set.c:  return iree_min((storage_size - sizeof(iree_hal_resource_set_chunk_t)) /
../../utils/resource_set.c:  IREE_ASSERT_LE(block_pool->usable_block_size, 64 * 1024,
../../utils/resource_set.c:  set->block_pool = block_pool;
../../utils/resource_set.c:  inlined_chunk->next_chunk = NULL;
../../utils/resource_set.c:  inlined_chunk->capacity = iree_hal_resource_set_chunk_capacity(
../../utils/resource_set.c:      block_pool->usable_block_size -
../../utils/resource_set.c:  inlined_chunk->count = 0;
../../utils/resource_set.c:  set->chunk_head = inlined_chunk;
../../utils/resource_set.c:  iree_hal_resource_set_chunk_t* chunk = set->chunk_head;
../../utils/resource_set.c:    iree_hal_resource_set_chunk_t* next_chunk = chunk->next_chunk;
../../utils/resource_set.c:    for (iree_host_size_t i = 0; i < chunk->count; ++i) {
../../utils/resource_set.c:      iree_hal_resource_release(chunk->resources[i]);
../../utils/resource_set.c:        set->block_pool,
../../utils/resource_set.c:    block->next = block_head;
../../utils/resource_set.c:  iree_arena_block_pool_t* block_pool = set->block_pool;
../../utils/resource_set.c:  iree_hal_resource_set_chunk_t* chunk = set->chunk_head;
../../utils/resource_set.c:        set->block_pool->usable_block_size);
../../utils/resource_set.c:    chunk = chunk->next_chunk;
../../utils/resource_set.c:  iree_hal_resource_set_chunk_t* chunk = set->chunk_head;
../../utils/resource_set.c:    iree_hal_resource_set_chunk_t* next_chunk = chunk->next_chunk;
../../utils/resource_set.c:        chunk, set->block_pool->usable_block_size -
../../utils/resource_set.c:  iree_hal_resource_set_chunk_t* chunk = set->chunk_head;
../../utils/resource_set.c:  if (IREE_UNLIKELY(chunk->count + 1 > chunk->capacity)) {
../../utils/resource_set.c:    // Ran out of room in the current chunk - acquire a new one and link it into
../../utils/resource_set.c:        iree_arena_block_pool_acquire(set->block_pool, &block, (void**)&chunk));
../../utils/resource_set.c:    chunk->next_chunk = set->chunk_head;
../../utils/resource_set.c:    set->chunk_head = chunk;
../../utils/resource_set.c:    chunk->capacity = iree_hal_resource_set_chunk_capacity(
../../utils/resource_set.c:        set->block_pool->usable_block_size);
../../utils/resource_set.c:    chunk->count = 0;
../../utils/resource_set.c:  chunk->resources[chunk->count++] = resource;
../../utils/resource_set.c:// resource will be retained in the main source-of-truth list.
../../utils/resource_set.c://   +----+----+----+----+
../../utils/resource_set.c://   +----+----+----+----+
../../utils/resource_set.c://       +----+----+----+----+
../../utils/resource_set.c://       +----+----+----+----+
../../utils/resource_set.c://       +----+----+----+----+
../../utils/resource_set.c://       +----+----+----+----+
../../utils/resource_set.c://   +----+----+----+----+
../../utils/resource_set.c://   +----+----+----+----+
../../utils/resource_set.c://     +----+----+----+----+
../../utils/resource_set.c://     +----+----+----+----+
../../utils/resource_set.c://     +----+----+----+----+
../../utils/resource_set.c://     +----+----+----+----+
../../utils/resource_set.c://   On a 32-bit system with uint32x4_t we only need 4 registers.
../../utils/resource_set.c://   On a 64-bit system with uint64x2_t we also only need 4 registers - though
../../utils/resource_set.c://    https://developer.arm.com/architectures/instruction-sets/intrinsics/vdupq_n_u32
../../utils/resource_set.c://    https://developer.arm.com/architectures/instruction-sets/intrinsics/vceqq_u32
../../utils/resource_set.c://    https://developer.arm.com/architectures/instruction-sets/intrinsics/vorrq_u32
../../utils/resource_set.c://    https://developer.arm.com/architectures/instruction-sets/intrinsics/vmaxvq_u32
../../utils/resource_set.c://    https://developer.arm.com/architectures/instruction-sets/intrinsics/vdupq_n_u64
../../utils/resource_set.c://    https://developer.arm.com/architectures/instruction-sets/intrinsics/vceqq_u64
../../utils/resource_set.c://    https://developer.arm.com/architectures/instruction-sets/intrinsics/vorrq_u64
../../utils/resource_set.c://    https://developer.arm.com/architectures/instruction-sets/intrinsics/vreinterpretq_u64_u32
../../utils/resource_set.c://    https://developer.arm.com/architectures/instruction-sets/intrinsics/vmaxvq_u32
../../utils/resource_set.c://    https://developer.arm.com/architectures/instruction-sets/intrinsics/vextq_u32
../../utils/resource_set.c://    https://developer.arm.com/architectures/instruction-sets/intrinsics/vextq_u64
../../utils/resource_set.c://   https://github.com/simd-everywhere/simde/blob/master/simde/arm/neon/ceq.h#L591
../../utils/resource_set.c:  for (iree_host_size_t i = 0; i < IREE_ARRAYSIZE(set->mru); ++i) {
../../utils/resource_set.c:    if (set->mru[i] != resource) continue;
../../utils/resource_set.c:    // Hit - keep the list sorted by most->least recently used.
../../utils/resource_set.c:      memmove(&set->mru[1], &set->mru[0], sizeof(set->mru[0]) * i);
../../utils/resource_set.c:      set->mru[0] = resource;
../../utils/resource_set.c:  // Miss - insert into the main list (slow path).
../../utils/resource_set.c:  // Note that we do this before updating the MRU in case allocation fails - we
../../utils/resource_set.c:  memmove(&set->mru[1], &set->mru[0],
../../utils/resource_set.c:          sizeof(set->mru[0]) * (IREE_ARRAYSIZE(set->mru) - 1));
../../utils/resource_set.c:  set->mru[0] = resource;
../../utils/deferred_command_buffer.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/deferred_command_buffer.c://===----------------------------------------------------------------------===//
../../utils/deferred_command_buffer.c://===----------------------------------------------------------------------===//
../../utils/deferred_command_buffer.c:// Header prefixed to all commands, forming a linked-list.
../../utils/deferred_command_buffer.c://===----------------------------------------------------------------------===//
../../utils/deferred_command_buffer.c://===----------------------------------------------------------------------===//
../../utils/deferred_command_buffer.c:// A singly-linked list of commands allocated from an arena.
../../utils/deferred_command_buffer.c:  // Will be reset as the command buffer is re-recorded.
../../utils/deferred_command_buffer.c:  iree_arena_initialize(block_pool, &out_cmd_list->arena);
../../utils/deferred_command_buffer.c:  out_cmd_list->head = NULL;
../../utils/deferred_command_buffer.c:  out_cmd_list->tail = NULL;
../../utils/deferred_command_buffer.c:  return cmd_list->head == NULL;
../../utils/deferred_command_buffer.c:  // adding more commands on this path and it would remove a round-trip through
../../utils/deferred_command_buffer.c:  iree_arena_reset(&cmd_list->arena);
../../utils/deferred_command_buffer.c:  cmd_list->head = NULL;
../../utils/deferred_command_buffer.c:  cmd_list->tail = NULL;
../../utils/deferred_command_buffer.c:      iree_arena_allocate(&cmd_list->arena, command_size, (void**)&header));
../../utils/deferred_command_buffer.c:  header->next = NULL;
../../utils/deferred_command_buffer.c:  header->type = command_type;
../../utils/deferred_command_buffer.c:  if (!cmd_list->head) {
../../utils/deferred_command_buffer.c:    cmd_list->head = header;
../../utils/deferred_command_buffer.c:  } else if (cmd_list->tail) {
../../utils/deferred_command_buffer.c:    cmd_list->tail->next = header;
../../utils/deferred_command_buffer.c:  cmd_list->tail = header;
../../utils/deferred_command_buffer.c:      iree_arena_allocate(&cmd_list->arena, data_length, &target_data));
../../utils/deferred_command_buffer.c://===----------------------------------------------------------------------===//
../../utils/deferred_command_buffer.c://===----------------------------------------------------------------------===//
../../utils/deferred_command_buffer.c:        &iree_hal_deferred_command_buffer_vtable, &command_buffer->base);
../../utils/deferred_command_buffer.c:    command_buffer->host_allocator = host_allocator;
../../utils/deferred_command_buffer.c:    iree_hal_cmd_list_initialize(block_pool, &command_buffer->cmd_list);
../../utils/deferred_command_buffer.c:                                            &command_buffer->resource_set);
../../utils/deferred_command_buffer.c:    *out_command_buffer = &command_buffer->base;
../../utils/deferred_command_buffer.c:    iree_hal_command_buffer_destroy(&command_buffer->base);
../../utils/deferred_command_buffer.c:  iree_allocator_t host_allocator = command_buffer->host_allocator;
../../utils/deferred_command_buffer.c:  iree_hal_cmd_list_deinitialize(&command_buffer->cmd_list);
../../utils/deferred_command_buffer.c:  iree_hal_resource_set_free(command_buffer->resource_set);
../../utils/deferred_command_buffer.c:  return iree_hal_resource_is(&command_buffer->resource,
../../utils/deferred_command_buffer.c:  if (!iree_hal_cmd_list_is_empty(&command_buffer->cmd_list)) {
../../utils/deferred_command_buffer.c:                            "command buffer cannot be re-recorded");
../../utils/deferred_command_buffer.c:  iree_hal_resource_set_freeze(command_buffer->resource_set);
../../utils/deferred_command_buffer.c://===----------------------------------------------------------------------===//
../../utils/deferred_command_buffer.c://===----------------------------------------------------------------------===//
../../utils/deferred_command_buffer.c:      &iree_hal_deferred_command_buffer_cast(base_command_buffer)->cmd_list;
../../utils/deferred_command_buffer.c:  cmd->source_stage_mask = source_stage_mask;
../../utils/deferred_command_buffer.c:  cmd->target_stage_mask = target_stage_mask;
../../utils/deferred_command_buffer.c:  cmd->flags = flags;
../../utils/deferred_command_buffer.c:  cmd->memory_barrier_count = memory_barrier_count;
../../utils/deferred_command_buffer.c:  cmd->memory_barriers = NULL;
../../utils/deferred_command_buffer.c:  cmd->buffer_barrier_count = buffer_barrier_count;
../../utils/deferred_command_buffer.c:  cmd->buffer_barriers = NULL;
../../utils/deferred_command_buffer.c:        (void**)&cmd->memory_barriers));
../../utils/deferred_command_buffer.c:        (void**)&cmd->buffer_barriers));
../../utils/deferred_command_buffer.c:      target_command_buffer, cmd->source_stage_mask, cmd->target_stage_mask,
../../utils/deferred_command_buffer.c:      cmd->flags, cmd->memory_barrier_count, cmd->memory_barriers,
../../utils/deferred_command_buffer.c:      cmd->buffer_barrier_count, cmd->buffer_barriers);
../../utils/deferred_command_buffer.c://===----------------------------------------------------------------------===//
../../utils/deferred_command_buffer.c://===----------------------------------------------------------------------===//
../../utils/deferred_command_buffer.c:  iree_hal_cmd_list_t* cmd_list = &command_buffer->cmd_list;
../../utils/deferred_command_buffer.c:      iree_hal_resource_set_insert(command_buffer->resource_set, 1, &event));
../../utils/deferred_command_buffer.c:  cmd->event = event;
../../utils/deferred_command_buffer.c:  cmd->source_stage_mask = source_stage_mask;
../../utils/deferred_command_buffer.c:  return iree_hal_command_buffer_signal_event(target_command_buffer, cmd->event,
../../utils/deferred_command_buffer.c:                                              cmd->source_stage_mask);
../../utils/deferred_command_buffer.c://===----------------------------------------------------------------------===//
../../utils/deferred_command_buffer.c://===----------------------------------------------------------------------===//
../../utils/deferred_command_buffer.c:  iree_hal_cmd_list_t* cmd_list = &command_buffer->cmd_list;
../../utils/deferred_command_buffer.c:      iree_hal_resource_set_insert(command_buffer->resource_set, 1, &event));
../../utils/deferred_command_buffer.c:  cmd->event = event;
../../utils/deferred_command_buffer.c:  cmd->source_stage_mask = source_stage_mask;
../../utils/deferred_command_buffer.c:  return iree_hal_command_buffer_reset_event(target_command_buffer, cmd->event,
../../utils/deferred_command_buffer.c:                                             cmd->source_stage_mask);
../../utils/deferred_command_buffer.c://===----------------------------------------------------------------------===//
../../utils/deferred_command_buffer.c://===----------------------------------------------------------------------===//
../../utils/deferred_command_buffer.c:  iree_hal_cmd_list_t* cmd_list = &command_buffer->cmd_list;
../../utils/deferred_command_buffer.c:      command_buffer->resource_set, event_count, events));
../../utils/deferred_command_buffer.c:      sizeof(*cmd) + sizeof(cmd->events[0]) * event_count, (void**)&cmd));
../../utils/deferred_command_buffer.c:  cmd->event_count = event_count;
../../utils/deferred_command_buffer.c:  cmd->source_stage_mask = source_stage_mask;
../../utils/deferred_command_buffer.c:  cmd->target_stage_mask = target_stage_mask;
../../utils/deferred_command_buffer.c:  cmd->memory_barrier_count = memory_barrier_count;
../../utils/deferred_command_buffer.c:  cmd->memory_barriers = NULL;
../../utils/deferred_command_buffer.c:  cmd->buffer_barrier_count = buffer_barrier_count;
../../utils/deferred_command_buffer.c:  cmd->buffer_barriers = NULL;
../../utils/deferred_command_buffer.c:  memcpy(cmd->events, events, sizeof(cmd->events[0]) * event_count);
../../utils/deferred_command_buffer.c:        (void**)&cmd->memory_barriers));
../../utils/deferred_command_buffer.c:        (void**)&cmd->buffer_barriers));
../../utils/deferred_command_buffer.c:      target_command_buffer, cmd->event_count,
../../utils/deferred_command_buffer.c:      (const iree_hal_event_t**)cmd->events, cmd->source_stage_mask,
../../utils/deferred_command_buffer.c:      cmd->target_stage_mask, cmd->memory_barrier_count, cmd->memory_barriers,
../../utils/deferred_command_buffer.c:      cmd->buffer_barrier_count, cmd->buffer_barriers);
../../utils/deferred_command_buffer.c://===----------------------------------------------------------------------===//
../../utils/deferred_command_buffer.c://===----------------------------------------------------------------------===//
../../utils/deferred_command_buffer.c:  iree_hal_cmd_list_t* cmd_list = &command_buffer->cmd_list;
../../utils/deferred_command_buffer.c:        command_buffer->resource_set, 1, &buffer_ref.buffer));
../../utils/deferred_command_buffer.c:  cmd->buffer_ref = buffer_ref;
../../utils/deferred_command_buffer.c:  cmd->flags = flags;
../../utils/deferred_command_buffer.c:  cmd->arg0 = arg0;
../../utils/deferred_command_buffer.c:  cmd->arg1 = arg1;
../../utils/deferred_command_buffer.c:      binding_table, cmd->buffer_ref, &buffer_ref));
../../utils/deferred_command_buffer.c:      target_command_buffer, buffer_ref, cmd->flags, cmd->arg0, cmd->arg1);
../../utils/deferred_command_buffer.c://===----------------------------------------------------------------------===//
../../utils/deferred_command_buffer.c://===----------------------------------------------------------------------===//
../../utils/deferred_command_buffer.c:  iree_hal_cmd_list_t* cmd_list = &command_buffer->cmd_list;
../../utils/deferred_command_buffer.c:  if (pattern_length > sizeof(cmd->pattern)) {
../../utils/deferred_command_buffer.c:        command_buffer->resource_set, 1, &target_ref.buffer));
../../utils/deferred_command_buffer.c:  cmd->target_ref = target_ref;
../../utils/deferred_command_buffer.c:  memcpy(&cmd->pattern, pattern, pattern_length);
../../utils/deferred_command_buffer.c:  cmd->pattern_length = pattern_length;
../../utils/deferred_command_buffer.c:  cmd->flags = flags;
../../utils/deferred_command_buffer.c:      binding_table, cmd->target_ref, &target_ref));
../../utils/deferred_command_buffer.c:                                             (void**)&cmd->pattern,
../../utils/deferred_command_buffer.c:                                             cmd->pattern_length, cmd->flags);
../../utils/deferred_command_buffer.c://===----------------------------------------------------------------------===//
../../utils/deferred_command_buffer.c://===----------------------------------------------------------------------===//
../../utils/deferred_command_buffer.c:  iree_hal_cmd_list_t* cmd_list = &command_buffer->cmd_list;
../../utils/deferred_command_buffer.c:        command_buffer->resource_set, 1, &target_ref.buffer));
../../utils/deferred_command_buffer.c:      sizeof(*cmd) + sizeof(cmd->source_buffer[0]) * target_ref.length,
../../utils/deferred_command_buffer.c:  cmd->target_ref = target_ref;
../../utils/deferred_command_buffer.c:  cmd->flags = flags;
../../utils/deferred_command_buffer.c:  memcpy(cmd->source_buffer, (const uint8_t*)source_buffer + source_offset,
../../utils/deferred_command_buffer.c:         sizeof(cmd->source_buffer[0]) * target_ref.length);
../../utils/deferred_command_buffer.c:      binding_table, cmd->target_ref, &target_ref));
../../utils/deferred_command_buffer.c:      target_command_buffer, cmd->source_buffer, 0, target_ref, cmd->flags);
../../utils/deferred_command_buffer.c://===----------------------------------------------------------------------===//
../../utils/deferred_command_buffer.c://===----------------------------------------------------------------------===//
../../utils/deferred_command_buffer.c:  iree_hal_cmd_list_t* cmd_list = &command_buffer->cmd_list;
../../utils/deferred_command_buffer.c:        command_buffer->resource_set, resource_count, resources));
../../utils/deferred_command_buffer.c:  cmd->source_ref = source_ref;
../../utils/deferred_command_buffer.c:  cmd->target_ref = target_ref;
../../utils/deferred_command_buffer.c:  cmd->flags = flags;
../../utils/deferred_command_buffer.c:      binding_table, cmd->source_ref, &source_ref));
../../utils/deferred_command_buffer.c:      binding_table, cmd->target_ref, &target_ref));
../../utils/deferred_command_buffer.c:                                             target_ref, cmd->flags);
../../utils/deferred_command_buffer.c://===----------------------------------------------------------------------===//
../../utils/deferred_command_buffer.c://===----------------------------------------------------------------------===//
../../utils/deferred_command_buffer.c:  iree_hal_cmd_list_t* cmd_list = &command_buffer->cmd_list;
../../utils/deferred_command_buffer.c:      command_buffer->resource_set, resource_count, resources));
../../utils/deferred_command_buffer.c:  cmd->channel = channel;
../../utils/deferred_command_buffer.c:  cmd->op = op;
../../utils/deferred_command_buffer.c:  cmd->param = param;
../../utils/deferred_command_buffer.c:  cmd->send_ref = send_ref;
../../utils/deferred_command_buffer.c:  cmd->recv_ref = recv_ref;
../../utils/deferred_command_buffer.c:  cmd->element_count = element_count;
../../utils/deferred_command_buffer.c:      binding_table, cmd->send_ref, &send_ref));
../../utils/deferred_command_buffer.c:      binding_table, cmd->recv_ref, &recv_ref));
../../utils/deferred_command_buffer.c:  return iree_hal_command_buffer_collective(target_command_buffer, cmd->channel,
../../utils/deferred_command_buffer.c:                                            cmd->op, cmd->param, send_ref,
../../utils/deferred_command_buffer.c:                                            recv_ref, cmd->element_count);
../../utils/deferred_command_buffer.c://===----------------------------------------------------------------------===//
../../utils/deferred_command_buffer.c://===----------------------------------------------------------------------===//
../../utils/deferred_command_buffer.c:      command_buffer->resource_set, resource_count, resources));
../../utils/deferred_command_buffer.c:      &command_buffer->cmd_list, IREE_HAL_CMD_DISPATCH, total_size,
../../utils/deferred_command_buffer.c:  cmd->executable = executable;
../../utils/deferred_command_buffer.c:  cmd->entry_point = entry_point;
../../utils/deferred_command_buffer.c:  memcpy(&cmd->config, &config, sizeof(cmd->config));
../../utils/deferred_command_buffer.c:  cmd->flags = flags;
../../utils/deferred_command_buffer.c:  cmd->constants = iree_make_const_byte_span(cmd_ptr, constants.data_length);
../../utils/deferred_command_buffer.c:  cmd->bindings.count = bindings.count;
../../utils/deferred_command_buffer.c:  cmd->bindings.values = (iree_hal_buffer_ref_t*)cmd_ptr;
../../utils/deferred_command_buffer.c:      command_buffer->resource_set, bindings.count, bindings.values,
../../utils/deferred_command_buffer.c:  iree_hal_dispatch_config_t config = cmd->config;
../../utils/deferred_command_buffer.c:      binding_table, cmd->config.workgroup_count_ref,
../../utils/deferred_command_buffer.c:      cmd->bindings.count * sizeof(iree_hal_buffer_ref_t));
../../utils/deferred_command_buffer.c:  for (iree_host_size_t i = 0; i < cmd->bindings.count; ++i) {
../../utils/deferred_command_buffer.c:        binding_table, cmd->bindings.values[i], &binding_refs[i]));
../../utils/deferred_command_buffer.c:      .count = cmd->bindings.count,
../../utils/deferred_command_buffer.c:      target_command_buffer, cmd->executable, cmd->entry_point, config,
../../utils/deferred_command_buffer.c:      cmd->constants, binding_ref_list, cmd->flags);
../../utils/deferred_command_buffer.c://===----------------------------------------------------------------------===//
../../utils/deferred_command_buffer.c://===----------------------------------------------------------------------===//
../../utils/deferred_command_buffer.c:  iree_hal_cmd_list_t* cmd_list = &command_buffer->cmd_list;
../../utils/deferred_command_buffer.c:    for (iree_hal_cmd_header_t* cmd = cmd_list->head; cmd != NULL;
../../utils/deferred_command_buffer.c:         cmd = cmd->next) {
../../utils/deferred_command_buffer.c:      status = iree_hal_cmd_apply_table[cmd->type](target_command_buffer,
../../utils/deferred_command_buffer.c:  // One-shot command buffers can't be replayed so we can drop the memory
../../utils/deferred_command_buffer.c:      iree_all_bits_set(command_buffer->base.mode,
../../local/loaders/vmvx_module_loader.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/loaders/vmvx_module_loader.c://===----------------------------------------------------------------------===//
../../local/loaders/vmvx_module_loader.c:// Built-in executable helpers
../../local/loaders/vmvx_module_loader.c://===----------------------------------------------------------------------===//
../../local/loaders/vmvx_module_loader.c:                              "executable has no executable-level constants "
../../local/loaders/vmvx_module_loader.c:                            "executable requires executable-level constants "
../../local/loaders/vmvx_module_loader.c:  // Wrap the constant memory in an on-stack buffer.
../../local/loaders/vmvx_module_loader.c:  // lifetime - this will abort if it's not.
../../local/loaders/vmvx_module_loader.c://===----------------------------------------------------------------------===//
../../local/loaders/vmvx_module_loader.c://===----------------------------------------------------------------------===//
../../local/loaders/vmvx_module_loader.c:  // per-call state.
../../local/loaders/vmvx_module_loader.c:  // Set executable-level constants.
../../local/loaders/vmvx_module_loader.c:        context, bytecode_module, executable_params->constant_count,
../../local/loaders/vmvx_module_loader.c:        executable_params->constants, host_allocator);
../../local/loaders/vmvx_module_loader.c:    out_state->context = context;
../../local/loaders/vmvx_module_loader.c:    out_state->vmvx_module_state = vmvx_module_state;
../../local/loaders/vmvx_module_loader.c:  if (state->context) {
../../local/loaders/vmvx_module_loader.c:    iree_vm_context_release(state->context);
../../local/loaders/vmvx_module_loader.c:    state->context = NULL;
../../local/loaders/vmvx_module_loader.c://===----------------------------------------------------------------------===//
../../local/loaders/vmvx_module_loader.c://===----------------------------------------------------------------------===//
../../local/loaders/vmvx_module_loader.c:  // Preallocated per-worker states that are used to emulate TLS.
../../local/loaders/vmvx_module_loader.c:      iree_host_align(entry_count * sizeof(*executable->entry_fn_ordinals), 8);
../../local/loaders/vmvx_module_loader.c:      entry_count * sizeof(*executable->base.dispatch_attrs), 8);
../../local/loaders/vmvx_module_loader.c:      iree_host_align(worker_capacity * sizeof(*executable->worker_states), 8);
../../local/loaders/vmvx_module_loader.c:                                         host_allocator, &executable->base);
../../local/loaders/vmvx_module_loader.c:    executable->base.dispatch_attrs = dispatch_attrs;
../../local/loaders/vmvx_module_loader.c:    executable->worker_capacity = worker_capacity;
../../local/loaders/vmvx_module_loader.c:    executable->worker_states = (iree_hal_vmvx_worker_state_t*)ptr;
../../local/loaders/vmvx_module_loader.c:    executable->bytecode_module = bytecode_module;
../../local/loaders/vmvx_module_loader.c:    executable->entry_fn_count = entry_count;
../../local/loaders/vmvx_module_loader.c:    for (iree_host_size_t i = 0; i < executable->entry_fn_count; ++i) {
../../local/loaders/vmvx_module_loader.c:      executable->entry_fn_ordinals[i] = entry_fn.ordinal;
../../local/loaders/vmvx_module_loader.c:    // reference from the module. Module-level reflection attrs would help.
../../local/loaders/vmvx_module_loader.c:    for (iree_host_size_t i = 0; i < executable->entry_fn_count; ++i) {
../../local/loaders/vmvx_module_loader.c:          .module = executable->bytecode_module,
../../local/loaders/vmvx_module_loader.c:          .ordinal = executable->entry_fn_ordinals[i],
../../local/loaders/vmvx_module_loader.c:          host_allocator, &executable->worker_states[i]);
../../local/loaders/vmvx_module_loader.c:  iree_allocator_t host_allocator = executable->base.host_allocator;
../../local/loaders/vmvx_module_loader.c:  for (iree_host_size_t i = 0; i < executable->worker_capacity; ++i) {
../../local/loaders/vmvx_module_loader.c:    iree_hal_vmvx_worker_state_deinitialize(&executable->worker_states[i]);
../../local/loaders/vmvx_module_loader.c:  if (IREE_UNLIKELY(ordinal >= executable->entry_fn_count)) {
../../local/loaders/vmvx_module_loader.c:      .module = executable->bytecode_module,
../../local/loaders/vmvx_module_loader.c:      .ordinal = executable->entry_fn_ordinals[ordinal],
../../local/loaders/vmvx_module_loader.c:  // Fetch worker-local state. This caller is the only one able to access it so
../../local/loaders/vmvx_module_loader.c:  if (IREE_UNLIKELY(worker_id >= executable->worker_capacity)) {
../../local/loaders/vmvx_module_loader.c:      &executable->worker_states[worker_id];
../../local/loaders/vmvx_module_loader.c:  iree_vmvx_module_state_update_workgroup_state(worker_state->vmvx_module_state,
../../local/loaders/vmvx_module_loader.c:                                                workgroup_state->processor_id);
../../local/loaders/vmvx_module_loader.c:  // On-stack interface local to this invocation.
../../local/loaders/vmvx_module_loader.c:      iree_vm_list_storage_size(&buffer_type, dispatch_state->binding_count);
../../local/loaders/vmvx_module_loader.c:      &buffer_type, dispatch_state->binding_count, &binding_list));
../../local/loaders/vmvx_module_loader.c:  // Map bindings into on-stack VMVX buffers.
../../local/loaders/vmvx_module_loader.c:      dispatch_state->binding_count * sizeof(iree_vm_buffer_t));
../../local/loaders/vmvx_module_loader.c:  for (iree_host_size_t i = 0; i < dispatch_state->binding_count; ++i) {
../../local/loaders/vmvx_module_loader.c:        iree_make_byte_span(dispatch_state->binding_ptrs[i],
../../local/loaders/vmvx_module_loader.c:                            dispatch_state->binding_lengths[i]),
../../local/loaders/vmvx_module_loader.c:      iree_make_byte_span(workgroup_state->local_memory,
../../local/loaders/vmvx_module_loader.c:                          workgroup_state->local_memory_size),
../../local/loaders/vmvx_module_loader.c:      iree_make_byte_span((void*)dispatch_state->constants,
../../local/loaders/vmvx_module_loader.c:                          sizeof(uint32_t) * dispatch_state->constant_count),
../../local/loaders/vmvx_module_loader.c:  // NOTE: this level of the VM ABI is supported - but may change in the future.
../../local/loaders/vmvx_module_loader.c:      .workgroup_id_x = workgroup_state->workgroup_id_x,
../../local/loaders/vmvx_module_loader.c:      .workgroup_id_y = workgroup_state->workgroup_id_y,
../../local/loaders/vmvx_module_loader.c:      .workgroup_id_z = workgroup_state->workgroup_id_z,
../../local/loaders/vmvx_module_loader.c:      .workgroup_size_x = dispatch_state->workgroup_size_x,
../../local/loaders/vmvx_module_loader.c:      .workgroup_size_y = dispatch_state->workgroup_size_y,
../../local/loaders/vmvx_module_loader.c:      .workgroup_size_z = dispatch_state->workgroup_size_z,
../../local/loaders/vmvx_module_loader.c:      .workgroup_count_x = dispatch_state->workgroup_count_x,
../../local/loaders/vmvx_module_loader.c:      .workgroup_count_y = dispatch_state->workgroup_count_y,
../../local/loaders/vmvx_module_loader.c:      .workgroup_count_z = dispatch_state->workgroup_count_z,
../../local/loaders/vmvx_module_loader.c:      iree_vm_context_state_resolver(worker_state->context),
../../local/loaders/vmvx_module_loader.c:      executable->base.host_allocator);
../../local/loaders/vmvx_module_loader.c:  status = entry_fn.module->begin_call(entry_fn.module->self, stack, call);
../../local/loaders/vmvx_module_loader.c:  for (iree_host_size_t i = 0; i < dispatch_state->binding_count; ++i) {
../../local/loaders/vmvx_module_loader.c://===----------------------------------------------------------------------===//
../../local/loaders/vmvx_module_loader.c://===----------------------------------------------------------------------===//
../../local/loaders/vmvx_module_loader.c:          common_module_count * sizeof(executable_loader->common_modules[0]),
../../local/loaders/vmvx_module_loader.c:        iree_hal_executable_import_provider_null(), &executable_loader->base);
../../local/loaders/vmvx_module_loader.c:    executable_loader->host_allocator = host_allocator;
../../local/loaders/vmvx_module_loader.c:    executable_loader->instance = instance;
../../local/loaders/vmvx_module_loader.c:    iree_vm_instance_retain(executable_loader->instance);
../../local/loaders/vmvx_module_loader.c:    // We prepend the vmvx_module to any user-provided modules.
../../local/loaders/vmvx_module_loader.c:    executable_loader->common_module_count = common_module_count;
../../local/loaders/vmvx_module_loader.c:    executable_loader->common_modules[IREE_VMVX_MODULE_INDEX] = vmvx_module;
../../local/loaders/vmvx_module_loader.c:      executable_loader->common_modules[1 + i] = user_modules[i];
../../local/loaders/vmvx_module_loader.c:  iree_allocator_t host_allocator = executable_loader->host_allocator;
../../local/loaders/vmvx_module_loader.c:  for (iree_host_size_t i = 0; i < executable_loader->common_module_count;
../../local/loaders/vmvx_module_loader.c:    iree_vm_module_release(executable_loader->common_modules[i]);
../../local/loaders/vmvx_module_loader.c:  iree_vm_instance_release(executable_loader->instance);
../../local/loaders/vmvx_module_loader.c:             iree_make_cstring_view("vmvx-bytecode-fb")) ||
../../local/loaders/vmvx_module_loader.c:                                iree_make_cstring_view("accel-bytecode-fb"));
../../local/loaders/vmvx_module_loader.c:      executable_params->executable_data;
../../local/loaders/vmvx_module_loader.c:  if (iree_all_bits_set(executable_params->caching_mode,
../../local/loaders/vmvx_module_loader.c:    // Zero-copy route.
../../local/loaders/vmvx_module_loader.c:    bytecode_module_allocator = executable_loader->host_allocator;
../../local/loaders/vmvx_module_loader.c:        z0, iree_allocator_clone(executable_loader->host_allocator,
../../local/loaders/vmvx_module_loader.c:                                 executable_params->executable_data,
../../local/loaders/vmvx_module_loader.c:  // Load the user-provided bytecode module. We pass ownership of the data (if
../../local/loaders/vmvx_module_loader.c:      executable_loader->instance, executable_params->executable_data,
../../local/loaders/vmvx_module_loader.c:      bytecode_module_allocator, executable_loader->host_allocator,
../../local/loaders/vmvx_module_loader.c:        executable_loader->common_module_count + 1;
../../local/loaders/vmvx_module_loader.c:    memcpy(context_modules, executable_loader->common_modules,
../../local/loaders/vmvx_module_loader.c:           executable_loader->common_module_count *
../../local/loaders/vmvx_module_loader.c:               sizeof(executable_loader->common_modules[0]));
../../local/loaders/vmvx_module_loader.c:    context_modules[context_module_count - 1] = bytecode_module;
../../local/loaders/vmvx_module_loader.c:        executable_loader->instance, context_module_count, context_modules,
../../local/loaders/vmvx_module_loader.c:        executable_loader->host_allocator, out_executable);
../../local/loaders/embedded_elf_loader.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/loaders/embedded_elf_loader.h:// Creates an executable loader that can load minimally-featured ELF dynamic
../../local/loaders/embedded_elf_loader.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/loaders/embedded_elf_loader.c://===----------------------------------------------------------------------===//
../../local/loaders/embedded_elf_loader.c://===----------------------------------------------------------------------===//
../../local/loaders/embedded_elf_loader.c:      &executable->module, IREE_HAL_EXECUTABLE_LIBRARY_EXPORT_NAME,
../../local/loaders/embedded_elf_loader.c:  executable->library.header =
../../local/loaders/embedded_elf_loader.c:          &executable->base.environment);
../../local/loaders/embedded_elf_loader.c:  if (!executable->library.header) {
../../local/loaders/embedded_elf_loader.c:      *executable->library.header;
../../local/loaders/embedded_elf_loader.c:  switch (header->sanitizer) {
../../local/loaders/embedded_elf_loader.c:                              (uint32_t)header->sanitizer);
../../local/loaders/embedded_elf_loader.c:  executable->identifier = iree_make_cstring_view(header->name);
../../local/loaders/embedded_elf_loader.c:  executable->base.dispatch_attrs = executable->library.v0->exports.attrs;
../../local/loaders/embedded_elf_loader.c:  IREE_ASSERT_ARGUMENT(executable_params->executable_data.data &&
../../local/loaders/embedded_elf_loader.c:                       executable_params->executable_data.data_length);
../../local/loaders/embedded_elf_loader.c:  IREE_ASSERT_ARGUMENT(!executable_params->constant_count ||
../../local/loaders/embedded_elf_loader.c:                       executable_params->constants);
../../local/loaders/embedded_elf_loader.c:      executable_params->constant_count * sizeof(*executable_params->constants);
../../local/loaders/embedded_elf_loader.c:                                         host_allocator, &executable->base);
../../local/loaders/embedded_elf_loader.c:  if (iree_status_is_ok(status) && executable_params->constant_count > 0) {
../../local/loaders/embedded_elf_loader.c:    memcpy(target_constants, executable_params->constants,
../../local/loaders/embedded_elf_loader.c:           executable_params->constant_count *
../../local/loaders/embedded_elf_loader.c:               sizeof(*executable_params->constants));
../../local/loaders/embedded_elf_loader.c:    executable->base.environment.constants = target_constants;
../../local/loaders/embedded_elf_loader.c:        executable_params->executable_data, /*import_table=*/NULL,
../../local/loaders/embedded_elf_loader.c:        host_allocator, &executable->module);
../../local/loaders/embedded_elf_loader.c:        &executable->base.environment, import_provider,
../../local/loaders/embedded_elf_loader.c:        &executable->library.v0->imports,
../../local/loaders/embedded_elf_loader.c:                                                executable->library.v0);
../../local/loaders/embedded_elf_loader.c:    iree_hal_executable_library_publish_source_files(executable->library.v0);
../../local/loaders/embedded_elf_loader.c:  iree_allocator_t host_allocator = executable->base.host_allocator;
../../local/loaders/embedded_elf_loader.c:  iree_elf_module_deinitialize(&executable->module);
../../local/loaders/embedded_elf_loader.c:      &executable->base.environment, host_allocator);
../../local/loaders/embedded_elf_loader.c:  const iree_hal_executable_library_v0_t* library = executable->library.v0;
../../local/loaders/embedded_elf_loader.c:  if (IREE_UNLIKELY(ordinal >= library->exports.count)) {
../../local/loaders/embedded_elf_loader.c:  IREE_HAL_EXECUTABLE_LIBRARY_CALL_TRACE_ZONE_BEGIN(z0, executable->identifier,
../../local/loaders/embedded_elf_loader.c:  IREE_HAL_EXECUTABLE_LIBRARY_CALL_HOOK_BEGIN(executable->identifier, library,
../../local/loaders/embedded_elf_loader.c:  int ret = iree_elf_call_i_ppp(library->exports.ptrs[ordinal],
../../local/loaders/embedded_elf_loader.c:                                (void*)&base_executable->environment,
../../local/loaders/embedded_elf_loader.c:  IREE_HAL_EXECUTABLE_LIBRARY_CALL_HOOK_END(executable->identifier, library,
../../local/loaders/embedded_elf_loader.c://===----------------------------------------------------------------------===//
../../local/loaders/embedded_elf_loader.c://===----------------------------------------------------------------------===//
../../local/loaders/embedded_elf_loader.c:        &executable_loader->base);
../../local/loaders/embedded_elf_loader.c:    executable_loader->host_allocator = host_allocator;
../../local/loaders/embedded_elf_loader.c:    executable_loader->plugin_manager = plugin_manager;
../../local/loaders/embedded_elf_loader.c:        executable_loader->plugin_manager);
../../local/loaders/embedded_elf_loader.c:  iree_allocator_t host_allocator = executable_loader->host_allocator;
../../local/loaders/embedded_elf_loader.c:  iree_hal_executable_plugin_manager_release(executable_loader->plugin_manager);
../../local/loaders/embedded_elf_loader.c:      executable_format, iree_make_cstring_view("embedded-elf-" IREE_ARCH));
../../local/loaders/embedded_elf_loader.c:      executable_params, base_executable_loader->import_provider,
../../local/loaders/embedded_elf_loader.c:      executable_loader->host_allocator, out_executable);
../../utils/libmpi.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/libmpi.c://===----------------------------------------------------------------------===//
../../utils/libmpi.c://===----------------------------------------------------------------------===//
../../utils/libmpi.c:        library, kName, (void**)&syms->mpiSymbolName));      \
../../utils/libmpi.c://===----------------------------------------------------------------------===//
../../utils/libmpi.c://===----------------------------------------------------------------------===//
../../utils/libmpi.c:  if (syms->MPI_Error_string(result, error_string, &error_len) != MPI_SUCCESS) {
../../utils/libmpi.c:  if (syms->MPI_Error_class(result, &error_class) != MPI_SUCCESS) {
../../local/loaders/vmvx_module_loader.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/loaders/vmvx_module_loader.h:// in many contexts. Modules must be thread-safe and ideally have no thread
../../local/loaders/vmvx_module_loader.h:// Compiled VMVX programs that use the user-provided modules are encouraged to
../../local/loaders/vmvx_module_loader.h:// `arm-sve` modules, etc).
../../local/local_executable.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/local_executable.c:  iree_hal_resource_initialize(vtable, &out_base_executable->resource);
../../local/local_executable.c:  out_base_executable->host_allocator = host_allocator;
../../local/local_executable.c:  out_base_executable->dispatch_attrs = NULL;
../../local/local_executable.c:                                             &out_base_executable->environment);
../../local/local_executable.c:              executable->resource.vtable)
../../local/local_executable.c:      ->issue_call(executable, ordinal, dispatch_state, workgroup_state,
../../local/local_executable.c:  const uint32_t workgroup_count_x = dispatch_state->workgroup_count_x;
../../local/local_executable.c:  const uint32_t workgroup_count_y = dispatch_state->workgroup_count_y;
../../local/local_executable.c:  const uint32_t workgroup_count_z = dispatch_state->workgroup_count_z;
../../local/loaders/BUILD.bazel:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/caching_allocator.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/caching_allocator.h:// device-local and host-visible buffers on devices with discrete memory.
../../utils/caching_allocator.h:// Pools are scanned in-order to allow for prioritization.
../../utils/caching_allocator.h:// Thread-safe: the allocator can be shared across multiple user-level devices
../../utils/caching_allocator.h:  // bounded (~64-1024).
../../utils/caching_allocator.h:// Thread-safe: internal synchronization of caching allocator data structures
../../utils/caching_allocator.h:// Thread-safe: internal synchronization of caching allocator data structures
../../utils/caching_allocator.h:// Creates a caching allocator with the given key-value |config_pairs|.
../../local/inline_command_buffer.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/inline_command_buffer.h:// Initializes an inline synchronous one-shot single-threaded command "buffer".
../../local/inline_command_buffer.h:// caller-allocated |storage| (must be at least the capacity specified by
../../local/inline_command_buffer.h:// Creates an inline synchronous one-shot single-threaded command "buffer".
../../local/inline_command_buffer.h:// This is designed for ultra-low latency situations where we know the command
../../local/inline_command_buffer.h:// can begin execution immediately. No inter-command-buffer scheduling will be
../../utils/executable_debug_info.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/executable_debug_info.h:// Verifies per-export debug info is valid.
../../local/executable_library_util.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/executable_library_util.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/executable_library_util.c:      iree_all_bits_set(executable_params->caching_mode,
../../local/executable_library_util.c:  if (library->constants.count != executable_params->constant_count) {
../../local/executable_library_util.c:                            library->constants.count,
../../local/executable_library_util.c:                            executable_params->constant_count);
../../local/executable_library_util.c:  if (library->exports.attrs) {
../../local/executable_library_util.c:    for (uint32_t i = 0; i < library->exports.count; ++i) {
../../local/executable_library_util.c:          library->exports.attrs[i];
../../local/executable_library_util.c:  if (!import_table || !import_table->count) return iree_ok_status();
../../local/executable_library_util.c:  IREE_TRACE_ZONE_APPEND_VALUE_I64(z0, import_table->count);
../../local/executable_library_util.c:  environment->import_thunk = import_thunk;
../../local/executable_library_util.c:      iree_host_align(import_table->count * sizeof(*environment->import_funcs),
../../local/executable_library_util.c:      import_table->count * sizeof(*environment->import_contexts),
../../local/executable_library_util.c:  environment->import_funcs = (const iree_hal_executable_import_v0_t*)base_ptr;
../../local/executable_library_util.c:  environment->import_contexts = (const void**)(base_ptr + import_funcs_size);
../../local/executable_library_util.c:              import_provider, import_table->count, import_table->symbols,
../../local/executable_library_util.c:              (void**)environment->import_funcs,
../../local/executable_library_util.c:              (void**)environment->import_contexts,
../../local/executable_library_util.c:  if (environment->import_funcs != NULL) {
../../local/executable_library_util.c:    iree_allocator_free(host_allocator, (void*)environment->import_funcs);
../../local/executable_library_util.c:  environment->import_funcs = NULL;
../../local/executable_library_util.c:  environment->import_contexts = NULL;
../../local/executable_library_util.c:  environment->import_thunk = NULL;
../../local/executable_library_util.c:  for (uint32_t i = 0; i < library->sources.count; ++i) {
../../local/executable_library_util.c:        &library->sources.files[i];
../../local/executable_library_util.c:    IREE_TRACE_PUBLISH_SOURCE_FILE(source_file->path, source_file->path_length,
../../local/executable_library_util.c:                                   source_file->content,
../../local/executable_library_util.c:                                   source_file->content_length);
../../local/executable_library_util.c:  if (library->exports.names != NULL) {
../../local/executable_library_util.c:    entry_point_name = iree_make_cstring_view(library->exports.names[ordinal]);
../../local/executable_library_util.c:  if (library->exports.stage_locations != NULL) {
../../local/executable_library_util.c:    for (uint32_t i = 0; i < library->exports.stage_locations->count; ++i) {
../../local/executable_library_util.c:      // const char* name = library->exports.stage_locations->names[i];
../../local/executable_library_util.c:          &library->exports.stage_locations->locations[i];
../../local/executable_library_util.c:      source_file = location->path;
../../local/executable_library_util.c:      source_file_length = location->path_length;
../../local/executable_library_util.c:      source_line = location->line;
../../local/executable_library_util.c:    if (library->exports.source_locations != NULL) {
../../local/executable_library_util.c:          &library->exports.source_locations[ordinal];
../../local/executable_library_util.c:      source_file = location->path;
../../local/executable_library_util.c:      source_file_length = location->path_length;
../../local/executable_library_util.c:      source_line = location->line;
../../local/executable_library_util.c:  if (library->exports.tags != NULL) {
../../local/executable_library_util.c:    const char* tag = library->exports.tags[ordinal];
../../local/executable_plugin_manager.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/executable_plugin_manager.c://===----------------------------------------------------------------------===//
../../local/executable_plugin_manager.c://===----------------------------------------------------------------------===//
../../local/executable_plugin_manager.c://===----------------------------------------------------------------------===//
../../local/executable_plugin_manager.c://===----------------------------------------------------------------------===//
../../local/executable_plugin_manager.c:  plugin->library.header = header_ptr;
../../local/executable_plugin_manager.c:  const iree_hal_executable_plugin_header_t* header = *plugin->library.header;
../../local/executable_plugin_manager.c:  plugin->identifier = iree_make_cstring_view(header->name);
../../local/executable_plugin_manager.c:  if (iree_all_bits_set(header->features,
../../local/executable_plugin_manager.c:        (int)plugin->identifier.size, plugin->identifier.data);
../../local/executable_plugin_manager.c:  switch (header->sanitizer) {
../../local/executable_plugin_manager.c:          "runtime is not compiled with it enabled; add -fsanitize=address to "
../../local/executable_plugin_manager.c:          (int)plugin->identifier.size, plugin->identifier.data);
../../local/executable_plugin_manager.c:          "runtime is not compiled with it enabled; add -fsanitize=thread to "
../../local/executable_plugin_manager.c:          (int)plugin->identifier.size, plugin->identifier.data);
../../local/executable_plugin_manager.c:          (int)plugin->identifier.size, plugin->identifier.data,
../../local/executable_plugin_manager.c:          (uint32_t)header->sanitizer);
../../local/executable_plugin_manager.c:  // Plugin is probably good - let's try loading it! It could fail for any
../../local/executable_plugin_manager.c:  return (iree_status_t)plugin->library.v0->load(
../../local/executable_plugin_manager.c:      (const iree_hal_executable_plugin_string_pair_t*)params, &plugin->self);
../../local/executable_plugin_manager.c:  iree_atomic_ref_count_init(&out_base_plugin->ref_count);
../../local/executable_plugin_manager.c:  out_base_plugin->vtable = vtable;
../../local/executable_plugin_manager.c:  memset(&out_base_plugin->library, 0, sizeof(out_base_plugin->library));
../../local/executable_plugin_manager.c:  out_base_plugin->self = NULL;
../../local/executable_plugin_manager.c:  out_base_plugin->resolve_thunk = resolve_thunk;
../../local/executable_plugin_manager.c:          out_base_plugin->library.v0->header;
../../local/executable_plugin_manager.c:      IREE_TRACE_ZONE_APPEND_TEXT(z0, header->name);
../../local/executable_plugin_manager.c:      IREE_TRACE_ZONE_APPEND_TEXT(z0, header->description);
../../local/executable_plugin_manager.c:  IREE_TRACE_ZONE_APPEND_TEXT(z0, plugin->identifier.data,
../../local/executable_plugin_manager.c:                              plugin->identifier.size);
../../local/executable_plugin_manager.c:  if (plugin->library.v0 && plugin->library.v0->unload) {
../../local/executable_plugin_manager.c:    plugin->library.v0->unload(plugin->self);
../../local/executable_plugin_manager.c:  memset(&plugin->library, 0, sizeof(plugin->library));
../../local/executable_plugin_manager.c:  plugin->self = NULL;
../../local/executable_plugin_manager.c:  plugin->vtable->destroy(plugin);
../../local/executable_plugin_manager.c:    iree_atomic_ref_count_inc(&plugin->ref_count);
../../local/executable_plugin_manager.c:      iree_atomic_ref_count_dec(&plugin->ref_count) == 1) {
../../local/executable_plugin_manager.c:  IREE_TRACE_ZONE_APPEND_TEXT(z0, plugin->identifier.data,
../../local/executable_plugin_manager.c:                              plugin->identifier.size);
../../local/executable_plugin_manager.c:      plugin->resolve_thunk
../../local/executable_plugin_manager.c:          ? plugin->resolve_thunk(plugin->library.v0->resolve, plugin->self,
../../local/executable_plugin_manager.c:          : (iree_status_t)plugin->library.v0->resolve(plugin->self, &params,
../../local/executable_plugin_manager.c://===----------------------------------------------------------------------===//
../../local/executable_plugin_manager.c://===----------------------------------------------------------------------===//
../../local/executable_plugin_manager.c://===----------------------------------------------------------------------===//
../../local/executable_plugin_manager.c://===----------------------------------------------------------------------===//
../../local/executable_plugin_manager.c:      sizeof(*manager) + capacity * sizeof(manager->providers[0]),
../../local/executable_plugin_manager.c:      plugins_offset + capacity * sizeof(*manager->plugins);
../../local/executable_plugin_manager.c:  iree_atomic_ref_count_init(&manager->ref_count);
../../local/executable_plugin_manager.c:  manager->host_allocator = host_allocator;
../../local/executable_plugin_manager.c:  manager->capacity = capacity;
../../local/executable_plugin_manager.c:  iree_slim_mutex_initialize(&manager->mutex);
../../local/executable_plugin_manager.c:  manager->plugin_count = 0;
../../local/executable_plugin_manager.c:  manager->plugins =
../../local/executable_plugin_manager.c:  // Register any externally-defined plugins by default. Dynamically registered
../../local/executable_plugin_manager.c:  iree_allocator_t host_allocator = manager->host_allocator;
../../local/executable_plugin_manager.c:  for (int32_t i = manager->plugin_count - 1; i >= 0; --i) {
../../local/executable_plugin_manager.c:    iree_hal_executable_plugin_release(manager->plugins[i]);
../../local/executable_plugin_manager.c:  iree_slim_mutex_deinitialize(&manager->mutex);
../../local/executable_plugin_manager.c:    iree_atomic_ref_count_inc(&manager->ref_count);
../../local/executable_plugin_manager.c:      iree_atomic_ref_count_dec(&manager->ref_count) == 1) {
../../local/executable_plugin_manager.c:    // No-op provider; may happen on accident.
../../local/executable_plugin_manager.c:  // Hold the mutex to block other writers - readers are fine, though, as
../../local/executable_plugin_manager.c:  iree_slim_mutex_lock(&manager->mutex);
../../local/executable_plugin_manager.c:      iree_atomic_load(&manager->provider_count, iree_memory_order_acquire);
../../local/executable_plugin_manager.c:  if (slot >= manager->capacity) {
../../local/executable_plugin_manager.c:    iree_slim_mutex_unlock(&manager->mutex);
../../local/executable_plugin_manager.c:                            manager->capacity);
../../local/executable_plugin_manager.c:  manager->providers[slot] = provider;
../../local/executable_plugin_manager.c:    manager->plugins[manager->plugin_count++] = plugin;
../../local/executable_plugin_manager.c:  iree_atomic_fetch_add(&manager->provider_count, 1, iree_memory_order_release);
../../local/executable_plugin_manager.c:  iree_slim_mutex_unlock(&manager->mutex);
../../local/executable_plugin_manager.c:  // but that's ok: multithreaded registration/resolution is non-deterministic
../../local/executable_plugin_manager.c:      iree_atomic_load(&manager->provider_count, iree_memory_order_acquire);
../../local/executable_plugin_manager.c:  for (int32_t i = provider_count - 1; i >= 0; --i) {
../../local/executable_plugin_manager.c:    iree_hal_executable_import_provider_t provider = manager->providers[i];
../../local/executable_plugin_manager.c:    iree_string_builder_initialize(manager->host_allocator, &builder);
../../utils/stream_tracing.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/stream_tracing.h:// Per-stream tracing context.
../../utils/stream_tracing.h:// No-op if IREE tracing is not enabled.
../../utils/stream_tracing.h://   IREE_HAL_STREAM_TRACE_ZONE_BEGIN(queue->tracing_context, stream);
../../utils/stream_tracing.h://   IREE_HAL_STREAM_TRACE_ZONE_END(queue->tracing_context, stream);
../../utils/stream_tracing.h://   iree_hal_stream_tracing_context_collect(queue->tracing_context);
../../utils/stream_tracing.h:// NOTE: timestamps can have non-trivial side-effecting behavior and may
../../utils/stream_tracing.h:// Thread-compatible: external synchronization is required if using from
../../utils/stream_tracing.h:// Collects in-flight timestamp queries from the stream and feeds them to tracy.
../../local/executable_environment.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/executable_environment.c://===----------------------------------------------------------------------===//
../../local/executable_environment.c://===----------------------------------------------------------------------===//
../../local/executable_environment.c:  // TODO(benvanik): move this someplace better? Technically not thread-safe
../../local/executable_environment.c:                     &out_environment->processor.data[0]);
../../utils/deferred_command_buffer.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../utils/deferred_command_buffer.h://===----------------------------------------------------------------------===//
../../utils/deferred_command_buffer.h://===----------------------------------------------------------------------===//
../../utils/deferred_command_buffer.h:// Records an in-memory command buffer that can be replayed against a target
../../utils/deferred_command_buffer.h:// If the command buffer was recorded in one-shot mode it will be reset upon
../../local/local_executable.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/local_executable.h:  // Defines per-entry point how much workgroup local memory is required.
../../local/executable_library.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/executable_library.h:// this was a schema: backwards-incompatible changes require version bumps or
../../local/executable_library.h:// the ability to feature-detect at runtime.
../../local/executable_library.h://===----------------------------------------------------------------------===//
../../local/executable_library.h://===----------------------------------------------------------------------===//
../../local/executable_library.h://===----------------------------------------------------------------------===//
../../local/executable_library.h://===----------------------------------------------------------------------===//
../../local/executable_library.h:  // Equivalent compiler flag: -fsanitize=address
../../local/executable_library.h:  // Equivalent compiler flag: -fsanitize=memory
../../local/executable_library.h:  // Equivalent compiler flag: -fsanitize=thread
../../local/executable_library.h:  // Equivalent compiler flag: -fsanitize=undefined
../../local/executable_library.h://===----------------------------------------------------------------------===//
../../local/executable_library.h://===----------------------------------------------------------------------===//
../../local/executable_library.h:// architecture-specific dispatch routines. Some environmental properties may
../../local/executable_library.h:// change per-invocation such as the CPU info when performing dispatches on
../../local/executable_library.h://===----------------------------------------------------------------------===//
../../local/executable_library.h://===----------------------------------------------------------------------===//
../../local/executable_library.h:// Returns 0 on success and non-zero on failure. Failures will cause device loss
../../local/executable_library.h:// caught and only that they are not harmful - clamping byte ranges and never
../../local/executable_library.h:// To enable linker isolation, ABI shimming, and import multi-versioning we use
../../local/executable_library.h:// this import table exclusively and do not allow platform-level linking. If it
../../local/executable_library.h:// have the platform-dependent ABI (Windows, MacOS, etc), and may not be
../../local/executable_library.h:// available at all (bare-metal).
../../local/executable_library.h:// and symbol availability is known during build-time linking. Static linking
../../local/executable_library.h:// Represented as a struct-of-arrays for more efficient packing and more
../../local/executable_library.h:// locality during lookup. Each subarray - when not omitted and NULL - is
../../local/executable_library.h:  //     Function-specified version number used to allow multiple versions to
../../local/executable_library.h:// Architecture-specific CPU information available to executables.
../../local/executable_library.h:// The format of the data is architecture-specific as by construction no value
../../local/executable_library.h:  // Opaque architecture-specific encoding in 64-bit words.
../../local/executable_library.h:  // This may represent a fixed-length data structure, a series of hardware
../../local/executable_library.h:  // registers, or key-value pairs.
../../local/executable_library.h:  // The contents are opaque here as to support out-of-tree architectures. The
../../local/executable_library.h:              "8-byte alignment required");
../../local/executable_library.h:// operating environments (Linux, Mac, bare-metal, web, etc) by not having
../../local/executable_library.h:// platform-specific syscalls and register query emulation.
../../local/executable_library.h:  // Optional architecture-specific CPU information.
../../local/executable_library.h:// Read-only per-dispatch state passed to each workgroup in a dispatch.
../../local/executable_library.h:// (on archs with 64-bit pointers; 32-bit fits in a single line).
../../local/executable_library.h:// For workgroup dimensions we allow the full 32-bit range on X and Y as those
../../local/executable_library.h:// usually in the 1-16 range; any higher and it can pessimize scheduling. Almost
../../local/executable_library.h:  // used (known at compile-time).
../../local/executable_library.h:  // to ensure cache-friendly behavior. The first instructions every dispatch
../../local/executable_library.h:  // cache misses. Less-frequently used fields can follow.
../../local/executable_library.h:// Read-only per-workgroup state passed to each workgroup in a dispatch.
../../local/executable_library.h:// (on archs with 64-bit pointers; 32-bit fits in a single line).
../../local/executable_library.h:  // This is in the range of 0-workgroup_count and each unique workgroup is to
../../local/executable_library.h:  // (8-bits, or 16-bit for single-node thousand-core future proofing).
../../local/executable_library.h:  // Requires a non-zero value to be specified for |local_memory_pages|; at
../../local/executable_library.h:// Returns 0 on success and non-zero on failure. Failures will cause device loss
../../local/executable_library.h:// caught and only that they are not harmful - clamping byte ranges and never
../../local/executable_library.h:// executed. 0 defaults are well-specified and the entire attributes table may
../../local/executable_library.h:  // Total number of 32-bit constants used by the dispatch.
../../local/executable_library.h:  // The path (absolute or relative) to the source file, NUL-terminated.
../../local/executable_library.h:  // Names identifying the locations 1:1 with the locations set, NUL-terminated.
../../local/executable_library.h:// A table of exported functions arranged as a struct-of-arrays for more
../../local/executable_library.h:// efficient packing and faster lookup. Each subarray - when not omitted and
../../local/executable_library.h:// NULL - is indexed by export ordinal and has up to |count| entries.
../../local/executable_library.h:  // Used to describe the entry point in a human-readable format useful for
../../local/executable_library.h:// A table declaring the executable-level constants that can be used to
../../local/executable_library.h:  // The path (absolute or relative) of the source file, NUL-terminated.
../../local/executable_library.h:// The entire structure is designed to be read-only and able to live embedded in
../../local/executable_library.h:// members at runtime so long as they observe the thread-safety guarantees.
../../local/executable_library.h:  // Table of executable-level constants.
../../local/executable_library_demo.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/executable_library_demo.c:// WARNING: these functions must not access mutable global state: read-only data
../../local/executable_library_demo.c:      (const dispatch_tile_a_constants_t*)dispatch_state->constants;
../../local/executable_library_demo.c:  const float* src = ((const float*)dispatch_state->binding_ptrs[0]);
../../local/executable_library_demo.c:  float* dst = ((float*)dispatch_state->binding_ptrs[1]);
../../local/executable_library_demo.c:  const uint32_t x = workgroup_state->workgroup_id_x;
../../local/executable_library_demo.c:  dst[x] = src[x] + constants->f0;
../../local/executable_library_demo.c:// The table can be omitted if no attributes are non-zero. We don't use
../../local/executable_library_demo.c:// architecture-specific version.
../../local/executable_library_benchmark.md:---
../../local/executable_library_benchmark.md:Use `iree/hal/local/executable_library_benchmark --help` for more information.
../../local/executable_library_benchmark.md:the fusion is compiler-driven this can be tricky to ensure.
../../local/executable_library_benchmark.md:ever-changing, and unfriendly for a reason!
../../local/executable_library_benchmark.md:---
../../local/executable_library_benchmark.md:    --executable_format=embedded-elf \
../../local/executable_library_benchmark.md:    --executable_file=iree/hal/local/elf/testdata/elementwise_mul_x86_64.so \
../../local/executable_library_benchmark.md:    --entry_point=0 \
../../local/executable_library_benchmark.md:    --workgroup_count_x=1 \
../../local/executable_library_benchmark.md:    --workgroup_count_y=1 \
../../local/executable_library_benchmark.md:    --workgroup_count_z=1 \
../../local/executable_library_benchmark.md:    --workgroup_size_x=1 \
../../local/executable_library_benchmark.md:    --workgroup_size_y=1 \
../../local/executable_library_benchmark.md:    --workgroup_size_z=1 \
../../local/executable_library_benchmark.md:    --binding=4xf32=1,2,3,4 \
../../local/executable_library_benchmark.md:    --binding=4xf32=100,200,300,400 \
../../local/executable_library_benchmark.md:    --binding=4xf32=0,0,0,0
../../local/executable_library_benchmark.md:---------------------------------------------------------------------------------------------
../../local/executable_library_benchmark.md:---------------------------------------------------------------------------------------------
../../local/executable_library_benchmark.md:---
../../local/executable_library_benchmark.md:iree/hal/local/executable_library_benchmark --flagfile=my_flags.txt
../../local/executable_library_benchmark.md:For an example, the flags for an x86-64 run of a simple element-wise multiply:
../../local/executable_library_benchmark.md:iree/hal/local/executable_library_benchmark --flagfile=iree/hal/local/testdata/elementwise_mul_benchmark.txt
../../local/executable_library_benchmark.md:---
../../local/executable_library_benchmark.md:1. Hand-author a `hal.executable.source` op or extract a `hal.executable`
../../local/executable_library_benchmark.md:iree-compile \
../../local/executable_library_benchmark.md:    --compile-mode=hal-executable \
../../local/executable_library_benchmark.md:    -o=elementwise_mul.so \
../../local/executable_library_benchmark.md:    --iree-hal-target-device=local \
../../local/executable_library_benchmark.md:    --iree-hal-local-target-device-backends=llvm-cpu \
../../local/executable_library_benchmark.md:    --iree-llvmcpu-debug-symbols=false \
../../local/executable_library_benchmark.md:    --iree-llvmcpu-target-triple=x86_64-pc-linux-elf
../../local/executable_library_benchmark.md:---
../../local/executable_library_benchmark.md:`--entry_point=` flag to select the executable. It's important to remember that
../../local/executable_library_benchmark.md:compiler and subject to change at any time - when using this approach one must
../../local/executable_library_benchmark.md:iree-compile \
../../local/executable_library_benchmark.md:    --iree-input-type=stablehlo \
../../local/executable_library_benchmark.md:    -o=module.vmfb \
../../local/executable_library_benchmark.md:    --iree-hal-target-device=local \
../../local/executable_library_benchmark.md:    --iree-hal-local-target-device-backends=llvm-cpu \
../../local/executable_library_benchmark.md:    --iree-llvmcpu-debug-symbols=false \
../../local/executable_library_benchmark.md:    --iree-llvmcpu-target-triple=x86_64-pc-linux-elf \
../../local/executable_library_benchmark.md:    --mlir-print-ir-after-all \
../../local/executable_library_benchmark.md:--executable_format=embedded-elf
../../local/executable_library_benchmark.md:--executable_file=_simple_mul_dispatch_0_llvm_binary_ex_elf.so
../../local/executable_library_benchmark.md:--entry_point=1
../../local/executable_library_benchmark.md:--workgroup_count_x=5
../../local/executable_library_benchmark.md:--workgroup_count_y=6
../../local/executable_library_benchmark.md:--workgroup_count_z=7
../../local/executable_library_benchmark.md:--binding=16xi8
../../local/executable_library_benchmark.md:--binding=16xi8
../../local/executable_library_benchmark.md:--binding=16xi8
../../local/executable_library_benchmark.md:--binding=4xf32=1,2,3,4
../../local/executable_library_benchmark.md:--binding=4xf32=100,200,300,400
../../local/executable_library_benchmark.md:--binding=4xf32=0,0,0,0
../../local/executable_library_benchmark.md:**Note that multiple tensors may alias to a single binding** - including
../../local/executable_library_benchmark.md:non-constant. This microbenchmarking approach is not generally suited for
../../local/executable_library_benchmark.md:--constant=1
../../local/executable_library_benchmark.md:--constant=2
../../local/executable_library_benchmark.md:--constant=3
../../local/executable_library_benchmark.md:--constant=4
../../local/executable_loader.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/executable_loader.c:  iree_atomic_ref_count_init(&out_base_loader->ref_count);
../../local/executable_loader.c:  out_base_loader->vtable = vtable;
../../local/executable_loader.c:  out_base_loader->import_provider = import_provider;
../../local/executable_loader.c:    iree_atomic_ref_count_inc(&executable_loader->ref_count);
../../local/executable_loader.c:      iree_atomic_ref_count_dec(&executable_loader->ref_count) == 1) {
../../local/executable_loader.c:    executable_loader->vtable->destroy(executable_loader);
../../local/executable_loader.c:  return executable_loader->vtable->query_support(
../../local/executable_loader.c:  IREE_ASSERT_ARGUMENT(!executable_params->executable_data.data_length ||
../../local/executable_loader.c:                       executable_params->executable_data.data);
../../local/executable_loader.c:  return executable_loader->vtable->try_load(
../../local/local_executable_cache.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/local_executable_cache.h:// or inproc_lru_executable_cache (simple in-memory LRU of recent executables).
../../local/local_executable_cache.h:// one device is the same JIT'ed executable in another, and in multi-tenant
../../driver.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../driver.c:  // Split the parameter string into a list of key-value pairs.
../../local/elf/fatelf.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/elf/fatelf.h:// https://raw.githubusercontent.com/icculus/fatelf/main/docs/fatelf-specification.txt
../../local/elf/fatelf.h:// should be compatible with the original fatelf-* tools.
../../local/elf/fatelf.h://   iree-fatelf join elf_a.so elf_b.so elf_c.so > fatelf.sos
../../local/elf/fatelf.h://   iree-fatelf split fatelf.sos
../../local/elf/fatelf.h:// Little-endian magic bytes used to identify FatELF files.
../../local/elf/fatelf.h:  IREE_FATELF_BYTE_ORDER_MSB = 0,  // IREE_ELF_ELFDATA2MSB - big-endian
../../local/elf/fatelf.h:  IREE_FATELF_BYTE_ORDER_LSB = 1,  // IREE_ELF_ELFDATA2LSB - little-endian
../../local/elf/fatelf.h:// This has some of the fields from the iree_elf_ehdr_t and references a header-
../../local/executable_loader.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/executable_loader.h://===----------------------------------------------------------------------===//
../../local/executable_loader.h://===----------------------------------------------------------------------===//
../../local/executable_loader.h:// Interface used to resolve executable imports at load-time.
../../local/executable_loader.h:  // User-defined pointer passed to all functions.
../../local/executable_loader.h://===----------------------------------------------------------------------===//
../../local/executable_loader.h://===----------------------------------------------------------------------===//
../../local/executable_loader.h:// Thread-safe - multiple threads may load executables (including the *same*
../../local/executable_loader.h://===----------------------------------------------------------------------===//
../../local/executable_loader.h://===----------------------------------------------------------------------===//
../../local/elf/elf_module_test_main.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/elf/elf_module_test_main.c:      if (iree_string_view_match_pattern(iree_make_cstring_view(file_toc->name),
../../local/elf/elf_module_test_main.c:            iree_make_const_byte_span(file_toc->data, file_toc->size);
../../local/elf/elf_module_test_main.c:                          "no architecture-specific ELF binary embedded into "
../../local/elf/elf_module_test_main.c:  if (header->version != IREE_HAL_EXECUTABLE_LIBRARY_VERSION_LATEST) {
../../local/elf/elf_module_test_main.c:  if (strncmp(header->name, "ex", strlen(header->name)) != 0) {
../../local/elf/elf_module_test_main.c:  if (library.v0->exports.count != 1) {
../../local/elf/elf_module_test_main.c:  int ret = iree_elf_call_i_ppp((const void*)library.v0->exports.ptrs[0],
../../local/elf/arch.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/elf/arch.h:// Applies architecture-specific relocations.
../../local/elf/arch.h:// Cross-ABI function calls
../../local/elf/arch.h:// Host -> ELF: void(*)(void)
../../local/elf/arch.h:// Host -> ELF: void*(*)(int)
../../local/elf/arch.h:// Host -> ELF: void*(*)(int, void*)
../../local/elf/arch.h:// Host -> ELF: int(*)(void*)
../../local/elf/arch.h:// Host -> ELF: int(*)(void*, void*, void*)
../../local/elf/arch.h:// Host -> ELF: void*(*)(void*, void*, void*)
../../local/elf/arch.h:// ELF -> Host: int(*)(void*, void*, void*)
../../local/elf/CMakeLists.txt:# CMake-only content.                                                          #
../../local/plugins/embedded_elf_plugin.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/plugins/embedded_elf_plugin.h:// in-memory |buffer|. The plugin will be loaded and verified for compatibility.
../../local/plugins/embedded_elf_plugin.h:// Optionally key-value parameters may be provided to the plugin on
../../local/plugins/BUILD.bazel:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/elf/elf_module.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/plugins/embedded_elf_plugin.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/plugins/embedded_elf_plugin.c://===----------------------------------------------------------------------===//
../../local/plugins/embedded_elf_plugin.c://===----------------------------------------------------------------------===//
../../local/plugins/embedded_elf_plugin.c:  plugin->host_allocator = host_allocator;
../../local/plugins/embedded_elf_plugin.c:      buffer, /*import_table=*/NULL, host_allocator, &plugin->module);
../../local/plugins/embedded_elf_plugin.c:        &plugin->module, IREE_HAL_EXECUTABLE_PLUGIN_EXPORT_NAME,
../../local/plugins/embedded_elf_plugin.c:        host_allocator, &plugin->base);
../../local/plugins/embedded_elf_plugin.c:  iree_allocator_t host_allocator = plugin->host_allocator;
../../local/plugins/embedded_elf_plugin.c:  iree_elf_module_deinitialize(&plugin->module);
../../local/plugins/embedded_elf_plugin.c://===----------------------------------------------------------------------===//
../../local/plugins/embedded_elf_plugin.c://===----------------------------------------------------------------------===//
../../local/plugins/embedded_elf_plugin.c:  plugin->host_allocator = host_allocator;
../../local/plugins/embedded_elf_plugin.c:  plugin->file_contents = file_contents;
../../local/plugins/embedded_elf_plugin.c:      file_contents->const_buffer, /*import_table=*/NULL, host_allocator,
../../local/plugins/embedded_elf_plugin.c:      &plugin->module);
../../local/plugins/embedded_elf_plugin.c:        &plugin->module, IREE_HAL_EXECUTABLE_PLUGIN_EXPORT_NAME,
../../local/plugins/embedded_elf_plugin.c:        host_allocator, &plugin->base);
../../local/plugins/embedded_elf_plugin.c:  iree_allocator_t host_allocator = plugin->host_allocator;
../../local/plugins/embedded_elf_plugin.c:  iree_elf_module_deinitialize(&plugin->module);
../../local/plugins/embedded_elf_plugin.c:  iree_io_file_contents_free(plugin->file_contents);
../../local/plugins/system_library_plugin.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/plugins/system_library_plugin.c:  plugin->host_allocator = host_allocator;
../../local/plugins/system_library_plugin.c:  plugin->handle = handle;
../../local/plugins/system_library_plugin.c:  iree_dynamic_library_retain(plugin->handle);
../../local/plugins/system_library_plugin.c:      /*resolve_thunk=*/NULL, host_allocator, &plugin->base);
../../local/plugins/system_library_plugin.c:  iree_allocator_t host_allocator = plugin->host_allocator;
../../local/plugins/system_library_plugin.c:  iree_dynamic_library_release(plugin->handle);
../../local/plugins/CMakeLists.txt:# CMake-only content.                                                          #
../../local/plugins/static_plugin.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/plugins/static_plugin.h:// Creates a statically-declared executable import plugin available from the
../../local/plugins/static_plugin.h:// Optionally key-value parameters may be provided to the plugin on
../../local/executable_environment.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/executable_environment.h://===----------------------------------------------------------------------===//
../../local/executable_environment.h://===----------------------------------------------------------------------===//
../../local/plugins/system_library_plugin.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/plugins/system_library_plugin.h:// in-memory |buffer|. The plugin will be loaded and verified for compatibility.
../../local/plugins/system_library_plugin.h:// The system-provided loader will be used and symbols may be resolved outside
../../local/plugins/system_library_plugin.h:// allocators (but shouldn't!) and have other massively side-effecting behavior.
../../local/plugins/system_library_plugin.h:// Optionally key-value parameters may be provided to the plugin on
../../local/elf/platform.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/elf/platform.h://===----------------------------------------------------------------------===//
../../local/elf/platform.h://===----------------------------------------------------------------------===//
../../local/elf/platform.h:// fail-safe mechanism only.
../../local/elf/platform.h://  https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect
../../local/elf/platform.h://  https://man7.org/linux/man-pages/man2/mprotect.2.html
../../local/elf/fatelf.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/elf/fatelf.c:  // NOTE: header is always in little-endian so we have to use our utilities to
../../local/elf/fatelf.c:  // be portable. We don't actually care about big-endian platforms but this
../../local/elf/fatelf.c:      .magic = iree_unaligned_load_le_u32(&raw_header->magic),
../../local/elf/fatelf.c:      .version = iree_unaligned_load_le_u16(&raw_header->version),
../../local/elf/fatelf.c:      .record_count = iree_unaligned_load_le_u8(&raw_header->record_count),
../../local/elf/fatelf.c:      .reserved = iree_unaligned_load_le_u8(&raw_header->reserved),
../../local/elf/fatelf.c:    const iree_fatelf_record_t* raw_record = &raw_header->records[i];
../../local/elf/fatelf.c:        .machine = iree_unaligned_load_le_u16(&raw_record->machine),
../../local/elf/fatelf.c:        .osabi = iree_unaligned_load_le_u8(&raw_record->osabi),
../../local/elf/fatelf.c:        .osabi_version = iree_unaligned_load_le_u8(&raw_record->osabi_version),
../../local/elf/fatelf.c:        .word_size = iree_unaligned_load_le_u8(&raw_record->word_size),
../../local/elf/fatelf.c:        .byte_order = iree_unaligned_load_le_u8(&raw_record->byte_order),
../../local/elf/fatelf.c:        .reserved0 = iree_unaligned_load_le_u8(&raw_record->reserved0),
../../local/elf/fatelf.c:        .reserved1 = iree_unaligned_load_le_u8(&raw_record->reserved1),
../../local/elf/fatelf.c:        .offset = iree_unaligned_load_le_u64(&raw_record->offset),
../../local/elf/fatelf.c:        .size = iree_unaligned_load_le_u64(&raw_record->size),
../../local/elf/fatelf.c:  // Bounds check the file range - the caller expects valid pointers.
../../local/elf/fatelf.c:        "ELF file range out of bounds; %" PRIu64 "-%" PRIu64 " (%" PRIu64
../../local/elf/fatelf.c:        selected_offset, selected_offset + selected_size - 1, selected_size,
../../local/elf/elf_types.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/elf/elf_types.h://   third_party/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
../../local/elf/elf_types.h://   https://refspecs.linuxbase.org/LSB_3.1.1/LSB-Core-generic/LSB-Core-generic.html
../../local/elf/elf_types.h:// We define both 32-bit and 64-bit variants of the structures as we support
../../local/elf/elf_types.h:// architecture-native integer width.
../../local/elf/elf_types.h:  IREE_ELF_ELFCLASS32 = 1,    // 32-bit objects
../../local/elf/elf_types.h:  IREE_ELF_ELFCLASS64 = 2,    // 64-bit objects
../../local/elf/elf_types.h:  IREE_ELF_ELFDATA2LSB = 1,  // Little-endian
../../local/elf/elf_types.h:  IREE_ELF_ELFDATA2MSB = 2,  // Big-endian
../../local/elf/elf_types.h:#error "unsupported ELF N size (only 32/64-bits are defined)"
../../local/plugins/registration/CMakeLists.txt:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/plugins/registration/BUILD.bazel:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/plugins/registration/BUILD.bazel:    "embedded-elf",
../../local/plugins/registration/BUILD.bazel:    "system-library",
../../local/plugins/registration/BUILD.bazel:        "embedded-elf",
../../local/plugins/registration/BUILD.bazel:        "system-library",
../../local/plugins/registration/BUILD.bazel:        ":embedded-elf_enabled": ["//runtime/src/iree/hal/local/plugins:embedded_elf_plugin"],
../../local/plugins/registration/BUILD.bazel:        ":system-library_enabled": ["//runtime/src/iree/hal/local/plugins:system_library_plugin"],
../../local/plugins/registration/init.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/plugins/registration/init.h:// --executable_plugin= flag list. Fails if any declared plugin cannot be
../../local/plugins/registration/init.h:// Registers all plugins in the --executable_plugin= flag list. Fails if any
../../local/plugins/registration/init.h:// --executable_plugin=. This allows for binding layers to load plugins
../../local/plugins/registration/init.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/plugins/registration/init.c:    "  --executable_plugin=some/system.dll\n"
../../local/plugins/registration/init.c:    "  --executable_plugin=some/standalone.sos\n"
../../local/plugins/registration/init.c:    "  --executable_plugin=embedded:some/standalone.so");
../../local/elf/BUILD.bazel:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/elf/BUILD.bazel:#===------------------------------------------------------------------------===#
../../local/elf/BUILD.bazel:#===------------------------------------------------------------------------===#
../../local/elf/BUILD.bazel:#===------------------------------------------------------------------------===#
../../local/elf/BUILD.bazel:#===------------------------------------------------------------------------===#
../../local/elf/elf_module.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/elf/elf_module.c:  if (memcmp(ehdr->e_ident, elf_magic, sizeof(elf_magic)) != 0) {
../../local/elf/elf_module.c:  // endianness determines how multi-byte fields are interpreted.
../../local/elf/elf_module.c:  if (ehdr->e_ident[IREE_ELF_EI_CLASS] != IREE_ELF_ELFCLASS32) {
../../local/elf/elf_module.c:                            "system/ELF class mismatch: expected 32-bit");
../../local/elf/elf_module.c:  if (ehdr->e_ident[IREE_ELF_EI_CLASS] != IREE_ELF_ELFCLASS64) {
../../local/elf/elf_module.c:                            "system/ELF class mismatch: expected 64-bit");
../../local/elf/elf_module.c:  if (ehdr->e_ident[IREE_ELF_EI_DATA] != IREE_ELF_ELFDATA2LSB) {
../../local/elf/elf_module.c:        "system/ELF endianness mismatch: expected little-endian");
../../local/elf/elf_module.c:  if (ehdr->e_ident[IREE_ELF_EI_DATA] != IREE_ELF_ELFDATA2MSB) {
../../local/elf/elf_module.c:        "system/ELF endianness mismatch: expected big-endian");
../../local/elf/elf_module.c:  if (ehdr->e_version != 1) {
../../local/elf/elf_module.c:  if (!iree_elf_machine_is_valid(ehdr->e_machine)) {
../../local/elf/elf_module.c:        (uint32_t)ehdr->e_machine);
../../local/elf/elf_module.c:  // We could probably support non-shared object types but no need today and it
../../local/elf/elf_module.c:  if (ehdr->e_type != IREE_ELF_ET_DYN) {
../../local/elf/elf_module.c:  // Sanity checks on entity sizes - they can be larger than what we expect,
../../local/elf/elf_module.c:  // array-style accesses to scale out based on the ehdr values
../../local/elf/elf_module.c:  if (ehdr->e_ehsize != sizeof(iree_elf_ehdr_t) ||
../../local/elf/elf_module.c:      ehdr->e_phentsize != sizeof(iree_elf_phdr_t) ||
../../local/elf/elf_module.c:      ehdr->e_shentsize != sizeof(iree_elf_shdr_t)) {
../../local/elf/elf_module.c:  if (ehdr->e_phoff == 0 || ehdr->e_phnum == 0 ||
../../local/elf/elf_module.c:      (ehdr->e_phoff + ehdr->e_phnum * ehdr->e_phentsize) >
../../local/elf/elf_module.c:  if (ehdr->e_shoff == 0 || ehdr->e_shnum == 0 ||
../../local/elf/elf_module.c:      (ehdr->e_shoff + ehdr->e_shnum * ehdr->e_shentsize) >
../../local/elf/elf_module.c:// Verifies the phdr table for supported types and in-bounds file references.
../../local/elf/elf_module.c:  for (iree_elf_half_t i = 0; i < load_state->ehdr->e_phnum; ++i) {
../../local/elf/elf_module.c:    const iree_elf_phdr_t* phdr = &load_state->phdr_table[i];
../../local/elf/elf_module.c:    if (phdr->p_type != IREE_ELF_PT_LOAD) continue;
../../local/elf/elf_module.c:    if (phdr->p_offset + phdr->p_filesz > raw_data.data_length) {
../../local/elf/elf_module.c:                              "-%" PRIu64 "of max %" PRIu64,
../../local/elf/elf_module.c:                              (uint64_t)phdr->p_offset,
../../local/elf/elf_module.c:                              (uint64_t)(phdr->p_offset + phdr->p_filesz),
../../local/elf/elf_module.c:  out_load_state->memory_info = iree_memory_query_info();
../../local/elf/elf_module.c:      (const iree_elf_phdr_t*)(raw_data.data + ehdr->e_phoff);
../../local/elf/elf_module.c:      (const iree_elf_shdr_t*)(raw_data.data + ehdr->e_shoff);
../../local/elf/elf_module.c:  out_load_state->ehdr = ehdr;
../../local/elf/elf_module.c:  out_load_state->phdr_table = phdr_table;
../../local/elf/elf_module.c:  out_load_state->shdr_table = shdr_table;
../../local/elf/elf_module.c:// Calculates the in-memory layout of the ELF module as defined by its segments.
../../local/elf/elf_module.c:  for (iree_elf_half_t i = 0; i < load_state->ehdr->e_phnum; ++i) {
../../local/elf/elf_module.c:    const iree_elf_phdr_t* phdr = &load_state->phdr_table[i];
../../local/elf/elf_module.c:    if (phdr->p_type != IREE_ELF_PT_LOAD) continue;
../../local/elf/elf_module.c:        iree_page_align_start(phdr->p_vaddr, phdr->p_align);
../../local/elf/elf_module.c:        iree_page_align_end(phdr->p_vaddr + phdr->p_memsz, phdr->p_align);
../../local/elf/elf_module.c:      .length = (iree_host_size_t)(vaddr_max - vaddr_min),
../../local/elf/elf_module.c:  // Calculate the total internally-aligned vaddr range.
../../local/elf/elf_module.c:  module->vaddr_size = iree_page_align_end(
../../local/elf/elf_module.c:      vaddr_range.length, load_state->memory_info.normal_page_size);
../../local/elf/elf_module.c:      IREE_MEMORY_VIEW_FLAG_MAY_EXECUTE, module->vaddr_size,
../../local/elf/elf_module.c:      module->host_allocator, (void**)&module->vaddr_base));
../../local/elf/elf_module.c:  module->vaddr_bias = module->vaddr_base - vaddr_range.offset;
../../local/elf/elf_module.c:  for (iree_elf_half_t i = 0; i < load_state->ehdr->e_phnum; ++i) {
../../local/elf/elf_module.c:    const iree_elf_phdr_t* phdr = &load_state->phdr_table[i];
../../local/elf/elf_module.c:    if (phdr->p_type != IREE_ELF_PT_LOAD) continue;
../../local/elf/elf_module.c:        .offset = phdr->p_vaddr,
../../local/elf/elf_module.c:        .length = phdr->p_memsz,
../../local/elf/elf_module.c:        module->vaddr_bias, 1, &byte_range,
../../local/elf/elf_module.c:    // a mapped file - if it is, we can remap the page and directly reference it
../../local/elf/elf_module.c:    // here for read-only segments and setup copy-on-write for writeable ones.
../../local/elf/elf_module.c:    if (phdr->p_filesz > 0) {
../../local/elf/elf_module.c:      memcpy(module->vaddr_bias + phdr->p_vaddr, raw_data.data + phdr->p_offset,
../../local/elf/elf_module.c:             phdr->p_filesz);
../../local/elf/elf_module.c:    // NOTE: p_memsz may be larger than p_filesz - if so, the extra memory bytes
../../local/elf/elf_module.c:    // so this is a no-op.
../../local/elf/elf_module.c:    // we can go back through and remove write access from read-only/executable
../../local/elf/elf_module.c:// This will make pages read-only and must only be performed after relocation
../../local/elf/elf_module.c:  for (iree_elf_half_t i = 0; i < load_state->ehdr->e_phnum; ++i) {
../../local/elf/elf_module.c:    const iree_elf_phdr_t* phdr = &load_state->phdr_table[i];
../../local/elf/elf_module.c:    if (phdr->p_type != IREE_ELF_PT_LOAD) continue;
../../local/elf/elf_module.c:    // permissions. See Table 7-37:
../../local/elf/elf_module.c:    // https://docs.oracle.com/cd/E19683-01/816-1386/6m7qcoblk/index.html#chapter6-34713
../../local/elf/elf_module.c:    if (phdr->p_flags & IREE_ELF_PF_R) access |= IREE_MEMORY_ACCESS_READ;
../../local/elf/elf_module.c:    if (phdr->p_flags & IREE_ELF_PF_W) access |= IREE_MEMORY_ACCESS_WRITE;
../../local/elf/elf_module.c:    if (phdr->p_flags & IREE_ELF_PF_X) access |= IREE_MEMORY_ACCESS_EXECUTE;
../../local/elf/elf_module.c:    if ((phdr->p_flags & IREE_ELF_PF_X) && (phdr->p_flags & IREE_ELF_PF_W)) {
../../local/elf/elf_module.c:        .offset = phdr->p_vaddr,
../../local/elf/elf_module.c:        .length = phdr->p_memsz,
../../local/elf/elf_module.c:    IREE_RETURN_IF_ERROR(iree_memory_view_protect_ranges(module->vaddr_bias, 1,
../../local/elf/elf_module.c:      iree_memory_flush_icache(module->vaddr_bias + phdr->p_vaddr,
../../local/elf/elf_module.c:                               phdr->p_memsz);
../../local/elf/elf_module.c:  // PT_GNU_RELRO: hardening of post-relocation segments.
../../local/elf/elf_module.c:  for (iree_elf_half_t i = 0; i < load_state->ehdr->e_phnum; ++i) {
../../local/elf/elf_module.c:    const iree_elf_phdr_t* phdr = &load_state->phdr_table[i];
../../local/elf/elf_module.c:    if (phdr->p_type != IREE_ELF_PT_GNU_RELRO) continue;
../../local/elf/elf_module.c:        .offset = phdr->p_vaddr,
../../local/elf/elf_module.c:        .length = phdr->p_memsz,
../../local/elf/elf_module.c:        module->vaddr_bias, 1, &byte_range, IREE_MEMORY_ACCESS_READ));
../../local/elf/elf_module.c:  if (module->vaddr_base != NULL) {
../../local/elf/elf_module.c:    iree_memory_view_release(module->vaddr_base, module->vaddr_size,
../../local/elf/elf_module.c:                             module->host_allocator);
../../local/elf/elf_module.c:  module->vaddr_base = NULL;
../../local/elf/elf_module.c:  module->vaddr_bias = NULL;
../../local/elf/elf_module.c:  module->vaddr_size = 0;
../../local/elf/elf_module.c:  for (iree_elf_half_t i = 0; i < load_state->ehdr->e_phnum; ++i) {
../../local/elf/elf_module.c:    const iree_elf_phdr_t* phdr = &load_state->phdr_table[i];
../../local/elf/elf_module.c:    if (phdr->p_type == IREE_ELF_PT_DYNAMIC) {
../../local/elf/elf_module.c:      dyn_table = (const iree_elf_dyn_t*)(module->vaddr_bias + phdr->p_vaddr);
../../local/elf/elf_module.c:      dyn_table_count = phdr->p_filesz / sizeof(iree_elf_dyn_t);
../../local/elf/elf_module.c:  load_state->dyn_table = dyn_table;
../../local/elf/elf_module.c:  load_state->dyn_table_count = dyn_table_count;
../../local/elf/elf_module.c:    switch (dyn->d_tag) {
../../local/elf/elf_module.c:        module->dynstr = (const char*)(module->vaddr_bias + dyn->d_un.d_ptr);
../../local/elf/elf_module.c:        module->dynstr_size = dyn->d_un.d_val;
../../local/elf/elf_module.c:        module->dynsym =
../../local/elf/elf_module.c:            (const iree_elf_sym_t*)(module->vaddr_bias + dyn->d_un.d_ptr);
../../local/elf/elf_module.c:        if (dyn->d_un.d_val != sizeof(iree_elf_sym_t)) {
../../local/elf/elf_module.c:            (const iree_elf_word_t*)(module->vaddr_bias + dyn->d_un.d_ptr);
../../local/elf/elf_module.c:        module->dynsym_count = hash[1];  // symbol count, obviously~
../../local/elf/elf_module.c:        load_state->init = dyn->d_un.d_ptr;
../../local/elf/elf_module.c:        load_state->init_array =
../../local/elf/elf_module.c:            (const iree_elf_addr_t*)(module->vaddr_bias + dyn->d_un.d_ptr);
../../local/elf/elf_module.c:        load_state->init_array_count = dyn->d_un.d_val;
../../local/elf/elf_module.c:        if (dyn->d_un.d_val != sizeof(iree_elf_rel_t)) {
../../local/elf/elf_module.c:        if (dyn->d_un.d_val != sizeof(iree_elf_rela_t)) {
../../local/elf/elf_module.c:  if (!module->dynstr || !module->dynstr_size || !module->dynsym ||
../../local/elf/elf_module.c:      !module->dynsym_count) {
../../local/elf/elf_module.c:  // space - this is the least of your concerns :)
../../local/elf/elf_module.c:  for (iree_host_size_t i = 1; i < module->dynsym_count; ++i) {
../../local/elf/elf_module.c:    const iree_elf_sym_t* sym = &module->dynsym[i];
../../local/elf/elf_module.c:    if (sym->st_shndx == IREE_ELF_SHN_UNDEF) {
../../local/elf/elf_module.c:          sym->st_name ? module->dynstr + sym->st_name : NULL;
../../local/elf/elf_module.c:                              "platform-agnostic loader",
../../local/elf/elf_module.c:  // Redirect to the architecture-specific handler.
../../local/elf/elf_module.c:  reloc_state.vaddr_bias = module->vaddr_bias;
../../local/elf/elf_module.c:  reloc_state.dyn_table = load_state->dyn_table;
../../local/elf/elf_module.c:  reloc_state.dyn_table_count = load_state->dyn_table_count;
../../local/elf/elf_module.c:  reloc_state.dynsym = module->dynsym;
../../local/elf/elf_module.c:  reloc_state.dynsym_count = module->dynsym_count;
../../local/elf/elf_module.c:  if (load_state->init != IREE_ELF_ADDR_MIN) {
../../local/elf/elf_module.c:    iree_elf_call_v_v((void*)(module->vaddr_bias + load_state->init));
../../local/elf/elf_module.c:  // NOTE: entries with values of 0 or -1 must be ignored.
../../local/elf/elf_module.c:  for (iree_host_size_t i = 0; i < load_state->init_array_count; ++i) {
../../local/elf/elf_module.c:    iree_elf_addr_t symbol_ptr = load_state->init_array[i];
../../local/elf/elf_module.c:    iree_elf_call_v_v((void*)(module->vaddr_bias + symbol_ptr));
../../local/elf/elf_module.c:// specified using --hash-style=sysv with ld/lld. By default most linkers
../../local/elf/elf_module.c:// --hash-style=both and emit both `.hash` and `.gnu.hash`, but that's silly for
../../local/elf/elf_module.c:// https://docs.oracle.com/cd/E23824_01/html/819-0690/chapter6-48031.html
../../local/elf/elf_module.c:// https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2
../../local/elf/elf_module.c:  for (int i = (int)module->dynsym_count - 1; i > 0; i--) {
../../local/elf/elf_module.c:    const iree_elf_sym_t* sym = &module->dynsym[i];
../../local/elf/elf_module.c:    iree_elf_byte_t bind = IREE_ELF_ST_BIND(sym->st_info);
../../local/elf/elf_module.c:    if (sym->st_name == 0) continue;
../../local/elf/elf_module.c:    if (strcmp(module->dynstr + sym->st_name, symbol_name) == 0) {
../../local/elf/elf_module.c:  out_module->host_allocator = host_allocator;
../../local/elf/elf_module.c:  *out_export = module->vaddr_bias + sym->st_value;
../../local/elf/arch/arm_64.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/elf/arch/arm_64.c:    uint32_t type = IREE_ELF_R_TYPE(rela->r_info);
../../local/elf/arch/arm_64.c:    uint32_t sym_ordinal = (uint32_t)IREE_ELF_R_SYM(rela->r_info);
../../local/elf/arch/arm_64.c:      if (sym_ordinal >= state->dynsym_count) {
../../local/elf/arch/arm_64.c:      sym_addr = (iree_elf_addr_t)state->vaddr_bias +
../../local/elf/arch/arm_64.c:                 state->dynsym[sym_ordinal].st_value;
../../local/elf/arch/arm_64.c:        (iree_elf_addr_t)state->vaddr_bias + rela->r_offset;
../../local/elf/arch/arm_64.c:        *(uint64_t*)instr_ptr += (uint64_t)(sym_addr + rela->r_addend);
../../local/elf/arch/arm_64.c:        *(uint64_t*)instr_ptr = (uint64_t)(sym_addr + rela->r_addend);
../../local/elf/arch/arm_64.c:        *(uint64_t*)instr_ptr = (uint64_t)(state->vaddr_bias + rela->r_addend);
../../local/elf/arch/arm_64.c:  for (iree_host_size_t i = 0; i < state->dyn_table_count; ++i) {
../../local/elf/arch/arm_64.c:    const iree_elf_dyn_t* dyn = &state->dyn_table[i];
../../local/elf/arch/arm_64.c:    switch (dyn->d_tag) {
../../local/elf/arch/arm_64.c:            (const iree_elf_rela_t*)(state->vaddr_bias + dyn->d_un.d_ptr);
../../local/elf/arch/arm_64.c:        rela_count = dyn->d_un.d_val / sizeof(iree_elf_rela_t);
../../local/elf/arch/arm_64.c:// Cross-ABI function calls
../../local/elf/testdata/CMakeLists.txt:# CMake-only content.                                                          #
../../local/elf/arch/x86_32.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/elf/arch/x86_32.c:// https://uclibc.org/docs/psABI-i386.pdf
../../local/elf/arch/x86_32.c:    uint32_t type = IREE_ELF_R_TYPE(rel->r_info);
../../local/elf/arch/x86_32.c:    uint32_t sym_ordinal = (uint32_t)IREE_ELF_R_SYM(rel->r_info);
../../local/elf/arch/x86_32.c:      if (sym_ordinal >= state->dynsym_count) {
../../local/elf/arch/x86_32.c:      sym_addr = (iree_elf_addr_t)state->vaddr_bias +
../../local/elf/arch/x86_32.c:                 state->dynsym[sym_ordinal].st_value;
../../local/elf/arch/x86_32.c:        (iree_elf_addr_t)state->vaddr_bias + rel->r_offset;
../../local/elf/arch/x86_32.c:        // case IREE_ELF_R_386_NONE: early-exit above
../../local/elf/arch/x86_32.c:        *(uint32_t*)instr_ptr += (uint32_t)state->vaddr_bias;
../../local/elf/arch/x86_32.c:        *(uint32_t*)instr_ptr += (uint32_t)(sym_addr - instr_ptr);
../../local/elf/arch/x86_32.c:  for (iree_host_size_t i = 0; i < state->dyn_table_count; ++i) {
../../local/elf/arch/x86_32.c:    const iree_elf_dyn_t* dyn = &state->dyn_table[i];
../../local/elf/arch/x86_32.c:    switch (dyn->d_tag) {
../../local/elf/arch/x86_32.c:            (const iree_elf_rel_t*)(state->vaddr_bias + dyn->d_un.d_ptr);
../../local/elf/arch/x86_32.c:        rel_count = dyn->d_un.d_val / sizeof(iree_elf_rel_t);
../../local/elf/arch/x86_32.c:// Cross-ABI function calls
../../local/elf/arch/x86_32.c:// https://uclibc.org/docs/psABI-i386.pdf
../../local/elf/arch/x86_32.c:// Non-volatile:
../../local/elf/platform/apple.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/elf/platform/apple.c:// NOTE: because Apple there's some hoop-jumping to get executable code.
../../local/elf/platform/apple.c:// https://developer.apple.com/documentation/apple-silicon/porting-just-in-time-compilers-to-apple-silicon
../../local/elf/platform/apple.c:// https://keith.github.io/xcode-man-pages/pthread_jit_write_protect_np.3.html
../../local/elf/platform/linux.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/elf/platform/linux.c:  void* base_address = mmap(NULL, total_length, mmap_prot, mmap_flags, -1, 0);
../../local/elf/platform/linux.c:        mmap(range_start, aligned_length, mmap_prot, mmap_flags, -1, 0);
../../local/elf/arch/x86_64.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/elf/arch/x86_64.c:// https://github.com/hjl-tools/x86-psABI/wiki/x86-64-psABI-1.0.pdf
../../local/elf/arch/x86_64.c:  IREE_ELF_R_X86_64_PC64 = 24,      // Place relative 64-bit signed
../../local/elf/arch/x86_64.c:    uint32_t type = IREE_ELF_R_TYPE(rela->r_info);
../../local/elf/arch/x86_64.c:    uint32_t sym_ordinal = (uint32_t)IREE_ELF_R_SYM(rela->r_info);
../../local/elf/arch/x86_64.c:      if (sym_ordinal >= state->dynsym_count) {
../../local/elf/arch/x86_64.c:      sym_addr = (iree_elf_addr_t)state->vaddr_bias +
../../local/elf/arch/x86_64.c:                 state->dynsym[sym_ordinal].st_value;
../../local/elf/arch/x86_64.c:        (iree_elf_addr_t)state->vaddr_bias + rela->r_offset;
../../local/elf/arch/x86_64.c:      // case IREE_ELF_R_X86_64_NONE: early-exit above
../../local/elf/arch/x86_64.c:        *(uint64_t*)instr_ptr = (uint64_t)(state->vaddr_bias + rela->r_addend);
../../local/elf/arch/x86_64.c:        *(uint64_t*)instr_ptr = (uint64_t)(sym_addr + rela->r_addend);
../../local/elf/arch/x86_64.c:        *(uint32_t*)instr_ptr = (uint32_t)(sym_addr + rela->r_addend);
../../local/elf/arch/x86_64.c:        *(int32_t*)instr_ptr = (int32_t)(sym_addr + rela->r_addend);
../../local/elf/arch/x86_64.c:            (uint32_t)(sym_addr + rela->r_addend - instr_ptr);
../../local/elf/arch/x86_64.c:  for (iree_host_size_t i = 0; i < state->dyn_table_count; ++i) {
../../local/elf/arch/x86_64.c:    const iree_elf_dyn_t* dyn = &state->dyn_table[i];
../../local/elf/arch/x86_64.c:    switch (dyn->d_tag) {
../../local/elf/arch/x86_64.c:            (const iree_elf_rela_t*)(state->vaddr_bias + dyn->d_un.d_ptr);
../../local/elf/arch/x86_64.c:        rela_count = dyn->d_un.d_val / sizeof(iree_elf_rela_t);
../../local/elf/arch/x86_64.c:        if (dyn->d_un.d_val != IREE_ELF_DT_RELA) {
../../local/elf/arch/x86_64.c:            (const iree_elf_rela_t*)(state->vaddr_bias + dyn->d_un.d_ptr);
../../local/elf/arch/x86_64.c:        plt_rela_count = dyn->d_un.d_val / sizeof(iree_elf_rela_t);
../../local/elf/arch/x86_64.c:// Cross-ABI function calls
../../local/elf/arch/x86_64.c:// https://github.com/hjl-tools/x86-psABI/wiki/x86-64-psABI-1.0.pdf
../../local/plugins/static_plugin.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/plugins/static_plugin.c:  plugin->host_allocator = host_allocator;
../../local/plugins/static_plugin.c:      /*resolve_thunk=*/NULL, host_allocator, &plugin->base);
../../local/plugins/static_plugin.c:  iree_allocator_t host_allocator = plugin->host_allocator;
../../local/elf/platform/generic.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/elf/platform/generic.c:  // No-op.
../../local/elf/platform/generic.c:  // No-op.
../../local/BUILD.bazel:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/elf/platform/windows.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/elf/platform/windows.c:// https://docs.microsoft.com/en-us/windows/win32/memory/memory-protection-constants
../../local/elf/testdata/BUILD.bazel:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/elf/arch/riscv.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/elf/arch/riscv.c:// https://github.com/riscv/riscv-elf-psabi-doc/blob/master/riscv-elf.md
../../local/elf/arch/riscv.c:    uint32_t type = IREE_ELF_R_TYPE(rela->r_info);
../../local/elf/arch/riscv.c:    uint32_t sym_ordinal = (uint32_t)IREE_ELF_R_SYM(rela->r_info);
../../local/elf/arch/riscv.c:      if (sym_ordinal >= state->dynsym_count) {
../../local/elf/arch/riscv.c:      sym_addr = (iree_elf_addr_t)state->vaddr_bias +
../../local/elf/arch/riscv.c:                 state->dynsym[sym_ordinal].st_value;
../../local/elf/arch/riscv.c:        (iree_elf_addr_t)state->vaddr_bias + rela->r_offset;
../../local/elf/arch/riscv.c:        *(uint32_t*)instr_ptr = (uint32_t)(sym_addr + rela->r_addend);
../../local/elf/arch/riscv.c:        *(uint32_t*)instr_ptr = (uint32_t)(state->vaddr_bias + rela->r_addend);
../../local/elf/arch/riscv.c:    uint32_t type = IREE_ELF_R_TYPE(rela->r_info);
../../local/elf/arch/riscv.c:    uint32_t sym_ordinal = (uint32_t)IREE_ELF_R_SYM(rela->r_info);
../../local/elf/arch/riscv.c:      if (sym_ordinal >= state->dynsym_count) {
../../local/elf/arch/riscv.c:      sym_addr = (iree_elf_addr_t)state->vaddr_bias +
../../local/elf/arch/riscv.c:                 state->dynsym[sym_ordinal].st_value;
../../local/elf/arch/riscv.c:        (iree_elf_addr_t)state->vaddr_bias + rela->r_offset;
../../local/elf/arch/riscv.c:        *(uint32_t*)instr_ptr = (uint32_t)(sym_addr + rela->r_addend);
../../local/elf/arch/riscv.c:        *(uint64_t*)instr_ptr = (uint64_t)(sym_addr + rela->r_addend);
../../local/elf/arch/riscv.c:        *(uint64_t*)instr_ptr = (uint64_t)(state->vaddr_bias + rela->r_addend);
../../local/elf/arch/riscv.c:  for (iree_host_size_t i = 0; i < state->dyn_table_count; ++i) {
../../local/elf/arch/riscv.c:    const iree_elf_dyn_t* dyn = &state->dyn_table[i];
../../local/elf/arch/riscv.c:    switch (dyn->d_tag) {
../../local/elf/arch/riscv.c:            (const iree_elf_rela_t*)(state->vaddr_bias + dyn->d_un.d_ptr);
../../local/elf/arch/riscv.c:        rela_count = dyn->d_un.d_val / sizeof(iree_elf_rela_t);
../../local/elf/arch/riscv.c:// Cross-ABI function calls
../../local/elf/testdata/generate.sh:# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/elf/testdata/generate.sh:# Updates the checked-in ELF files used for testing the ELF loader.
../../local/elf/testdata/generate.sh:# happens every few months as we are not yet binary-stable but in the future
../../local/elf/testdata/generate.sh:# To use, ensure iree-compile and your compiled ld.lld are on your PATH and
../../local/elf/testdata/generate.sh:# Uncomment to see the iree-compile commands issued:
../../local/elf/testdata/generate.sh:# set -x
../../local/elf/testdata/generate.sh:set -e
../../local/elf/testdata/generate.sh:ROOT_DIR=$(git rev-parse --show-toplevel)
../../local/elf/testdata/generate.sh:# $2: list of iree-compile arguments for targeting
../../local/elf/testdata/generate.sh:    iree-compile
../../local/elf/testdata/generate.sh:      --compile-mode=hal-executable
../../local/elf/testdata/generate.sh:      -o="${TESTDATA}/${so_name}"
../../local/elf/testdata/generate.sh:      --iree-hal-target-device=local
../../local/elf/testdata/generate.sh:      --iree-hal-local-target-device-backends=llvm-cpu
../../local/elf/testdata/generate.sh:      --iree-llvmcpu-debug-symbols=false
../../local/elf/testdata/generate.sh:  --iree-llvmcpu-target-triple=armv7a-pc-linux-elf
../../local/elf/testdata/generate.sh:  --iree-llvmcpu-target-float-abi=hard
../../local/elf/testdata/generate.sh:  --iree-llvmcpu-target-triple=aarch64-pc-linux-elf
../../local/elf/testdata/generate.sh:  --iree-llvmcpu-target-triple=riscv32-pc-linux-elf
../../local/elf/testdata/generate.sh:  --iree-llvmcpu-target-cpu=generic-rv32
../../local/elf/testdata/generate.sh:  --iree-llvmcpu-target-cpu-features=+m,+f
../../local/elf/testdata/generate.sh:  --iree-llvmcpu-target-abi=ilp32
../../local/elf/testdata/generate.sh:  --iree-llvmcpu-target-triple=riscv64-pc-linux-elf
../../local/elf/testdata/generate.sh:  --iree-llvmcpu-target-cpu=generic-rv64
../../local/elf/testdata/generate.sh:  --iree-llvmcpu-target-cpu-features=+m,+a,+f,+d,+c
../../local/elf/testdata/generate.sh:  --iree-llvmcpu-target-abi=lp64d
../../local/elf/testdata/generate.sh:  --iree-llvmcpu-target-triple=i686-pc-linux-elf
../../local/elf/testdata/generate.sh:  --iree-llvmcpu-target-triple=x86_64-pc-linux-elf
../../file.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/elf/testdata/elementwise_mul.mlir:// perform workgroup-level tiling.
../../local/elf/testdata/elementwise_mul.mlir://    --executable_format=embedded-elf \
../../local/elf/testdata/elementwise_mul.mlir://    --executable_file=iree/hal/local/elf/testdata/elementwise_mul_x86_64.so \
../../local/elf/testdata/elementwise_mul.mlir://    --entry_point=0 \
../../local/elf/testdata/elementwise_mul.mlir://    --workgroup_count_x=1 \
../../local/elf/testdata/elementwise_mul.mlir://    --workgroup_count_y=1 \
../../local/elf/testdata/elementwise_mul.mlir://    --workgroup_count_z=1 \
../../local/elf/testdata/elementwise_mul.mlir://    --workgroup_size_x=1 \
../../local/elf/testdata/elementwise_mul.mlir://    --workgroup_size_y=1 \
../../local/elf/testdata/elementwise_mul.mlir://    --workgroup_size_z=1 \
../../local/elf/testdata/elementwise_mul.mlir://    --binding=4xf32=1,2,3,4 \
../../local/elf/testdata/elementwise_mul.mlir://    --binding=4xf32=100,200,300,400 \
../../local/elf/testdata/elementwise_mul.mlir://    --binding=4xf32=0,0,0,0
../../local/elf/testdata/elementwise_mul.mlir:// as linking and multi-executable embedding support requires our host-side IR.
../../local/elf/testdata/elementwise_mul.mlir:  // contain other information - though when hand-authoring that's usually
../../local/elf/testdata/elementwise_mul.mlir:  hal.executable.export public @elementwise_mul ordinal(0) layout(#pipeline_layout) count(%arg0: !hal.device) -> (index, index, index) {
../../local/elf/testdata/elementwise_mul.mlir:      %base_i = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_id_x, %workgroup_size_x]
../../local/elf/testdata/elementwise_mul.mlir:      %step_i = affine.apply affine_map<()[s0, s1] -> (s0 * s1)>()[%workgroup_count_x, %workgroup_size_x]
../../local/elf/testdata/elementwise_mul.mlir:        %remaining = affine.min affine_map<(d0)[s0] -> (s0, -d0 + 4)>(%i)[%workgroup_size_x]
../../local/elf/testdata/elementwise_mul.mlir:        %lhs_tile = iree_tensor_ext.dispatch.tensor.load %lhs, offsets = [%i], sizes = [%remaining], strides = [1] : !iree_tensor_ext.dispatch.tensor<readonly:tensor<4xf32>> -> tensor<?xf32>
../../local/elf/testdata/elementwise_mul.mlir:        %rhs_tile = iree_tensor_ext.dispatch.tensor.load %rhs, offsets = [%i], sizes = [%remaining], strides = [1] : !iree_tensor_ext.dispatch.tensor<readonly:tensor<4xf32>> -> tensor<?xf32>
../../local/elf/testdata/elementwise_mul.mlir:          indexing_maps = [affine_map<(d0) -> (d0)>, affine_map<(d0) -> (d0)>, affine_map<(d0) -> (d0)>],
../../local/elf/testdata/elementwise_mul.mlir:          } -> tensor<?xf32>
../../local/elf/testdata/elementwise_mul.mlir:        iree_tensor_ext.dispatch.tensor.store %dst_tile, %dst, offsets = [%i], sizes = [%remaining], strides = [1] : tensor<?xf32> -> !iree_tensor_ext.dispatch.tensor<writeonly:tensor<4xf32>>
../../local/elf/testdata/elementwise_mul_benchmark.txt:--executable_format=embedded-elf
../../local/elf/testdata/elementwise_mul_benchmark.txt:--executable_file=iree/hal/local/elf/testdata/elementwise_mul_x86_64.so
../../local/elf/testdata/elementwise_mul_benchmark.txt:--entry_point=0
../../local/elf/testdata/elementwise_mul_benchmark.txt:--workgroup_count_x=1
../../local/elf/testdata/elementwise_mul_benchmark.txt:--workgroup_count_y=1
../../local/elf/testdata/elementwise_mul_benchmark.txt:--workgroup_count_z=1
../../local/elf/testdata/elementwise_mul_benchmark.txt:--workgroup_size_x=1
../../local/elf/testdata/elementwise_mul_benchmark.txt:--workgroup_size_y=1
../../local/elf/testdata/elementwise_mul_benchmark.txt:--workgroup_size_z=1
../../local/elf/testdata/elementwise_mul_benchmark.txt:--max_concurrency=1
../../local/elf/testdata/elementwise_mul_benchmark.txt:--binding=4xf32=1,2,3,4
../../local/elf/testdata/elementwise_mul_benchmark.txt:--binding=4xf32=100,200,300,400
../../local/elf/testdata/elementwise_mul_benchmark.txt:--binding=4xf32=0,0,0,0
../../semaphore.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../semaphore.c://===----------------------------------------------------------------------===//
../../semaphore.c://===----------------------------------------------------------------------===//
../../semaphore.c://===----------------------------------------------------------------------===//
../../semaphore.c://===----------------------------------------------------------------------===//
../../semaphore.c:          ((const iree_wait_source_wait_params_t*)params)->timeout;
../../semaphore.c:          ((const iree_wait_source_export_params_t*)params)->target_type;
../../semaphore.c://===----------------------------------------------------------------------===//
../../semaphore.c://===----------------------------------------------------------------------===//
../../semaphore.c:    const bool is_last = i == semaphore_list.count - 1;
../../semaphore.c:  // the user-intended relative timeout.
../../semaphore.c:  // no device-side batching. We should probably expose this as a device method
../../semaphore.c:  IREE_ASSERT(i >= 0 && i < semaphore_list->count);
../../semaphore.c:  IREE_ASSERT(j >= 0 && j < semaphore_list->count);
../../semaphore.c:  iree_hal_semaphore_t* tmp_semaphore = semaphore_list->semaphores[i];
../../semaphore.c:  uint64_t tmp_payload_value = semaphore_list->payload_values[i];
../../semaphore.c:  semaphore_list->semaphores[i] = semaphore_list->semaphores[j];
../../semaphore.c:  semaphore_list->payload_values[i] = semaphore_list->payload_values[j];
../../semaphore.c:  semaphore_list->semaphores[j] = tmp_semaphore;
../../semaphore.c:  semaphore_list->payload_values[j] = tmp_payload_value;
../../semaphore.c:  IREE_ASSERT(semaphore_list->count > 0);
../../semaphore.c:                                        semaphore_list->count - 1);
../../semaphore.c:  --semaphore_list->count;
../../buffer_heap_impl.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../buffer_heap_impl.h://===----------------------------------------------------------------------===//
../../buffer_heap_impl.h://===----------------------------------------------------------------------===//
../../device.h:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../device.h://===----------------------------------------------------------------------===//
../../device.h://===----------------------------------------------------------------------===//
../../device.h:// An opaque driver-specific handle to identify different devices.
../../device.h:  // disassembly or fine-grained breakpoint insertion.
../../device.h:  // Stable driver-specific path used to reference the device.
../../device.h:  // Human-readable name of the device as returned by the API.
../../device.h:  // transfer/dispatch commands within them. This gives a high-level overview
../../device.h:// Defines how a multi-wait operation treats the results of multiple semaphores.
../../device.h://===----------------------------------------------------------------------===//
../../device.h://===----------------------------------------------------------------------===//
../../device.h:// Vulkan device may return `vulkan-v1.1` or `vulkan-v1.2-spec1`.
../../device.h:// WARNING: this is not thread-safe and must only be performed when the device
../../device.h:// approach would be to replace the singular allocator with queue-specific pools
../../device.h:// WARNING: this is not thread-safe and must only be performed when the device
../../device.h:// allocations. This can be used on low-memory conditions or when
../../device.h:// in a device-specific way and if recognized the value will be converted to an
../../device.h:// (https://man7.org/linux/man-pages/man3/sysconf.3.html) in that the exact
../../device.h:// target-dependent.
../../device.h:// Well-known queries (category :: key):
../../device.h://   hal.device.id :: some-pattern-*
../../device.h://   hal.device.feature :: some-pattern-*
../../device.h://   hal.device.architecture :: some-pattern-*
../../device.h://   hal.executable.format :: some-pattern-*
../../device.h:// Reserves and returns a device-local queue-ordered transient buffer.
../../device.h:// Deallocates a queue-ordered transient buffer.
../../device.h:// Deallocations will only be queue-ordered if the |buffer| was originally
../../device.h:// Enqueues a single queue-ordered fill operation.
../../device.h:// Enqueues a single queue-ordered buffer update operation.
../../device.h:// poorly if the size is larger than an implementation-defined limit. Updates
../../device.h:// Enqueues a single queue-ordered copy operation.
../../device.h:// and the target buffer must have transfer-target usage.
../../device.h:// transfer-source usage and the target file must have write permission.
../../device.h:// command buffers to complete out-of-order. See:
../../device.h:// https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/vkQueueSubmit.html
../../device.h:// Flushes any locally-pending submissions in the queue.
../../device.h:// This will use an implementation-defined profiling API to capture all
../../device.h:// this method is a no-op. See implementation-specific device creation APIs and
../../device.h:// undefined if there are any in-flight or pending queue operations or access
../../device.h:// When measuring end-to-end performance use only
../../device.h:// - CPU: perf_event_open/close or vendor APIs
../../device.h:// - CUDA: cuProfilerStart/cuProfilerStop
../../device.h:// - Direct3D: PIXBeginCapture/PIXEndCapture
../../device.h:// - Metal: [MTLCaptureManager startCapture/stopCapture]
../../device.h:// - Vulkan: vkAcquireProfilingLockKHR/vkReleaseProfilingLockKHR +
../../device.h:// Flushes any pending profiling data. May be a no-op.
../../device.h://===----------------------------------------------------------------------===//
../../device.h://===----------------------------------------------------------------------===//
../../device.h:// A fixed-size list of retained devices.
../../device.h://===----------------------------------------------------------------------===//
../../device.h://===----------------------------------------------------------------------===//
../../local/elf/arch/x86_64_msvc.asm:; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/elf/arch/x86_64_msvc.asm:; https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention
../../local/elf/arch/x86_64_msvc.asm:; Non-volatile:
../../local/elf/arch/x86_64_msvc.asm:;   RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15, and XMM6-XMM15
../../local/elf/arch/x86_64_msvc.asm:; https://github.com/hjl-tools/x86-psABI/wiki/x86-64-psABI-1.0.pdf
../../local/elf/arch/x86_64_msvc.asm:; Total size of non-volatile XMM registers.
../../local/elf/arch/x86_64_msvc.asm:; following the SYS-V x64 ABI.
../../local/elf/arch/x86_64_msvc.asm:; https://docs.microsoft.com/en-us/cpp/build/exception-handling-x64?view=msvc-160#unwind-helpers-for-masm
../../local/elf/arch/x86_64_msvc.asm:  ; NOTE: we adjust this by 8 bytes to get on a 16-byte alignment so we can
../../local/elf/arch/x86_64_msvc.asm:; code following the SYS-V x64 ABI.
../../local/elf/arch/x86_64_msvc.asm:  ; RDX = a0         <- RDI
../../local/elf/arch/x86_64_msvc.asm:  ; R8  = a1         <- RSI
../../local/elf/arch/x86_64_msvc.asm:  ; R9  = a2         <- RDX
../../local/elf/arch/x86_64_msvc.asm:  ; RDX = a0         <- RDI
../../local/elf/arch/x86_64_msvc.asm:  ; R8  = a1         <- RSI
../../local/elf/arch/x86_64_msvc.asm:  ; R9  = a2         <- RDX
../../local/elf/arch/x86_64_msvc.asm:  ; RSI = a0         -> RCX
../../local/elf/arch/x86_64_msvc.asm:  ; RDX = a1         -> RDX
../../local/elf/arch/x86_64_msvc.asm:  ; RCX = a2         -> R8
../../local/elf/arch/arm_32.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../local/elf/arch/arm_32.c:    uint32_t type = IREE_ELF_R_TYPE(rel->r_info);
../../local/elf/arch/arm_32.c:    uint32_t sym_ordinal = (uint32_t)IREE_ELF_R_SYM(rel->r_info);
../../local/elf/arch/arm_32.c:      if (sym_ordinal >= state->dynsym_count) {
../../local/elf/arch/arm_32.c:      sym_addr = (iree_elf_addr_t)state->vaddr_bias +
../../local/elf/arch/arm_32.c:                 state->dynsym[sym_ordinal].st_value;
../../local/elf/arch/arm_32.c:        (iree_elf_addr_t)state->vaddr_bias + rel->r_offset;
../../local/elf/arch/arm_32.c:        *(uint32_t*)instr_ptr += (uint32_t)sym_addr - rel->r_offset;
../../local/elf/arch/arm_32.c:        *(uint32_t*)instr_ptr += (uint32_t)state->vaddr_bias;
../../local/elf/arch/arm_32.c:  for (iree_host_size_t i = 0; i < state->dyn_table_count; ++i) {
../../local/elf/arch/arm_32.c:    const iree_elf_dyn_t* dyn = &state->dyn_table[i];
../../local/elf/arch/arm_32.c:    switch (dyn->d_tag) {
../../local/elf/arch/arm_32.c:            (const iree_elf_rel_t*)(state->vaddr_bias + dyn->d_un.d_ptr);
../../local/elf/arch/arm_32.c:        rel_count = dyn->d_un.d_val / sizeof(iree_elf_rel_t);
../../local/elf/arch/arm_32.c:// Cross-ABI function calls
../../allocator.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../allocator.c://===----------------------------------------------------------------------===//
../../allocator.c://===----------------------------------------------------------------------===//
../../allocator.c:      statistics->host_bytes_peak, statistics->host_bytes_allocated,
../../allocator.c:      statistics->host_bytes_freed,
../../allocator.c:      (statistics->host_bytes_allocated - statistics->host_bytes_freed)));
../../allocator.c:      statistics->device_bytes_peak, statistics->device_bytes_allocated,
../../allocator.c:      statistics->device_bytes_freed,
../../allocator.c:      (statistics->device_bytes_allocated - statistics->device_bytes_freed)));
../../allocator.c:  // No-op when disabled.
../../allocator.c://===----------------------------------------------------------------------===//
../../allocator.c://===----------------------------------------------------------------------===//
../../allocator.c:  // No-op.
../../device.c:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
../../device.c://===----------------------------------------------------------------------===//
../../device.c://===----------------------------------------------------------------------===//
../../device.c:  // already-resolved semaphore. This would make using stream-ordered
../../device.c://===----------------------------------------------------------------------===//
../../device.c://===----------------------------------------------------------------------===//
../../device.c:      sizeof(*list) + capacity * sizeof(list->devices[0]);
../../device.c:  list->host_allocator = host_allocator;
../../device.c:  list->capacity = capacity;
../../device.c:  list->count = 0;
../../device.c:  iree_allocator_t host_allocator = list->host_allocator;
../../device.c:  for (iree_host_size_t i = 0; i < list->count; ++i) {
../../device.c:    iree_hal_device_release(list->devices[i]);
../../device.c:  if (list->count + 1 <= list->capacity) {
../../device.c:    list->devices[list->count++] = device;
../../device.c:                              list->capacity);
../../device.c:  return i < list->count ? list->devices[i] : NULL;
